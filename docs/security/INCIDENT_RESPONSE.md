# ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œæ‰‹é †

> **æœ€çµ‚æ›´æ–°**: 2025/08/01  
> **æ–‡æ›¸ç¨®åˆ¥**: æ­£å¼ä»•æ§˜æ›¸  
> **æ›´æ–°é »åº¦**: åŠå¹´æ›´æ–°

## æ¦‚è¦

insurance_gameãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ãŠã‘ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã®å¯¾å¿œæ‰‹é †ã‚’å®šç¾©ã—ã¾ã™ã€‚è¿…é€Ÿã‹ã¤é©åˆ‡ãªå¯¾å¿œã«ã‚ˆã‚Šã€è¢«å®³ã®æœ€å°åŒ–ã¨æ—©æœŸå¾©æ—§ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

## 1. ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã®åŸºæœ¬æ–¹é‡

### 1.1 å¯¾å¿œåŸå‰‡

#### è¿…é€Ÿæ€§
- **åˆå‹•å¯¾å¿œ**: æ¤œçŸ¥ã‹ã‚‰1æ™‚é–“ä»¥å†…ã®åˆå‹•å¯¾å¿œ
- **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: é‡è¦åº¦ã«å¿œã˜ãŸè¿…é€Ÿãªã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
- **æƒ…å ±å…±æœ‰**: é–¢ä¿‚è€…ã¸ã®è¿…é€Ÿãªæƒ…å ±å…±æœ‰

#### æœ€å°åŒ–
- **è¢«å®³æœ€å°åŒ–**: å½±éŸ¿ç¯„å›²ã®ç‰¹å®šã¨æ‹¡å¤§é˜²æ­¢
- **å¾©æ—§å„ªå…ˆ**: å¯èƒ½ãªé™ã‚Šè¿…é€Ÿãªã‚µãƒ¼ãƒ“ã‚¹å¾©æ—§
- **è¨¼æ‹ ä¿å…¨**: å°†æ¥ã®åˆ†æã®ãŸã‚ã®è¨¼æ‹ ä¿å…¨

#### é€æ˜æ€§
- **è¨˜éŒ²**: ã™ã¹ã¦ã®å¯¾å¿œæ´»å‹•ã®è©³ç´°è¨˜éŒ²
- **å ±å‘Š**: é©åˆ‡ãªé–¢ä¿‚è€…ã¸ã®å ±å‘Š
- **å­¦ç¿’**: ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã‹ã‚‰ã®å­¦ç¿’ã¨æ”¹å–„

### 1.2 å¯¾å¿œä½“åˆ¶

#### ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒãƒ¼ãƒ ï¼ˆIRTï¼‰
- **ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæŒ‡æ®å®˜**: å¯¾å¿œå…¨ä½“ã®æŒ‡æ®ãƒ»èª¿æ•´
- **æŠ€è¡“èª¿æŸ»æ‹…å½“**: æŠ€è¡“çš„åˆ†æãƒ»å¯¾ç­–å®Ÿè£…
- **ã‚³ãƒŸãƒ¥ãƒ‹ã‚±ãƒ¼ã‚·ãƒ§ãƒ³æ‹…å½“**: å†…å¤–ã¸ã®é€£çµ¡ãƒ»å ±å‘Š
- **è¨˜éŒ²æ‹…å½“**: å¯¾å¿œæ´»å‹•ã®è¨˜éŒ²ãƒ»æ–‡æ›¸åŒ–

#### ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ä½“åˆ¶
- **Level 1**: è»½å¾®ãªã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆï¼ˆé–‹ç™ºè€…ãƒ¬ãƒ™ãƒ«ï¼‰
- **Level 2**: é‡è¦ãªã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆï¼ˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒªãƒ¼ãƒ€ãƒ¼ï¼‰
- **Level 3**: é‡å¤§ãªã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆï¼ˆçµ„ç¹”ç®¡ç†è€…ï¼‰
- **Level 4**: è‡´å‘½çš„ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆï¼ˆå¤–éƒ¨å°‚é–€å®¶ï¼‰

## 2. ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆåˆ†é¡

### 2.1 é‡è¦åº¦ãƒ¬ãƒ™ãƒ«

#### Criticalï¼ˆç·Šæ€¥ï¼‰
- **å½±éŸ¿**: ã‚µãƒ¼ãƒ“ã‚¹å…¨ä½“ã®åœæ­¢ã€å¤§è¦æ¨¡ãƒ‡ãƒ¼ã‚¿æ¼æ´©
- **å¯¾å¿œæ™‚é–“**: 1æ™‚é–“ä»¥å†…ã®åˆå‹•å¯¾å¿œ
- **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: å³åº§ã«æœ€é«˜ãƒ¬ãƒ™ãƒ«ã¸

**ä¾‹**:
- å€‹äººæƒ…å ±ã®å¤§è¦æ¨¡æ¼æ´©
- ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã¸ã®ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹
- ãƒãƒ«ã‚¦ã‚§ã‚¢æ„ŸæŸ“ã®æ‹¡æ•£
- é‡è¦ãƒ‡ãƒ¼ã‚¿ã®ç ´å£Šãƒ»æ”¹ã–ã‚“

#### Highï¼ˆé«˜ï¼‰
- **å½±éŸ¿**: ä¸»è¦æ©Ÿèƒ½ã®åœæ­¢ã€é™å®šçš„ãƒ‡ãƒ¼ã‚¿æ¼æ´©
- **å¯¾å¿œæ™‚é–“**: 4æ™‚é–“ä»¥å†…ã®åˆå‹•å¯¾å¿œ
- **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: ç®¡ç†å±¤ã¸ã®å ±å‘Š

**ä¾‹**:
- èªè¨¼ã‚·ã‚¹ãƒ†ãƒ ã®ä¾µå®³
- é‡è¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ©Ÿèƒ½ã®ç„¡åŠ¹åŒ–
- é™å®šçš„ãªå€‹äººæƒ…å ±æ¼æ´©
- DDoSæ”»æ’ƒã«ã‚ˆã‚‹éƒ¨åˆ†çš„åœæ­¢

#### Mediumï¼ˆä¸­ï¼‰
- **å½±éŸ¿**: éƒ¨åˆ†çš„æ©Ÿèƒ½ä¸å…¨ã€è»½å¾®ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ä¾µå®³
- **å¯¾å¿œæ™‚é–“**: 24æ™‚é–“ä»¥å†…ã®å¯¾å¿œé–‹å§‹
- **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: é–‹ç™ºãƒãƒ¼ãƒ ãƒªãƒ¼ãƒ€ãƒ¼ã¸å ±å‘Š

**ä¾‹**:
- è»½å¾®ãªXSSè„†å¼±æ€§ã®æ‚ªç”¨
- è¨­å®šãƒŸã‚¹ã«ã‚ˆã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ›ãƒ¼ãƒ«
- ä¸å¯©ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³
- è»½å¾®ãªãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§å•é¡Œ

#### Lowï¼ˆä½ï¼‰
- **å½±éŸ¿**: è»½å¾®ãªå•é¡Œã€æ½œåœ¨çš„ãƒªã‚¹ã‚¯
- **å¯¾å¿œæ™‚é–“**: 7æ—¥ä»¥å†…ã®å¯¾å¿œè¨ˆç”»ç­–å®š
- **ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³**: å®šæœŸå ±å‘Šã§å¯¾å¿œ

**ä¾‹**:
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã§ã®è»½å¾®ãªæ¤œå‡º
- ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§å ±å‘Š
- ä¸é©åˆ‡ãªãƒ­ã‚°å‡ºåŠ›
- è»½å¾®ãªæ¨©é™è¨­å®šãƒŸã‚¹

### 2.2 ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆç¨®åˆ¥

#### ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹
- ã‚·ã‚¹ãƒ†ãƒ ã¸ã®ç„¡è¨±å¯ã‚¢ã‚¯ã‚»ã‚¹
- æ¨©é™æ˜‡æ ¼æ”»æ’ƒ
- ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä¹—ã£å–ã‚Š
- å†…éƒ¨ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹

#### ãƒ‡ãƒ¼ã‚¿é–¢é€£
- å€‹äººæƒ…å ±æ¼æ´©
- ãƒ‡ãƒ¼ã‚¿æ”¹ã–ã‚“ãƒ»ç ´å£Š
- ãƒ‡ãƒ¼ã‚¿ç›—å–
- ãƒ‡ãƒ¼ã‚¿æš—å·åŒ–æ”»æ’ƒ

#### ã‚µãƒ¼ãƒ“ã‚¹å¦¨å®³
- DDoSæ”»æ’ƒ
- ãƒªã‚½ãƒ¼ã‚¹æ¯æ¸‡æ”»æ’ƒ
- ã‚·ã‚¹ãƒ†ãƒ éè² è·
- æ„å›³çš„ãªã‚µãƒ¼ãƒ“ã‚¹åœæ­¢

#### ãƒãƒ«ã‚¦ã‚§ã‚¢
- ã‚¦ã‚¤ãƒ«ã‚¹æ„ŸæŸ“
- ãƒ©ãƒ³ã‚µãƒ ã‚¦ã‚§ã‚¢
- ã‚¹ãƒ‘ã‚¤ã‚¦ã‚§ã‚¢
- ãƒœãƒƒãƒˆãƒãƒƒãƒˆå‚åŠ 

## 3. æ¤œçŸ¥ãƒ»é€šå ±

### 3.1 è‡ªå‹•æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

#### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç›£è¦–
```typescript
// src/utils/incident-detection.ts
export class IncidentDetection {
  private static readonly DETECTION_RULES = {
    rapid_requests: { threshold: 100, timeWindow: 300000 }, // 5åˆ†ã§100å›
    error_spike: { threshold: 50, timeWindow: 600000 },     // 10åˆ†ã§50å›
    failed_auth: { threshold: 10, timeWindow: 900000 },     // 15åˆ†ã§10å›
    data_exfiltration: { threshold: 1000000, timeWindow: 3600000 } // 1æ™‚é–“ã§1MB
  };
  
  // ç•°å¸¸æ¤œçŸ¥ãƒ¡ã‚¤ãƒ³å‡¦ç†
  static detectAnomalies(): void {
    this.checkRapidRequests();
    this.checkErrorSpikes();
    this.checkFailedAuthentication();
    this.checkDataExfiltration();
    this.checkSecurityPatterns();
  }
  
  private static checkRapidRequests(): void {
    const recentRequests = this.getRecentAccessLogs(this.DETECTION_RULES.rapid_requests.timeWindow);
    
    if (recentRequests.length > this.DETECTION_RULES.rapid_requests.threshold) {
      this.triggerIncident({
        type: 'rapid_requests',
        severity: 'medium',
        description: 'Unusual number of requests detected',
        details: {
          requestCount: recentRequests.length,
          timeWindow: this.DETECTION_RULES.rapid_requests.timeWindow,
          sourceIPs: this.extractUniqueIPs(recentRequests)
        },
        evidence: recentRequests.slice(-10) // ç›´è¿‘10ä»¶
      });
    }
  }
  
  private static checkSecurityPatterns(): void {
    const recentLogs = this.getRecentSecurityLogs(3600000); // 1æ™‚é–“
    
    // XSSæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
    const xssAttempts = recentLogs.filter(log => 
      this.containsXSSPattern(log.request)
    );
    
    if (xssAttempts.length > 5) {
      this.triggerIncident({
        type: 'xss_attack',
        severity: 'high',
        description: 'Multiple XSS attack attempts detected',
        details: {
          attemptCount: xssAttempts.length,
          patterns: xssAttempts.map(attempt => attempt.pattern)
        },
        evidence: xssAttempts
      });
    }
    
    // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
    const sqlInjectionAttempts = recentLogs.filter(log => 
      this.containsSQLInjectionPattern(log.request)
    );
    
    if (sqlInjectionAttempts.length > 3) {
      this.triggerIncident({
        type: 'sql_injection',
        severity: 'critical',
        description: 'SQL injection attack attempts detected',
        details: {
          attemptCount: sqlInjectionAttempts.length,
          patterns: sqlInjectionAttempts.map(attempt => attempt.pattern)
        },
        evidence: sqlInjectionAttempts
      });
    }
  }
  
  private static triggerIncident(incident: IncidentAlert): void {
    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆè¨˜éŒ²
    this.recordIncident(incident);
    
    // è‡ªå‹•å¯¾å¿œã®å®Ÿè¡Œ
    this.executeAutomaticResponse(incident);
    
    // ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
    this.sendAlert(incident);
    
    // ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¤å®š
    if (this.requiresEscalation(incident)) {
      this.escalateIncident(incident);
    }
  }
  
  private static executeAutomaticResponse(incident: IncidentAlert): void {
    switch (incident.type) {
      case 'rapid_requests':
        this.implementRateLimit(incident.details.sourceIPs);
        break;
      case 'xss_attack':
        this.blockSuspiciousRequests(incident.evidence);
        break;
      case 'sql_injection':
        this.emergencySecurityLockdown();
        break;
    }
  }
  
  private static emergencySecurityLockdown(): void {
    // ç·Šæ€¥ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ãƒƒã‚¯ãƒ€ã‚¦ãƒ³
    console.warn('ğŸš¨ EMERGENCY SECURITY LOCKDOWN INITIATED');
    
    // è¿½åŠ ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
    this.enhanceSecurityHeaders();
    
    // ä¸å¯©ãªãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯
    this.activateStrictFiltering();
    
    // ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã®å‘ä¸Š
    this.increaseLogLevel();
  }
}

interface IncidentAlert {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  details: any;
  evidence: any[];
}
```

### 3.2 æ‰‹å‹•é€šå ±

#### é€šå ±ãƒãƒ£ãƒ³ãƒãƒ«
- **GitHub Issues**: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ©ãƒ™ãƒ«ä»˜ãIssue
- **ãƒ¡ãƒ¼ãƒ«**: security@project.comï¼ˆè¨­å®šæ™‚ï¼‰
- **Discord/Slack**: ç·Šæ€¥ãƒãƒ£ãƒ³ãƒãƒ«ï¼ˆè¨­å®šæ™‚ï¼‰

#### é€šå ±ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
```markdown
## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå ±å‘Š

### åŸºæœ¬æƒ…å ±
- **ç™ºè¦‹æ—¥æ™‚**: YYYY/MM/DD HH:MM
- **ç™ºè¦‹è€…**: [åå‰]
- **é‡è¦åº¦**: [Critical/High/Medium/Low]
- **ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆç¨®åˆ¥**: [ä¸æ­£ã‚¢ã‚¯ã‚»ã‚¹/ãƒ‡ãƒ¼ã‚¿æ¼æ´©/ã‚µãƒ¼ãƒ“ã‚¹å¦¨å®³/ãƒãƒ«ã‚¦ã‚§ã‚¢/ãã®ä»–]

### ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆè©³ç´°
- **æ¦‚è¦**: [ä½•ãŒç™ºç”Ÿã—ãŸã‹]
- **å½±éŸ¿ç¯„å›²**: [å½±éŸ¿ã‚’å—ã‘ã‚‹ã‚·ã‚¹ãƒ†ãƒ ãƒ»ãƒ‡ãƒ¼ã‚¿ãƒ»ãƒ¦ãƒ¼ã‚¶ãƒ¼]
- **æ¨å®šåŸå› **: [åŸå› ã®æ¨æ¸¬]
- **ç¾åœ¨ã®çŠ¶æ³**: [é€²è¡Œä¸­/æ²ˆé™åŒ–/èª¿æŸ»ä¸­]

### è¨¼æ‹ æƒ…å ±
- **ãƒ­ã‚°**: [é–¢é€£ã™ã‚‹ãƒ­ã‚°ã®æŠœç²‹]
- **ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ**: [å¿…è¦ã«å¿œã˜ã¦]
- **ãã®ä»–**: [ãã®ä»–ã®è¨¼æ‹ ]

### ç·Šæ€¥åº¦åˆ¤å®š
- [ ] å³åº§ã®å¯¾å¿œãŒå¿…è¦
- [ ] 24æ™‚é–“ä»¥å†…ã®å¯¾å¿œãŒå¿…è¦
- [ ] é€šå¸¸ã®å¯¾å¿œãƒ—ãƒ­ã‚»ã‚¹ã§å¯¾å¿œå¯èƒ½

### åˆæœŸå¯¾å¿œ
- **å®Ÿæ–½æ¸ˆã¿å¯¾å¿œ**: [æ—¢ã«å®Ÿæ–½ã—ãŸå¯¾å¿œ]
- **æ¨å¥¨å¯¾å¿œ**: [æ¨å¥¨ã•ã‚Œã‚‹å¯¾å¿œ]
```

## 4. åˆæœŸå¯¾å¿œ

### 4.1 ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆç¢ºèª

#### ç¢ºèªæ‰‹é †
1. **äº‹å®Ÿç¢ºèª**: å ±å‘Šå†…å®¹ã®æ­£ç¢ºæ€§ç¢ºèª
2. **å½±éŸ¿ç¯„å›²ç‰¹å®š**: è¢«å®³ã®ç¯„å›²ã¨ç¨‹åº¦ã®æŠŠæ¡
3. **é‡è¦åº¦åˆ¤å®š**: ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã®æ±ºå®š
4. **å¯¾å¿œãƒãƒ¼ãƒ æ‹›é›†**: å¿…è¦ãªäººå“¡ã®æ‹›é›†

#### åˆæœŸè©•ä¾¡ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
```typescript
// src/utils/incident-assessment.ts
export class IncidentAssessment {
  static assessIncident(report: IncidentReport): AssessmentResult {
    const assessment: AssessmentResult = {
      confirmed: false,
      severity: 'low',
      impactScope: [],
      riskLevel: 'low',
      recommendedActions: [],
      escalationRequired: false
    };
    
    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã®ç¢ºèª
    assessment.confirmed = this.confirmIncident(report);
    
    if (assessment.confirmed) {
      // é‡è¦åº¦è©•ä¾¡
      assessment.severity = this.evaluateSeverity(report);
      
      // å½±éŸ¿ç¯„å›²ç‰¹å®š
      assessment.impactScope = this.identifyImpactScope(report);
      
      // ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«è©•ä¾¡
      assessment.riskLevel = this.evaluateRiskLevel(assessment.severity, assessment.impactScope);
      
      // æ¨å¥¨ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
      assessment.recommendedActions = this.generateRecommendedActions(assessment);
      
      // ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³è¦å¦
      assessment.escalationRequired = this.requiresEscalation(assessment);
    }
    
    return assessment;
  }
  
  private static evaluateSeverity(report: IncidentReport): Severity {
    let score = 0;
    
    // ãƒ‡ãƒ¼ã‚¿ã®æ©Ÿå¯†æ€§
    if (report.dataInvolved) {
      if (report.personalDataInvolved) score += 30;
      if (report.sensitiveDataInvolved) score += 20;
    }
    
    // ã‚·ã‚¹ãƒ†ãƒ ã®å¯ç”¨æ€§
    if (report.serviceImpact) {
      if (report.serviceImpact === 'complete_outage') score += 40;
      if (report.serviceImpact === 'partial_outage') score += 20;
      if (report.serviceImpact === 'performance_degradation') score += 10;
    }
    
    // æ”»æ’ƒã®å·§å¦™ã•
    if (report.attackSophistication === 'high') score += 15;
    if (report.attackSophistication === 'medium') score += 10;
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®å½±éŸ¿
    if (report.userImpact === 'all_users') score += 25;
    if (report.userImpact === 'some_users') score += 15;
    
    if (score >= 70) return 'critical';
    if (score >= 40) return 'high';
    if (score >= 20) return 'medium';
    return 'low';
  }
  
  private static identifyImpactScope(report: IncidentReport): string[] {
    const scope: string[] = [];
    
    if (report.systemsAffected) {
      scope.push(...report.systemsAffected);
    }
    
    if (report.dataInvolved) {
      scope.push('user_data');
    }
    
    if (report.serviceImpact) {
      scope.push('service_availability');
    }
    
    return scope;
  }
}

interface IncidentReport {
  id: string;
  timestamp: number;
  type: string;
  description: string;
  dataInvolved: boolean;
  personalDataInvolved: boolean;
  sensitiveDataInvolved: boolean;
  serviceImpact: 'none' | 'performance_degradation' | 'partial_outage' | 'complete_outage';
  attackSophistication: 'low' | 'medium' | 'high';
  userImpact: 'no_users' | 'some_users' | 'many_users' | 'all_users';
  systemsAffected: string[];
}

interface AssessmentResult {
  confirmed: boolean;
  severity: Severity;
  impactScope: string[];
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  recommendedActions: string[];
  escalationRequired: boolean;
}

type Severity = 'low' | 'medium' | 'high' | 'critical';
```

### 4.2 å°ã˜è¾¼ã‚

#### ç·Šæ€¥å¯¾å¿œã‚¢ã‚¯ã‚·ãƒ§ãƒ³
```typescript
// src/utils/containment-actions.ts
export class ContainmentActions {
  // ç·Šæ€¥å°ã˜è¾¼ã‚å‡¦ç†
  static executeEmergencyContainment(incident: IncidentReport): ContainmentResult {
    const actions: ContainmentAction[] = [];
    
    switch (incident.type) {
      case 'unauthorized_access':
        actions.push(...this.containUnauthorizedAccess(incident));
        break;
      case 'data_breach':
        actions.push(...this.containDataBreach(incident));
        break;
      case 'ddos_attack':
        actions.push(...this.containDDoSAttack(incident));
        break;
      case 'malware_infection':
        actions.push(...this.containMalware(incident));
        break;
    }
    
    return this.executeActions(actions);
  }
  
  private static containUnauthorizedAccess(incident: IncidentReport): ContainmentAction[] {
    return [
      {
        type: 'isolate_affected_systems',
        priority: 'immediate',
        description: 'Isolate compromised systems',
        implementation: () => this.isolateAffectedSystems(incident.systemsAffected)
      },
      {
        type: 'revoke_credentials',
        priority: 'immediate',
        description: 'Revoke potentially compromised credentials',
        implementation: () => this.revokeCredentials()
      },
      {
        type: 'enable_enhanced_monitoring',
        priority: 'urgent',
        description: 'Enable enhanced security monitoring',
        implementation: () => this.enhanceMonitoring()
      }
    ];
  }
  
  private static containDataBreach(incident: IncidentReport): ContainmentAction[] {
    return [
      {
        type: 'stop_data_flow',
        priority: 'immediate',
        description: 'Stop unauthorized data access',
        implementation: () => this.stopDataFlow()
      },
      {
        type: 'preserve_evidence',
        priority: 'immediate',
        description: 'Preserve forensic evidence',
        implementation: () => this.preserveEvidence()
      },
      {
        type: 'assess_data_exposure',
        priority: 'urgent',
        description: 'Assess scope of data exposure',
        implementation: () => this.assessDataExposure()
      }
    ];
  }
  
  private static isolateAffectedSystems(systems: string[]): boolean {
    try {
      // ã‚·ã‚¹ãƒ†ãƒ ã®éš”é›¢å‡¦ç†ï¼ˆå®Ÿè£…ã¯ç’°å¢ƒã«ä¾å­˜ï¼‰
      console.warn(`ğŸ”’ Isolating systems: ${systems.join(', ')}`);
      
      // ç·Šæ€¥ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®é©ç”¨
      this.applyEmergencySecuritySettings();
      
      // ã‚¢ã‚¯ã‚»ã‚¹åˆ¶é™ã®å¼·åŒ–
      this.tightenAccessControls();
      
      return true;
    } catch (error) {
      console.error('System isolation failed:', error);
      return false;
    }
  }
  
  private static applyEmergencySecuritySettings(): void {
    // å³æ ¼ãªCSPã®é©ç”¨
    const strictCSP = [
      "default-src 'self'",
      "script-src 'self'",
      "style-src 'self'",
      "img-src 'self'",
      "connect-src 'self'",
      "frame-src 'none'",
      "object-src 'none'"
    ].join('; ');
    
    const meta = document.createElement('meta');
    meta.httpEquiv = 'Content-Security-Policy';
    meta.content = strictCSP;
    document.head.appendChild(meta);
    
    // è¿½åŠ ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼
    this.addSecurityHeader('X-Frame-Options', 'DENY');
    this.addSecurityHeader('X-Content-Type-Options', 'nosniff');
    this.addSecurityHeader('X-XSS-Protection', '1; mode=block');
  }
  
  private static preserveEvidence(): boolean {
    try {
      // ãƒ­ã‚°ã®ä¿å…¨
      const currentLogs = this.collectCurrentLogs();
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ä»˜ãã§ä¿å­˜
      const evidenceData = {
        timestamp: Date.now(),
        logs: currentLogs,
        systemState: this.captureSystemState(),
        networkState: this.captureNetworkState()
      };
      
      // æ”¹ã–ã‚“é˜²æ­¢ã®ãŸã‚ã®ãƒãƒƒã‚·ãƒ¥
      const evidenceHash = this.calculateHash(JSON.stringify(evidenceData));
      
      localStorage.setItem(`evidence_${Date.now()}`, JSON.stringify({
        data: evidenceData,
        hash: evidenceHash
      }));
      
      return true;
    } catch (error) {
      console.error('Evidence preservation failed:', error);
      return false;
    }
  }
}

interface ContainmentAction {
  type: string;
  priority: 'immediate' | 'urgent' | 'normal';
  description: string;
  implementation: () => boolean;
}

interface ContainmentResult {
  success: boolean;
  actionsExecuted: string[];
  failedActions: string[];
  timestamp: number;
  nextSteps: string[];
}
```

## 5. èª¿æŸ»ãƒ»åˆ†æ

### 5.1 ãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯èª¿æŸ»

#### è¨¼æ‹ åé›†
```typescript
// src/utils/forensic-analysis.ts
export class ForensicAnalysis {
  // ãƒ•ã‚©ãƒ¬ãƒ³ã‚¸ãƒƒã‚¯èª¿æŸ»ã®é–‹å§‹
  static beginInvestigation(incident: IncidentReport): Investigation {
    const investigation: Investigation = {
      id: this.generateInvestigationId(),
      incidentId: incident.id,
      startTime: Date.now(),
      investigator: 'automated_system',
      evidence: [],
      timeline: [],
      findings: [],
      status: 'active'
    };
    
    // è¨¼æ‹ åé›†
    investigation.evidence = this.collectEvidence(incident);
    
    // ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³æ§‹ç¯‰
    investigation.timeline = this.buildTimeline(investigation.evidence);
    
    // åˆæœŸåˆ†æ
    investigation.findings = this.performInitialAnalysis(investigation);
    
    return investigation;
  }
  
  private static collectEvidence(incident: IncidentReport): Evidence[] {
    const evidence: Evidence[] = [];
    
    // ã‚¢ã‚¯ã‚»ã‚¹ãƒ­ã‚°ã®åé›†
    const accessLogs = this.collectAccessLogs(incident.timestamp);
    evidence.push({
      type: 'access_logs',
      timestamp: Date.now(),
      data: accessLogs,
      hash: this.calculateHash(JSON.stringify(accessLogs)),
      source: 'local_storage'
    });
    
    // ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã®åé›†
    const errorLogs = this.collectErrorLogs(incident.timestamp);
    evidence.push({
      type: 'error_logs',
      timestamp: Date.now(),
      data: errorLogs,
      hash: this.calculateHash(JSON.stringify(errorLogs)),
      source: 'console_logs'
    });
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ­ã‚°ã®åé›†
    const securityLogs = this.collectSecurityLogs(incident.timestamp);
    evidence.push({
      type: 'security_logs',
      timestamp: Date.now(),
      data: securityLogs,
      hash: this.calculateHash(JSON.stringify(securityLogs)),
      source: 'security_monitor'
    });
    
    // ã‚·ã‚¹ãƒ†ãƒ çŠ¶æ…‹ã®è¨˜éŒ²
    const systemState = this.captureSystemState();
    evidence.push({
      type: 'system_state',
      timestamp: Date.now(),
      data: systemState,
      hash: this.calculateHash(JSON.stringify(systemState)),
      source: 'runtime_environment'
    });
    
    return evidence;
  }
  
  private static buildTimeline(evidence: Evidence[]): TimelineEvent[] {
    const events: TimelineEvent[] = [];
    
    // å„è¨¼æ‹ ã‹ã‚‰æ™‚ç³»åˆ—ã‚¤ãƒ™ãƒ³ãƒˆã‚’æŠ½å‡º
    evidence.forEach(ev => {
      if (ev.type === 'access_logs') {
        ev.data.forEach((log: any) => {
          events.push({
            timestamp: log.timestamp,
            type: 'access',
            description: `Access to ${log.resource}`,
            source: log.source || 'unknown',
            severity: this.classifyEventSeverity(log)
          });
        });
      }
      
      if (ev.type === 'error_logs') {
        ev.data.forEach((log: any) => {
          events.push({
            timestamp: log.timestamp,
            type: 'error',
            description: log.message,
            source: log.component || 'system',
            severity: log.level === 'error' ? 'high' : 'medium'
          });
        });
      }
    });
    
    // æ™‚ç³»åˆ—é †ã«ã‚½ãƒ¼ãƒˆ
    return events.sort((a, b) => a.timestamp - b.timestamp);
  }
  
  private static performInitialAnalysis(investigation: Investigation): Finding[] {
    const findings: Finding[] = [];
    
    // æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ†æ
    const attackPatterns = this.analyzeAttackPatterns(investigation.evidence);
    if (attackPatterns.length > 0) {
      findings.push({
        type: 'attack_pattern',
        severity: 'high',
        description: 'Suspicious attack patterns detected',
        details: attackPatterns,
        confidence: 0.8
      });
    }
    
    // ç•°å¸¸ãªã‚¢ã‚¯ã‚»ã‚¹ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ¤œå‡º
    const anomalousAccess = this.detectAnomalousAccess(investigation.timeline);
    if (anomalousAccess.length > 0) {
      findings.push({
        type: 'anomalous_access',
        severity: 'medium',
        description: 'Unusual access patterns detected',
        details: anomalousAccess,
        confidence: 0.7
      });
    }
    
    // ãƒ‡ãƒ¼ã‚¿æµå‡ºã®å…†å€™
    const dataExfiltrationSigns = this.detectDataExfiltration(investigation.evidence);
    if (dataExfiltrationSigns.length > 0) {
      findings.push({
        type: 'data_exfiltration',
        severity: 'critical',
        description: 'Potential data exfiltration detected',
        details: dataExfiltrationSigns,
        confidence: 0.9
      });
    }
    
    return findings;
  }
  
  // æ”»æ’ƒè€…ã®æ‰‹æ³•åˆ†æ
  private static analyzeAttackPatterns(evidence: Evidence[]): AttackPattern[] {
    const patterns: AttackPattern[] = [];
    
    const securityLogs = evidence.find(e => e.type === 'security_logs')?.data || [];
    
    // SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
    const sqlInjectionAttempts = securityLogs.filter((log: any) => 
      /('|--|;|union|select|drop|insert|update|delete)/i.test(log.request)
    );
    
    if (sqlInjectionAttempts.length > 3) {
      patterns.push({
        type: 'sql_injection',
        confidence: 0.9,
        attempts: sqlInjectionAttempts.length,
        timespan: this.calculateTimespan(sqlInjectionAttempts),
        indicators: sqlInjectionAttempts.map((attempt: any) => attempt.request)
      });
    }
    
    // XSSæ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
    const xssAttempts = securityLogs.filter((log: any) => 
      /<script|javascript:|on\w+=/i.test(log.request)
    );
    
    if (xssAttempts.length > 5) {
      patterns.push({
        type: 'xss_attack',
        confidence: 0.8,
        attempts: xssAttempts.length,
        timespan: this.calculateTimespan(xssAttempts),
        indicators: xssAttempts.map((attempt: any) => attempt.request)
      });
    }
    
    return patterns;
  }
}

interface Investigation {
  id: string;
  incidentId: string;
  startTime: number;
  investigator: string;
  evidence: Evidence[];
  timeline: TimelineEvent[];
  findings: Finding[];
  status: 'active' | 'completed' | 'suspended';
}

interface Evidence {
  type: string;
  timestamp: number;
  data: any;
  hash: string;
  source: string;
}

interface TimelineEvent {
  timestamp: number;
  type: string;
  description: string;
  source: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

interface Finding {
  type: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  details: any;
  confidence: number;
}

interface AttackPattern {
  type: string;
  confidence: number;
  attempts: number;
  timespan: number;
  indicators: string[];
}
```

### 5.2 æ ¹æœ¬åŸå› åˆ†æ

#### åŸå› ç‰¹å®šãƒ—ãƒ­ã‚»ã‚¹
```typescript
// src/utils/root-cause-analysis.ts
export class RootCauseAnalysis {
  // æ ¹æœ¬åŸå› åˆ†æã®å®Ÿè¡Œ
  static analyzeRootCause(investigation: Investigation): RootCauseReport {
    const report: RootCauseReport = {
      investigationId: investigation.id,
      analysisDate: Date.now(),
      rootCauses: [],
      contributingFactors: [],
      recommendations: [],
      preventiveMeasures: []
    };
    
    // 5 Whysæ‰‹æ³•ã«ã‚ˆã‚‹åŸå› åˆ†æ
    report.rootCauses = this.performFiveWhysAnalysis(investigation);
    
    // å¯„ä¸è¦å› ã®ç‰¹å®š
    report.contributingFactors = this.identifyContributingFactors(investigation);
    
    // æ”¹å–„ææ¡ˆã®ç”Ÿæˆ
    report.recommendations = this.generateRecommendations(report.rootCauses);
    
    // äºˆé˜²æªç½®ã®ææ¡ˆ
    report.preventiveMeasures = this.suggestPreventiveMeasures(report.rootCauses);
    
    return report;
  }
  
  private static performFiveWhysAnalysis(investigation: Investigation): RootCause[] {
    const rootCauses: RootCause[] = [];
    
    investigation.findings.forEach(finding => {
      const analysis = this.analyzeWithFiveWhys(finding);
      if (analysis) {
        rootCauses.push(analysis);
      }
    });
    
    return rootCauses;
  }
  
  private static analyzeWithFiveWhys(finding: Finding): RootCause | null {
    const whyChain: string[] = [];
    
    switch (finding.type) {
      case 'xss_attack':
        whyChain.push('XSS attack was successful');
        whyChain.push('User input was not properly sanitized');
        whyChain.push('Input validation function had a bug');
        whyChain.push('Code review did not catch the bug');
        whyChain.push('Security testing was insufficient');
        break;
        
      case 'unauthorized_access':
        whyChain.push('Unauthorized access occurred');
        whyChain.push('Authentication was bypassed');
        whyChain.push('Session management had a flaw');
        whyChain.push('Security headers were not properly configured');
        whyChain.push('Security best practices were not followed');
        break;
        
      case 'data_exfiltration':
        whyChain.push('Data was exfiltrated');
        whyChain.push('Access controls were insufficient');
        whyChain.push('Data classification was not implemented');
        whyChain.push('Monitoring was inadequate');
        whyChain.push('Security governance was weak');
        break;
    }
    
    if (whyChain.length >= 5) {
      return {
        findingType: finding.type,
        ultimateRootCause: whyChain[whyChain.length - 1],
        causalChain: whyChain,
        confidence: finding.confidence,
        category: this.categorizeCause(whyChain[whyChain.length - 1])
      };
    }
    
    return null;
  }
  
  private static identifyContributingFactors(investigation: Investigation): ContributingFactor[] {
    const factors: ContributingFactor[] = [];
    
    // æŠ€è¡“çš„è¦å› 
    if (this.hasVulnerableComponents(investigation)) {
      factors.push({
        category: 'technical',
        factor: 'Vulnerable dependencies',
        impact: 'high',
        description: 'Outdated or vulnerable third-party components'
      });
    }
    
    // ãƒ—ãƒ­ã‚»ã‚¹è¦å› 
    if (this.hasInsufficientTesting(investigation)) {
      factors.push({
        category: 'process',
        factor: 'Insufficient security testing',
        impact: 'medium',
        description: 'Lack of comprehensive security testing in CI/CD pipeline'
      });
    }
    
    // äººçš„è¦å› 
    if (this.hasSecurityTrainingGaps(investigation)) {
      factors.push({
        category: 'human',
        factor: 'Security awareness gaps',
        impact: 'medium',
        description: 'Insufficient security training for development team'
      });
    }
    
    // ç’°å¢ƒè¦å› 
    if (this.hasConfigurationIssues(investigation)) {
      factors.push({
        category: 'environmental',
        factor: 'Security configuration issues',
        impact: 'high',
        description: 'Improper security configuration in production environment'
      });
    }
    
    return factors;
  }
  
  private static generateRecommendations(rootCauses: RootCause[]): Recommendation[] {
    const recommendations: Recommendation[] = [];
    
    rootCauses.forEach(cause => {
      switch (cause.category) {
        case 'technical':
          recommendations.push({
            category: 'technical',
            priority: 'high',
            title: 'Implement automated security scanning',
            description: 'Set up automated vulnerability scanning in CI/CD pipeline',
            effort: 'medium',
            timeline: '2 weeks'
          });
          break;
          
        case 'process':
          recommendations.push({
            category: 'process',
            priority: 'high',
            title: 'Enhance security review process',
            description: 'Implement mandatory security review for all code changes',
            effort: 'low',
            timeline: '1 week'
          });
          break;
          
        case 'human':
          recommendations.push({
            category: 'human',
            priority: 'medium',
            title: 'Security training program',
            description: 'Implement regular security training for development team',
            effort: 'high',
            timeline: '1 month'
          });
          break;
      }
    });
    
    return recommendations;
  }
}

interface RootCauseReport {
  investigationId: string;
  analysisDate: number;
  rootCauses: RootCause[];
  contributingFactors: ContributingFactor[];
  recommendations: Recommendation[];
  preventiveMeasures: PreventiveMeasure[];
}

interface RootCause {
  findingType: string;
  ultimateRootCause: string;
  causalChain: string[];
  confidence: number;
  category: 'technical' | 'process' | 'human' | 'environmental';
}

interface ContributingFactor {
  category: string;
  factor: string;
  impact: 'low' | 'medium' | 'high';
  description: string;
}

interface Recommendation {
  category: string;
  priority: 'low' | 'medium' | 'high';
  title: string;
  description: string;
  effort: 'low' | 'medium' | 'high';
  timeline: string;
}

interface PreventiveMeasure {
  type: string;
  description: string;
  implementation: string;
  effectiveness: 'low' | 'medium' | 'high';
}
```

## 6. å¾©æ—§ãƒ»æ”¹å–„

### 6.1 ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§

#### å¾©æ—§æ‰‹é †
```typescript
// src/utils/system-recovery.ts
export class SystemRecovery {
  // ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§ãƒ—ãƒ­ã‚»ã‚¹
  static executeRecovery(incident: IncidentReport, analysis: RootCauseReport): RecoveryResult {
    const recovery: RecoveryResult = {
      incidentId: incident.id,
      startTime: Date.now(),
      steps: [],
      success: false,
      rollbackRequired: false
    };
    
    try {
      // 1. ç·Šæ€¥ä¿®æ­£ã®é©ç”¨
      const hotfixResult = this.applyHotfix(incident, analysis);
      recovery.steps.push(hotfixResult);
      
      if (!hotfixResult.success) {
        throw new Error('Hotfix application failed');
      }
      
      // 2. ã‚·ã‚¹ãƒ†ãƒ ã®æ¤œè¨¼
      const validationResult = this.validateSystemIntegrity();
      recovery.steps.push(validationResult);
      
      if (!validationResult.success) {
        throw new Error('System validation failed');
      }
      
      // 3. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã®å®Ÿè£…
      const hardeningResult = this.implementSecurityHardening(analysis);
      recovery.steps.push(hardeningResult);
      
      // 4. ç›£è¦–ã®å¼·åŒ–
      const monitoringResult = this.enhanceMonitoring(incident);
      recovery.steps.push(monitoringResult);
      
      // 5. æœ€çµ‚æ¤œè¨¼
      const finalValidation = this.performFinalValidation();
      recovery.steps.push(finalValidation);
      
      recovery.success = finalValidation.success;
      recovery.endTime = Date.now();
      
    } catch (error) {
      console.error('Recovery failed:', error);
      recovery.success = false;
      recovery.rollbackRequired = true;
      recovery.error = error.message;
    }
    
    return recovery;
  }
  
  private static applyHotfix(incident: IncidentReport, analysis: RootCauseReport): RecoveryStep {
    const step: RecoveryStep = {
      name: 'Apply Hotfix',
      startTime: Date.now(),
      success: false,
      details: []
    };
    
    try {
      analysis.recommendations
        .filter(rec => rec.priority === 'high')
        .forEach(rec => {
          const applied = this.applyRecommendation(rec);
          step.details.push({
            action: rec.title,
            success: applied
          });
        });
      
      // è„†å¼±æ€§ã®ä¿®æ­£
      if (incident.type === 'xss_attack') {
        this.patchXSSVulnerability();
        step.details.push({
          action: 'Patch XSS vulnerability',
          success: true
        });
      }
      
      if (incident.type === 'unauthorized_access') {
        this.strengthenAuthentication();
        step.details.push({
          action: 'Strengthen authentication',
          success: true
        });
      }
      
      step.success = step.details.every(detail => detail.success);
      step.endTime = Date.now();
      
    } catch (error) {
      step.success = false;
      step.error = error.message;
    }
    
    return step;
  }
  
  private static patchXSSVulnerability(): void {
    // XSSè„†å¼±æ€§ã®ç·Šæ€¥ä¿®æ­£
    console.log('ğŸ”§ Patching XSS vulnerability...');
    
    // å…¥åŠ›å€¤æ¤œè¨¼ã®å¼·åŒ–
    this.enhanceInputValidation();
    
    // å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã®å¼·åŒ–
    this.enhanceOutputEscaping();
    
    // CSPã®å¼·åŒ–
    this.strengthenCSP();
  }
  
  private static enhanceInputValidation(): void {
    // ã‚ˆã‚Šå³æ ¼ãªå…¥åŠ›æ¤œè¨¼ãƒ«ãƒ¼ãƒ«ã®é©ç”¨
    const strictValidationRules = {
      playerName: /^[a-zA-Z0-9\s]{1,20}$/,
      gameInput: /^[a-zA-Z0-9\s\-_]{0,100}$/,
      feedback: /^[a-zA-Z0-9\s\-_.,!?]{0,500}$/
    };
    
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«è¨­å®šã«é©ç”¨
    (window as any).STRICT_VALIDATION_RULES = strictValidationRules;
  }
  
  private static validateSystemIntegrity(): RecoveryStep {
    const step: RecoveryStep = {
      name: 'Validate System Integrity',
      startTime: Date.now(),
      success: false,
      details: []
    };
    
    try {
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­å®šã®ç¢ºèª
      const securityCheck = this.checkSecuritySettings();
      step.details.push({
        action: 'Security settings check',
        success: securityCheck
      });
      
      // æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
      const functionalTest = this.runFunctionalTests();
      step.details.push({
        action: 'Functional tests',
        success: functionalTest
      });
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
      const performanceTest = this.runPerformanceTests();
      step.details.push({
        action: 'Performance tests',
        success: performanceTest
      });
      
      step.success = step.details.every(detail => detail.success);
      step.endTime = Date.now();
      
    } catch (error) {
      step.success = false;
      step.error = error.message;
    }
    
    return step;
  }
}

interface RecoveryResult {
  incidentId: string;
  startTime: number;
  endTime?: number;
  steps: RecoveryStep[];
  success: boolean;
  rollbackRequired: boolean;
  error?: string;
}

interface RecoveryStep {
  name: string;
  startTime: number;
  endTime?: number;
  success: boolean;
  details: RecoveryStepDetail[];
  error?: string;
}

interface RecoveryStepDetail {
  action: string;
  success: boolean;
  error?: string;
}
```

### 6.2 å†ç™ºé˜²æ­¢ç­–

#### æ”¹å–„å®Ÿè£…
```typescript
// src/utils/prevention-measures.ts
export class PreventionMeasures {
  // å†ç™ºé˜²æ­¢ç­–ã®å®Ÿè£…
  static implementPreventionMeasures(analysis: RootCauseReport): PreventionResult {
    const result: PreventionResult = {
      analysisId: analysis.investigationId,
      implementationDate: Date.now(),
      measures: [],
      success: false
    };
    
    // æŠ€è¡“çš„äºˆé˜²ç­–
    const technicalMeasures = this.implementTechnicalMeasures(analysis);
    result.measures.push(...technicalMeasures);
    
    // ãƒ—ãƒ­ã‚»ã‚¹æ”¹å–„
    const processMeasures = this.implementProcessMeasures(analysis);
    result.measures.push(...processMeasures);
    
    // ç›£è¦–å¼·åŒ–
    const monitoringMeasures = this.implementMonitoringMeasures(analysis);
    result.measures.push(...monitoringMeasures);
    
    // æ•™è‚²ãƒ»è¨“ç·´
    const trainingMeasures = this.implementTrainingMeasures(analysis);
    result.measures.push(...trainingMeasures);
    
    result.success = result.measures.every(measure => measure.implemented);
    
    return result;
  }
  
  private static implementTechnicalMeasures(analysis: RootCauseReport): PreventionMeasure[] {
    const measures: PreventionMeasure[] = [];
    
    // è‡ªå‹•ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã®å®Ÿè£…
    measures.push({
      type: 'technical',
      name: 'Automated Security Scanning',
      description: 'Implement automated vulnerability scanning in CI/CD pipeline',
      implemented: this.setupAutomatedScanning(),
      effectiveness: 'high',
      maintenance: 'low'
    });
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ã®å¼·åŒ–
    measures.push({
      type: 'technical',
      name: 'Enhanced Security Headers',
      description: 'Implement comprehensive security headers',
      implemented: this.enhanceSecurityHeaders(),
      effectiveness: 'medium',
      maintenance: 'low'
    });
    
    // å…¥åŠ›æ¤œè¨¼ã®å¼·åŒ–
    measures.push({
      type: 'technical',
      name: 'Enhanced Input Validation',
      description: 'Implement stricter input validation rules',
      implemented: this.enhanceInputValidation(),
      effectiveness: 'high',
      maintenance: 'medium'
    });
    
    return measures;
  }
  
  private static setupAutomatedScanning(): boolean {
    try {
      // GitHub Actions ã«ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã‚’è¿½åŠ 
      const scanningConfig = {
        name: 'Security Scan',
        on: ['push', 'pull_request'],
        jobs: {
          security: {
            'runs-on': 'ubuntu-latest',
            steps: [
              { uses: 'actions/checkout@v4' },
              { name: 'Run npm audit', run: 'npm audit --audit-level high' },
              { name: 'Run OWASP dependency check', run: 'npm run security:dependency-check' },
              { name: 'Run static analysis', run: 'npm run security:static-analysis' }
            ]
          }
        }
      };
      
      console.log('ğŸ“ Automated security scanning configured');
      return true;
    } catch (error) {
      console.error('Failed to setup automated scanning:', error);
      return false;
    }
  }
  
  private static implementProcessMeasures(analysis: RootCauseReport): PreventionMeasure[] {
    const measures: PreventionMeasure[] = [];
    
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚»ã‚¹
    measures.push({
      type: 'process',
      name: 'Mandatory Security Review',
      description: 'Require security review for all code changes',
      implemented: this.establishSecurityReview(),
      effectiveness: 'high',
      maintenance: 'medium'
    });
    
    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œè¨“ç·´
    measures.push({
      type: 'process',
      name: 'Incident Response Drills',
      description: 'Regular incident response training and drills',
      implemented: this.scheduleResponseDrills(),
      effectiveness: 'medium',
      maintenance: 'medium'
    });
    
    return measures;
  }
  
  private static establishSecurityReview(): boolean {
    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆã®ä½œæˆ
    const reviewChecklist = [
      'Input validation implemented',
      'Output encoding applied',
      'Authentication checks present',
      'Authorization properly implemented',
      'Sensitive data properly handled',
      'Error handling secure',
      'Logging appropriate',
      'Third-party dependencies reviewed'
    ];
    
    console.log('ğŸ“‹ Security review process established');
    console.log('Checklist items:', reviewChecklist);
    
    return true;
  }
}

interface PreventionResult {
  analysisId: string;
  implementationDate: number;
  measures: PreventionMeasure[];
  success: boolean;
}

interface PreventionMeasure {
  type: 'technical' | 'process' | 'monitoring' | 'training';
  name: string;
  description: string;
  implemented: boolean;
  effectiveness: 'low' | 'medium' | 'high';
  maintenance: 'low' | 'medium' | 'high';
}
```

## 7. å ±å‘Šãƒ»é€šçŸ¥

### 7.1 å†…éƒ¨å ±å‘Š

#### ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒ¬ãƒãƒ¼ãƒˆä½œæˆ
```typescript
// src/utils/incident-reporting.ts
export class IncidentReporting {
  // åŒ…æ‹¬çš„ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
  static generateIncidentReport(
    incident: IncidentReport,
    investigation: Investigation,
    analysis: RootCauseReport,
    recovery: RecoveryResult
  ): IncidentReportDocument {
    
    const report: IncidentReportDocument = {
      id: `INCIDENT-${Date.now()}`,
      incidentId: incident.id,
      createdAt: Date.now(),
      createdBy: 'incident_response_system',
      classification: this.classifyIncident(incident),
      executiveSummary: this.generateExecutiveSummary(incident, analysis),
      incidentDetails: this.compileIncidentDetails(incident, investigation),
      impactAssessment: this.assessImpact(incident, investigation),
      rootCauseAnalysis: analysis,
      responseActions: this.summarizeResponseActions(recovery),
      lessonsLearned: this.extractLessonsLearned(analysis),
      preventionMeasures: this.summarizePreventionMeasures(analysis),
      recommendations: this.consolidateRecommendations(analysis),
      timeline: this.createDetailedTimeline(incident, investigation, recovery),
      attachments: this.gatherAttachments(investigation)
    };
    
    return report;
  }
  
  private static generateExecutiveSummary(
    incident: IncidentReport,
    analysis: RootCauseReport
  ): string {
    const summary = `
## ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼

**ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆæ¦‚è¦**: ${incident.description}

**ç™ºç”Ÿæ—¥æ™‚**: ${new Date(incident.timestamp).toLocaleString('ja-JP')}

**é‡è¦åº¦**: ${incident.severity} - ${this.getSeverityDescription(incident.severity)}

**å½±éŸ¿ç¯„å›²**: ${incident.impactScope.join(', ')}

**æ ¹æœ¬åŸå› **: ${analysis.rootCauses.map(rc => rc.ultimateRootCause).join('; ')}

**å¯¾å¿œçŠ¶æ³**: å°ã˜è¾¼ã‚å®Œäº†ã€ã‚·ã‚¹ãƒ†ãƒ å¾©æ—§æ¸ˆã¿ã€å†ç™ºé˜²æ­¢ç­–å®Ÿè£…ä¸­

**å­¦ç¿’äº‹é …**: ${this.summarizeLessons(analysis)}

**ä»Šå¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**: ${analysis.recommendations.length}ä»¶ã®æ”¹å–„ææ¡ˆã‚’å®Ÿè£…äºˆå®š
    `.trim();
    
    return summary;
  }
  
  private static compileIncidentDetails(
    incident: IncidentReport,
    investigation: Investigation
  ): IncidentDetails {
    return {
      detectionMethod: this.identifyDetectionMethod(incident),
      attackVector: this.identifyAttackVector(investigation),
      affectedSystems: incident.systemsAffected,
      dataInvolved: incident.dataInvolved,
      userImpact: incident.userImpact,
      businessImpact: this.assessBusinessImpact(incident),
      technicalDetails: this.compileTechnicalDetails(investigation),
      forensicFindings: investigation.findings
    };
  }
  
  private static createDetailedTimeline(
    incident: IncidentReport,
    investigation: Investigation,
    recovery: RecoveryResult
  ): TimelineEntry[] {
    const timeline: TimelineEntry[] = [];
    
    // ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆç™ºç”Ÿ
    timeline.push({
      timestamp: incident.timestamp,
      phase: 'incident',
      event: 'Incident Occurred',
      description: incident.description,
      actor: 'unknown'
    });
    
    // æ¤œçŸ¥
    timeline.push({
      timestamp: incident.detectionTime || incident.timestamp,
      phase: 'detection',
      event: 'Incident Detected',
      description: 'Incident was detected and reported',
      actor: 'monitoring_system'
    });
    
    // èª¿æŸ»é–‹å§‹
    timeline.push({
      timestamp: investigation.startTime,
      phase: 'investigation',
      event: 'Investigation Started',
      description: 'Forensic investigation initiated',
      actor: 'incident_response_team'
    });
    
    // å¯¾å¿œã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    recovery.steps.forEach(step => {
      timeline.push({
        timestamp: step.startTime,
        phase: 'recovery',
        event: step.name,
        description: `Recovery step: ${step.name}`,
        actor: 'incident_response_team'
      });
    });
    
    return timeline.sort((a, b) => a.timestamp - b.timestamp);
  }
}

interface IncidentReportDocument {
  id: string;
  incidentId: string;
  createdAt: number;
  createdBy: string;
  classification: IncidentClassification;
  executiveSummary: string;
  incidentDetails: IncidentDetails;
  impactAssessment: ImpactAssessment;
  rootCauseAnalysis: RootCauseReport;
  responseActions: ResponseActionSummary;
  lessonsLearned: string[];
  preventionMeasures: PreventionMeasureSummary;
  recommendations: Recommendation[];
  timeline: TimelineEntry[];
  attachments: Attachment[];
}

interface IncidentClassification {
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  subcategory: string;
  confidentiality: 'public' | 'internal' | 'confidential' | 'restricted';
}

interface IncidentDetails {
  detectionMethod: string;
  attackVector: string;
  affectedSystems: string[];
  dataInvolved: boolean;
  userImpact: string;
  businessImpact: string;
  technicalDetails: any;
  forensicFindings: Finding[];
}

interface ImpactAssessment {
  confidentiality: 'none' | 'low' | 'medium' | 'high';
  integrity: 'none' | 'low' | 'medium' | 'high';
  availability: 'none' | 'low' | 'medium' | 'high';
  overallImpact: 'low' | 'medium' | 'high' | 'critical';
}

interface ResponseActionSummary {
  containmentActions: string[];
  eradicationActions: string[];
  recoveryActions: string[];
  totalResponseTime: number;
}

interface PreventionMeasureSummary {
  implemented: number;
  planned: number;
  categories: string[];
}

interface TimelineEntry {
  timestamp: number;
  phase: 'incident' | 'detection' | 'investigation' | 'containment' | 'recovery' | 'lessons';
  event: string;
  description: string;
  actor: string;
}

interface Attachment {
  name: string;
  type: string;
  description: string;
  hash: string;
}
```

## 8. ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

#### åˆæœŸå¯¾å¿œï¼ˆDetection & Analysisï¼‰
- [ ] ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆã®ç¢ºèªã¨åˆ†é¡
- [ ] é‡è¦åº¦ãƒ¬ãƒ™ãƒ«ã®åˆ¤å®š
- [ ] å¯¾å¿œãƒãƒ¼ãƒ ã®æ‹›é›†
- [ ] åˆæœŸå°ã˜è¾¼ã‚ã®å®Ÿæ–½
- [ ] è¨¼æ‹ ä¿å…¨ã®é–‹å§‹
- [ ] é–¢ä¿‚è€…ã¸ã®åˆæœŸå ±å‘Š

#### å°ã˜è¾¼ã‚ãƒ»æ ¹çµ¶ãƒ»å¾©æ—§ï¼ˆContainment, Eradication & Recoveryï¼‰
- [ ] è¢«å®³æ‹¡å¤§ã®é˜²æ­¢
- [ ] æ”»æ’ƒè€…ã®ã‚¢ã‚¯ã‚»ã‚¹é®æ–­
- [ ] è„†å¼±æ€§ã®ä¿®æ­£
- [ ] ã‚·ã‚¹ãƒ†ãƒ ã®å¾©æ—§
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ–ã®å®Ÿè£…
- [ ] æ©Ÿèƒ½ãƒ»æ€§èƒ½ã®æ¤œè¨¼

#### äº‹å¾Œæ´»å‹•ï¼ˆPost-Incident Activityï¼‰
- [ ] è©³ç´°ãªã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒ¬ãƒãƒ¼ãƒˆã®ä½œæˆ
- [ ] æ ¹æœ¬åŸå› åˆ†æã®å®Ÿæ–½
- [ ] å†ç™ºé˜²æ­¢ç­–ã®ç­–å®šãƒ»å®Ÿè£…
- [ ] å¯¾å¿œãƒ—ãƒ­ã‚»ã‚¹ã®æ”¹å–„
- [ ] é–¢ä¿‚è€…ã¸ã®æœ€çµ‚å ±å‘Š
- [ ] å­¦ç¿’äº‹é …ã®æ–‡æ›¸åŒ–ãƒ»å…±æœ‰

### ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¤å®šãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
- [ ] å€‹äººæƒ…å ±ãŒé–¢ä¸ã—ã¦ã„ã‚‹
- [ ] ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã«å½±éŸ¿ãŒã‚ã‚‹
- [ ] æ”»æ’ƒãŒç¶™ç¶šã—ã¦ã„ã‚‹
- [ ] ãƒ¡ãƒ‡ã‚£ã‚¢å ±é“ã®å¯èƒ½æ€§ãŒã‚ã‚‹
- [ ] æ³•çš„å¯¾å¿œãŒå¿…è¦ã§ã‚ã‚‹
- [ ] å¤–éƒ¨å°‚é–€å®¶ã®æ”¯æ´ãŒå¿…è¦ã§ã‚ã‚‹

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼](./SECURITY_POLICY.md)
- [ã‚³ãƒ³ãƒ—ãƒ©ã‚¤ã‚¢ãƒ³ã‚¹è¦ä»¶](./COMPLIANCE_REQUIREMENTS.md)
- [ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š](../operations/MONITORING_ALERTING.md)
- [ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ãƒªã‚«ãƒãƒªæ‰‹é †](../operations/BACKUP_RECOVERY.md)