/**
 * メモリ最適化システム
 * メモリリーク検出、ガベージコレクション最適化、メモリ使用量監視
 */

export interface MemoryConfig {
  /** GC強制実行の閾値（MB） */
  gcThreshold: number
  /** リーク検出の有効化 */
  enableLeakDetection: boolean
  /** 弱参照の使用 */
  useWeakReferences: boolean
  /** メモリ監視間隔（ミリ秒） */
  monitoringInterval: number
  /** 最大ヒープサイズ（MB） */
  maxHeapSize: number
  /** 警告メモリ使用率（%） */
  warningMemoryThreshold: number
}

/**
 * メモリ統計情報
 */
export interface MemoryStats {
  /** 使用中ヒープサイズ（MB） */
  usedHeapSize: number
  /** 総ヒープサイズ（MB） */
  totalHeapSize: number
  /** ヒープサイズ上限（MB） */
  heapSizeLimit: number
  /** 使用率（%） */
  usagePercentage: number
  /** GC実行回数 */
  gcCount: number
  /** 平均GC時間（ms） */
  averageGCTime: number
  /** リーク検出数 */
  detectedLeaks: number
  /** オブジェクト数 */
  objectCount: number
  /** DOM要素数 */
  domElementCount: number
}

/**
 * メモリリーク情報
 */
export interface MemoryLeak {
  /** リークID */
  id: string
  /** オブジェクト種別 */
  type: string
  /** リークサイズ（推定） */
  size: number
  /** 検出時刻 */
  detectedAt: number
  /** 参照チェーン */
  referenceChain: string[]
  /** 重要度 */
  severity: 'low' | 'medium' | 'high' | 'critical'
}

/**
 * メモリ最適化マネージャー
 */
export class MemoryOptimizer {\n  private config: MemoryConfig\n  private stats: MemoryStats\n  private monitoringTimer: NodeJS.Timeout | null = null\n  private gcTimer: NodeJS.Timeout | null = null\n  \n  // リーク検出\n  private leakDetector: MemoryLeakDetector\n  private detectedLeaks: Map<string, MemoryLeak> = new Map()\n  \n  // 弱参照管理\n  private weakRefRegistry: FinalizationRegistry<string>\n  private weakRefs: Map<string, WeakRef<any>> = new Map()\n  \n  // GC監視\n  private gcObserver: PerformanceObserver | null = null\n  private gcHistory: Array<{ time: number; duration: number }> = []\n  \n  // オブジェクト追跡\n  private objectTracker: ObjectTracker\n  private eventListenerTracker: EventListenerTracker\n  private timerTracker: TimerTracker\n  \n  constructor(config: Partial<MemoryConfig> = {}) {\n    this.config = {\n      gcThreshold: 150, // 150MB\n      enableLeakDetection: true,\n      useWeakReferences: true,\n      monitoringInterval: 5000, // 5秒\n      maxHeapSize: 512, // 512MB\n      warningMemoryThreshold: 80, // 80%\n      ...config\n    }\n    \n    this.initializeOptimizer()\n  }\n  \n  /**\n   * メモリ最適化システムの初期化\n   */\n  private initializeOptimizer(): void {\n    this.initializeStats()\n    this.setupLeakDetection()\n    this.setupWeakReferences()\n    this.setupGCMonitoring()\n    this.setupObjectTracking()\n    this.startMonitoring()\n  }\n  \n  /**\n   * 統計情報の初期化\n   */\n  private initializeStats(): void {\n    this.stats = {\n      usedHeapSize: 0,\n      totalHeapSize: 0,\n      heapSizeLimit: 0,\n      usagePercentage: 0,\n      gcCount: 0,\n      averageGCTime: 0,\n      detectedLeaks: 0,\n      objectCount: 0,\n      domElementCount: 0\n    }\n  }\n  \n  /**\n   * リーク検出システムのセットアップ\n   */\n  private setupLeakDetection(): void {\n    if (this.config.enableLeakDetection) {\n      this.leakDetector = new MemoryLeakDetector()\n    }\n  }\n  \n  /**\n   * 弱参照システムのセットアップ\n   */\n  private setupWeakReferences(): void {\n    if (this.config.useWeakReferences && typeof FinalizationRegistry !== 'undefined') {\n      this.weakRefRegistry = new FinalizationRegistry((id: string) => {\n        this.onObjectFinalized(id)\n      })\n    }\n  }\n  \n  /**\n   * GC監視のセットアップ\n   */\n  private setupGCMonitoring(): void {\n    if (typeof PerformanceObserver !== 'undefined') {\n      try {\n        this.gcObserver = new PerformanceObserver((list) => {\n          for (const entry of list.getEntries()) {\n            if (entry.entryType === 'measure' && entry.name.includes('gc')) {\n              this.onGCEvent(entry.duration)\n            }\n          }\n        })\n        \n        this.gcObserver.observe({ entryTypes: ['measure'] })\n      } catch (error) {\n        console.warn('GC監視の初期化に失敗:', error)\n      }\n    }\n  }\n  \n  /**\n   * オブジェクト追跡のセットアップ\n   */\n  private setupObjectTracking(): void {\n    this.objectTracker = new ObjectTracker()\n    this.eventListenerTracker = new EventListenerTracker()\n    this.timerTracker = new TimerTracker()\n  }\n  \n  /**\n   * 監視の開始\n   */\n  private startMonitoring(): void {\n    this.monitoringTimer = setInterval(() => {\n      this.updateMemoryStats()\n      this.checkMemoryThresholds()\n      this.detectMemoryLeaks()\n    }, this.config.monitoringInterval)\n  }\n  \n  /**\n   * メモリ統計の更新\n   */\n  private updateMemoryStats(): void {\n    if ((performance as any).memory) {\n      const memory = (performance as any).memory\n      this.stats.usedHeapSize = Math.round(memory.usedJSHeapSize / 1024 / 1024)\n      this.stats.totalHeapSize = Math.round(memory.totalJSHeapSize / 1024 / 1024)\n      this.stats.heapSizeLimit = Math.round(memory.jsHeapSizeLimit / 1024 / 1024)\n      this.stats.usagePercentage = (this.stats.usedHeapSize / this.stats.heapSizeLimit) * 100\n    }\n    \n    // DOM要素数の更新\n    this.stats.domElementCount = document.querySelectorAll('*').length\n    \n    // オブジェクト数の更新\n    this.stats.objectCount = this.objectTracker.getObjectCount()\n    \n    // リーク数の更新\n    this.stats.detectedLeaks = this.detectedLeaks.size\n  }\n  \n  /**\n   * メモリ閾値のチェック\n   */\n  private checkMemoryThresholds(): void {\n    // GC強制実行の閾値チェック\n    if (this.stats.usedHeapSize > this.config.gcThreshold) {\n      this.forceGarbageCollection()\n    }\n    \n    // 警告閾値チェック\n    if (this.stats.usagePercentage > this.config.warningMemoryThreshold) {\n      this.onMemoryWarning()\n    }\n    \n    // 限界閾値チェック\n    if (this.stats.usagePercentage > 95) {\n      this.onMemoryCritical()\n    }\n  }\n  \n  /**\n   * メモリリークの検出\n   */\n  private detectMemoryLeaks(): void {\n    if (!this.config.enableLeakDetection) return\n    \n    const newLeaks = this.leakDetector.detectLeaks()\n    \n    for (const leak of newLeaks) {\n      if (!this.detectedLeaks.has(leak.id)) {\n        this.detectedLeaks.set(leak.id, leak)\n        this.onLeakDetected(leak)\n      }\n    }\n  }\n  \n  /**\n   * 強制ガベージコレクション\n   */\n  private forceGarbageCollection(): void {\n    const startTime = performance.now()\n    \n    // 手動クリーンアップ\n    this.manualCleanup()\n    \n    // GCヒント（実際のGC実行は保証されない）\n    if ((window as any).gc) {\n      (window as any).gc()\n    }\n    \n    const duration = performance.now() - startTime\n    this.onGCEvent(duration)\n    \n    console.log(`強制GC実行 - 実行時間: ${duration.toFixed(2)}ms`)\n  }\n  \n  /**\n   * 手動クリーンアップ\n   */\n  private manualCleanup(): void {\n    // 期限切れの弱参照をクリア\n    this.cleanupWeakReferences()\n    \n    // イベントリスナーのクリーンアップ\n    this.eventListenerTracker.cleanup()\n    \n    // タイマーのクリーンアップ\n    this.timerTracker.cleanup()\n    \n    // オブジェクトトラッカーのクリーンアップ\n    this.objectTracker.cleanup()\n  }\n  \n  /**\n   * 弱参照のクリーンアップ\n   */\n  private cleanupWeakReferences(): void {\n    const keysToDelete: string[] = []\n    \n    for (const [key, weakRef] of this.weakRefs) {\n      if (weakRef.deref() === undefined) {\n        keysToDelete.push(key)\n      }\n    }\n    \n    keysToDelete.forEach(key => this.weakRefs.delete(key))\n  }\n  \n  /**\n   * オブジェクトの弱参照登録\n   */\n  registerWeakReference<T extends object>(id: string, obj: T): void {\n    if (this.config.useWeakReferences && this.weakRefRegistry) {\n      const weakRef = new WeakRef(obj)\n      this.weakRefs.set(id, weakRef)\n      this.weakRefRegistry.register(obj, id)\n    }\n  }\n  \n  /**\n   * 弱参照の取得\n   */\n  getWeakReference<T>(id: string): T | undefined {\n    const weakRef = this.weakRefs.get(id)\n    return weakRef ? weakRef.deref() as T : undefined\n  }\n  \n  /**\n   * オブジェクトファイナライズ時の処理\n   */\n  private onObjectFinalized(id: string): void {\n    this.weakRefs.delete(id)\n    console.log(`オブジェクト解放: ${id}`)\n  }\n  \n  /**\n   * GCイベント処理\n   */\n  private onGCEvent(duration: number): void {\n    this.stats.gcCount++\n    this.gcHistory.push({ time: Date.now(), duration })\n    \n    // 履歴のサイズ制限\n    if (this.gcHistory.length > 100) {\n      this.gcHistory.shift()\n    }\n    \n    // 平均GC時間の更新\n    const totalTime = this.gcHistory.reduce((sum, entry) => sum + entry.duration, 0)\n    this.stats.averageGCTime = totalTime / this.gcHistory.length\n  }\n  \n  /**\n   * メモリ警告処理\n   */\n  private onMemoryWarning(): void {\n    console.warn(`メモリ使用量警告: ${this.stats.usagePercentage.toFixed(1)}%`)\n    \n    // 自動クリーンアップの実行\n    this.manualCleanup()\n  }\n  \n  /**\n   * メモリ限界処理\n   */\n  private onMemoryCritical(): void {\n    console.error(`メモリ使用量限界: ${this.stats.usagePercentage.toFixed(1)}%`)\n    \n    // 緊急クリーンアップ\n    this.emergencyCleanup()\n  }\n  \n  /**\n   * リーク検出時の処理\n   */\n  private onLeakDetected(leak: MemoryLeak): void {\n    console.warn(`メモリリーク検出:`, leak)\n    \n    // 重要度に応じた処理\n    switch (leak.severity) {\n      case 'critical':\n        this.handleCriticalLeak(leak)\n        break\n      case 'high':\n        this.handleHighPriorityLeak(leak)\n        break\n      default:\n        this.handleStandardLeak(leak)\n    }\n  }\n  \n  /**\n   * 緊急クリーンアップ\n   */\n  private emergencyCleanup(): void {\n    // より積極的なクリーンアップ\n    this.manualCleanup()\n    \n    // キャッシュの全クリア\n    this.clearAllCaches()\n    \n    // 強制GC\n    this.forceGarbageCollection()\n  }\n  \n  /**\n   * 全キャッシュのクリア\n   */\n  private clearAllCaches(): void {\n    // ブラウザキャッシュのクリア\n    if ('caches' in window) {\n      caches.keys().then(names => {\n        names.forEach(name => caches.delete(name))\n      })\n    }\n    \n    // セッションストレージのクリア\n    try {\n      sessionStorage.clear()\n    } catch (e) {\n      console.warn('セッションストレージのクリアに失敗:', e)\n    }\n  }\n  \n  /**\n   * クリティカルリークの処理\n   */\n  private handleCriticalLeak(leak: MemoryLeak): void {\n    console.error('クリティカルメモリリーク:', leak)\n    // 必要に応じてアプリケーションの再起動を促す\n  }\n  \n  /**\n   * 高優先度リークの処理\n   */\n  private handleHighPriorityLeak(leak: MemoryLeak): void {\n    console.warn('高優先度メモリリーク:', leak)\n    // 積極的なクリーンアップを実行\n    this.emergencyCleanup()\n  }\n  \n  /**\n   * 標準リークの処理\n   */\n  private handleStandardLeak(leak: MemoryLeak): void {\n    console.log('メモリリーク:', leak)\n    // 標準的なクリーンアップを実行\n    this.manualCleanup()\n  }\n  \n  /**\n   * メモリ使用量の取得\n   */\n  getMemoryUsage(): MemoryStats {\n    this.updateMemoryStats()\n    return { ...this.stats }\n  }\n  \n  /**\n   * リーク情報の取得\n   */\n  getDetectedLeaks(): MemoryLeak[] {\n    return Array.from(this.detectedLeaks.values())\n  }\n  \n  /**\n   * 詳細統計の取得\n   */\n  getDetailedStats(): {\n    memory: MemoryStats\n    leaks: MemoryLeak[]\n    gc: {\n      history: Array<{ time: number; duration: number }>\n      frequency: number\n      efficiency: number\n    }\n    tracking: {\n      objects: number\n      eventListeners: number\n      timers: number\n      weakReferences: number\n    }\n  } {\n    const now = Date.now()\n    const recentGCs = this.gcHistory.filter(entry => now - entry.time < 60000) // 1分以内\n    const gcFrequency = recentGCs.length / 60 // per minute\n    \n    return {\n      memory: this.getMemoryUsage(),\n      leaks: this.getDetectedLeaks(),\n      gc: {\n        history: [...this.gcHistory],\n        frequency: gcFrequency,\n        efficiency: this.calculateGCEfficiency()\n      },\n      tracking: {\n        objects: this.objectTracker.getObjectCount(),\n        eventListeners: this.eventListenerTracker.getListenerCount(),\n        timers: this.timerTracker.getTimerCount(),\n        weakReferences: this.weakRefs.size\n      }\n    }\n  }\n  \n  /**\n   * GC効率の計算\n   */\n  private calculateGCEfficiency(): number {\n    if (this.gcHistory.length < 2) return 1\n    \n    // GC前後のメモリ使用量変化を基に効率を計算\n    // 簡易実装\n    const avgDuration = this.stats.averageGCTime\n    const targetDuration = 10 // 10ms目標\n    \n    return Math.max(0, Math.min(1, targetDuration / avgDuration))\n  }\n  \n  /**\n   * 最適化推奨事項の生成\n   */\n  getOptimizationRecommendations(): string[] {\n    const recommendations: string[] = []\n    const stats = this.getDetailedStats()\n    \n    if (stats.memory.usagePercentage > 80) {\n      recommendations.push('メモリ使用量が高いです - 不要なオブジェクトの解放を検討してください')\n    }\n    \n    if (stats.leaks.length > 0) {\n      recommendations.push(`${stats.leaks.length}個のメモリリークが検出されました - 修正が必要です`)\n    }\n    \n    if (stats.gc.frequency > 5) {\n      recommendations.push('GC実行頻度が高いです - オブジェクト作成の最適化を検討してください')\n    }\n    \n    if (stats.gc.efficiency < 0.5) {\n      recommendations.push('GC効率が低いです - 大きなオブジェクトの分割を検討してください')\n    }\n    \n    if (stats.tracking.eventListeners > 100) {\n      recommendations.push('イベントリスナーが多すぎます - 不要なリスナーの削除を検討してください')\n    }\n    \n    if (stats.tracking.timers > 20) {\n      recommendations.push('アクティブなタイマーが多すぎます - 不要なタイマーの削除を検討してください')\n    }\n    \n    if (recommendations.length === 0) {\n      recommendations.push('メモリ使用状況は良好です')\n    }\n    \n    return recommendations\n  }\n  \n  /**\n   * 設定の更新\n   */\n  updateConfig(newConfig: Partial<MemoryConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // 監視間隔の変更\n    if (newConfig.monitoringInterval && this.monitoringTimer) {\n      clearInterval(this.monitoringTimer)\n      this.startMonitoring()\n    }\n  }\n  \n  /**\n   * システムの停止\n   */\n  stop(): void {\n    if (this.monitoringTimer) {\n      clearInterval(this.monitoringTimer)\n      this.monitoringTimer = null\n    }\n    \n    if (this.gcTimer) {\n      clearInterval(this.gcTimer)\n      this.gcTimer = null\n    }\n    \n    if (this.gcObserver) {\n      this.gcObserver.disconnect()\n      this.gcObserver = null\n    }\n  }\n  \n  /**\n   * リソースのクリーンアップ\n   */\n  cleanup(): void {\n    this.stop()\n    \n    this.detectedLeaks.clear()\n    this.weakRefs.clear()\n    this.gcHistory.length = 0\n    \n    this.objectTracker.cleanup()\n    this.eventListenerTracker.cleanup()\n    this.timerTracker.cleanup()\n  }\n}\n\n/**\n * メモリリーク検出器\n */\nclass MemoryLeakDetector {\n  private snapshots: Map<string, any> = new Map()\n  private objectCounts: Map<string, number> = new Map()\n  private threshold: number = 10 // 同じ種類のオブジェクトが10個以上増加したらリークと判定\n  \n  /**\n   * メモリリークの検出\n   */\n  detectLeaks(): MemoryLeak[] {\n    const leaks: MemoryLeak[] = []\n    const currentCounts = this.getCurrentObjectCounts()\n    \n    for (const [type, currentCount] of currentCounts) {\n      const previousCount = this.objectCounts.get(type) || 0\n      const increase = currentCount - previousCount\n      \n      if (increase > this.threshold) {\n        leaks.push({\n          id: `leak_${type}_${Date.now()}`,\n          type,\n          size: increase * this.estimateObjectSize(type),\n          detectedAt: Date.now(),\n          referenceChain: this.analyzeReferenceChain(type),\n          severity: this.determineSeverity(increase, type)\n        })\n      }\n    }\n    \n    this.objectCounts = currentCounts\n    return leaks\n  }\n  \n  /**\n   * 現在のオブジェクト数を取得\n   */\n  private getCurrentObjectCounts(): Map<string, number> {\n    const counts = new Map<string, number>()\n    \n    // DOM要素のカウント\n    const elements = document.querySelectorAll('*')\n    elements.forEach(element => {\n      const tagName = element.tagName.toLowerCase()\n      counts.set(`dom_${tagName}`, (counts.get(`dom_${tagName}`) || 0) + 1)\n    })\n    \n    // イベントリスナーのカウント（推定）\n    const eventTargets = document.querySelectorAll('[onclick], [onload], [onchange]')\n    counts.set('event_listeners', eventTargets.length)\n    \n    return counts\n  }\n  \n  /**\n   * オブジェクトサイズの推定\n   */\n  private estimateObjectSize(type: string): number {\n    // 簡易的なサイズ推定\n    const sizeMap: Record<string, number> = {\n      'dom_div': 200,\n      'dom_span': 100,\n      'dom_img': 500,\n      'event_listeners': 50,\n      'timer': 100\n    }\n    \n    return sizeMap[type] || 100\n  }\n  \n  /**\n   * 参照チェーンの分析\n   */\n  private analyzeReferenceChain(type: string): string[] {\n    // 簡易的な参照チェーン分析\n    return [`window`, `document`, type]\n  }\n  \n  /**\n   * リークの重要度判定\n   */\n  private determineSeverity(increase: number, type: string): MemoryLeak['severity'] {\n    if (increase > 100) return 'critical'\n    if (increase > 50) return 'high'\n    if (increase > 20) return 'medium'\n    return 'low'\n  }\n}\n\n/**\n * オブジェクト追跡器\n */\nclass ObjectTracker {\n  private trackedObjects: Map<string, any> = new Map()\n  private objectCount: number = 0\n  \n  /**\n   * オブジェクトの追跡開始\n   */\n  track(id: string, obj: any): void {\n    this.trackedObjects.set(id, obj)\n    this.objectCount++\n  }\n  \n  /**\n   * オブジェクトの追跡停止\n   */\n  untrack(id: string): void {\n    if (this.trackedObjects.delete(id)) {\n      this.objectCount--\n    }\n  }\n  \n  /**\n   * オブジェクト数の取得\n   */\n  getObjectCount(): number {\n    return this.objectCount\n  }\n  \n  /**\n   * クリーンアップ\n   */\n  cleanup(): void {\n    this.trackedObjects.clear()\n    this.objectCount = 0\n  }\n}\n\n/**\n * イベントリスナー追跡器\n */\nclass EventListenerTracker {\n  private listeners: Map<string, { element: Element; type: string; listener: EventListener }> = new Map()\n  \n  /**\n   * イベントリスナーの追跡開始\n   */\n  track(id: string, element: Element, type: string, listener: EventListener): void {\n    this.listeners.set(id, { element, type, listener })\n  }\n  \n  /**\n   * イベントリスナーの追跡停止\n   */\n  untrack(id: string): void {\n    this.listeners.delete(id)\n  }\n  \n  /**\n   * リスナー数の取得\n   */\n  getListenerCount(): number {\n    return this.listeners.size\n  }\n  \n  /**\n   * クリーンアップ\n   */\n  cleanup(): void {\n    // 未削除のリスナーを削除\n    for (const [id, { element, type, listener }] of this.listeners) {\n      try {\n        element.removeEventListener(type, listener)\n      } catch (error) {\n        console.warn(`イベントリスナーの削除に失敗: ${id}`, error)\n      }\n    }\n    \n    this.listeners.clear()\n  }\n}\n\n/**\n * タイマー追跡器\n */\nclass TimerTracker {\n  private timers: Map<string, { id: number; type: 'timeout' | 'interval' }> = new Map()\n  \n  /**\n   * タイマーの追跡開始\n   */\n  track(id: string, timerId: number, type: 'timeout' | 'interval'): void {\n    this.timers.set(id, { id: timerId, type })\n  }\n  \n  /**\n   * タイマーの追跡停止\n   */\n  untrack(id: string): void {\n    this.timers.delete(id)\n  }\n  \n  /**\n   * タイマー数の取得\n   */\n  getTimerCount(): number {\n    return this.timers.size\n  }\n  \n  /**\n   * クリーンアップ\n   */\n  cleanup(): void {\n    // 未削除のタイマーを削除\n    for (const [id, { id: timerId, type }] of this.timers) {\n      try {\n        if (type === 'timeout') {\n          clearTimeout(timerId)\n        } else {\n          clearInterval(timerId)\n        }\n      } catch (error) {\n        console.warn(`タイマーの削除に失敗: ${id}`, error)\n      }\n    }\n    \n    this.timers.clear()\n  }\n}\n\n/**\n * メモリプロファイラー\n */\nexport class MemoryProfiler {\n  private snapshots: Array<{ timestamp: number; memory: MemoryStats }> = []\n  private isRecording: boolean = false\n  \n  /**\n   * プロファイリング開始\n   */\n  startProfiling(): void {\n    if (this.isRecording) return\n    \n    this.isRecording = true\n    this.snapshots = []\n    \n    const recordSnapshot = () => {\n      if (!this.isRecording) return\n      \n      const memoryStats = this.getCurrentMemoryStats()\n      this.snapshots.push({\n        timestamp: Date.now(),\n        memory: memoryStats\n      })\n      \n      setTimeout(recordSnapshot, 100) // 100ms間隔\n    }\n    \n    recordSnapshot()\n  }\n  \n  /**\n   * プロファイリング停止\n   */\n  stopProfiling(): Array<{ timestamp: number; memory: MemoryStats }> {\n    this.isRecording = false\n    return [...this.snapshots]\n  }\n  \n  /**\n   * 現在のメモリ統計取得\n   */\n  private getCurrentMemoryStats(): MemoryStats {\n    const memory = (performance as any).memory\n    \n    return {\n      usedHeapSize: memory ? Math.round(memory.usedJSHeapSize / 1024 / 1024) : 0,\n      totalHeapSize: memory ? Math.round(memory.totalJSHeapSize / 1024 / 1024) : 0,\n      heapSizeLimit: memory ? Math.round(memory.jsHeapSizeLimit / 1024 / 1024) : 0,\n      usagePercentage: memory ? (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100 : 0,\n      gcCount: 0,\n      averageGCTime: 0,\n      detectedLeaks: 0,\n      objectCount: document.querySelectorAll('*').length,\n      domElementCount: document.querySelectorAll('*').length\n    }\n  }\n  \n  /**\n   * プロファイリング結果の分析\n   */\n  analyzeProfile(): {\n    memoryGrowth: number\n    peakUsage: number\n    averageUsage: number\n    stabilityScore: number\n    recommendations: string[]\n  } {\n    if (this.snapshots.length < 2) {\n      return {\n        memoryGrowth: 0,\n        peakUsage: 0,\n        averageUsage: 0,\n        stabilityScore: 1,\n        recommendations: ['プロファイリングデータが不足しています']\n      }\n    }\n    \n    const firstSnapshot = this.snapshots[0]\n    const lastSnapshot = this.snapshots[this.snapshots.length - 1]\n    \n    const memoryGrowth = lastSnapshot.memory.usedHeapSize - firstSnapshot.memory.usedHeapSize\n    const peakUsage = Math.max(...this.snapshots.map(s => s.memory.usedHeapSize))\n    const averageUsage = this.snapshots.reduce((sum, s) => sum + s.memory.usedHeapSize, 0) / this.snapshots.length\n    \n    // 安定性スコアの計算\n    const variance = this.snapshots.reduce((sum, s) => sum + Math.pow(s.memory.usedHeapSize - averageUsage, 2), 0) / this.snapshots.length\n    const standardDeviation = Math.sqrt(variance)\n    const stabilityScore = Math.max(0, 1 - (standardDeviation / averageUsage))\n    \n    const recommendations: string[] = []\n    \n    if (memoryGrowth > 50) {\n      recommendations.push('大幅なメモリ増加が検出されました - メモリリークの可能性があります')\n    }\n    \n    if (stabilityScore < 0.7) {\n      recommendations.push('メモリ使用量が不安定です - ガベージコレクションの最適化を検討してください')\n    }\n    \n    if (peakUsage > 300) {\n      recommendations.push('ピークメモリ使用量が高いです - メモリ使用量の削減を検討してください')\n    }\n    \n    return {\n      memoryGrowth,\n      peakUsage,\n      averageUsage,\n      stabilityScore,\n      recommendations\n    }\n  }\n}