import type { Game } from '@/domain/entities/Game'
import type { Card } from '@/domain/entities/Card'
import type { GameStage } from '@/domain/types/card.types'
import type { PlayerStats, ChallengeResult } from '@/domain/types/game.types'
import { GameStateManager, type EnhancedPlayerStats, type Achievement } from '../state/GameStateManager'

/**
 * プレイヤーの行動データ
 */
export interface PlayerAction {
  id: string
  timestamp: Date
  type: 'card_selection' | 'challenge_attempt' | 'insurance_purchase' | 'stage_progression' | 'game_complete'
  gameStage: GameStage
  turn: number
  vitality: number
  data: Record<string, any>
}

/**
 * 戦略パターン分析結果
 */
export interface StrategyPattern {
  name: string
  description: string
  frequency: number
  successRate: number
  averageVitality: number
  stages: GameStage[]
}

/**
 * プレイ効率の指標
 */
export interface EfficiencyMetrics {
  decisionSpeed: number // 平均決定時間（秒）
  optimalPlayRate: number // 最適プレイ率（%）
  resourceEfficiency: number // リソース効率性
  adaptabilityScore: number // 適応性スコア
}

/**
 * 学習進度の追跡
 */
export interface LearningProgress {
  masteredConcepts: string[]
  strugglingAreas: string[]
  improvementRate: number
  skillLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert'
  nextMilestone: string
}

/**
 * ゲーム分析エンジン
 * プレイヤーの行動を詳細に分析し、統計とインサイトを提供
 */
export class GameAnalytics {
  private stateManager: GameStateManager
  private actionHistory: PlayerAction[] = []
  private sessionStartTime: Date = new Date()
  private currentSessionActions: PlayerAction[] = []
  
  constructor() {\n    this.stateManager = GameStateManager.getInstance()\n  }\n  \n  /**\n   * プレイヤーのアクションを記録\n   */\n  recordAction(action: Omit<PlayerAction, 'id' | 'timestamp'>): void {\n    const fullAction: PlayerAction = {\n      id: this.generateActionId(),\n      timestamp: new Date(),\n      ...action\n    }\n    \n    this.actionHistory.push(fullAction)\n    this.currentSessionActions.push(fullAction)\n    \n    // アクション履歴が多すぎる場合は古いものを削除\n    if (this.actionHistory.length > 10000) {\n      this.actionHistory = this.actionHistory.slice(-5000)\n    }\n    \n    // リアルタイム分析を実行\n    this.analyzeRecentActions()\n  }\n  \n  /**\n   * カード選択を分析\n   */\n  analyzeCardSelection(selectedCards: Card[], availableCards: Card[], game: Game): void {\n    this.recordAction({\n      type: 'card_selection',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        selectedCardIds: selectedCards.map(c => c.id),\n        selectedPower: selectedCards.reduce((sum, c) => sum + c.power, 0),\n        availableCardIds: availableCards.map(c => c.id),\n        maxPossiblePower: availableCards.reduce((sum, c) => sum + c.power, 0),\n        selectionTime: this.calculateSelectionTime(),\n        insuranceCount: game.insuranceCards.length\n      }\n    })\n  }\n  \n  /**\n   * チャレンジ結果を分析\n   */\n  analyzeChallengeResult(result: ChallengeResult, game: Game): void {\n    this.recordAction({\n      type: 'challenge_attempt',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        success: result.success,\n        playerPower: result.playerPower,\n        challengePower: result.challengePower,\n        vitalityChange: result.vitalityChange,\n        powerBreakdown: result.powerBreakdown,\n        difficulty: this.calculateChallengeDifficulty(result)\n      }\n    })\n    \n    // チャレンジ成功率の更新\n    this.updateChallengeSuccessRates(game.stage, result.success)\n  }\n  \n  /**\n   * 保険購入を分析\n   */\n  analyzeInsurancePurchase(insuranceCard: Card, game: Game): void {\n    this.recordAction({\n      type: 'insurance_purchase',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        insuranceType: insuranceCard.insuranceType,\n        cost: insuranceCard.cost,\n        power: insuranceCard.power,\n        durationType: insuranceCard.durationType,\n        totalInsuranceCount: game.insuranceCards.length + 1,\n        vitalityRatio: game.vitality / game.maxVitality\n      }\n    })\n    \n    // 保険使用パターンの更新\n    this.updateInsuranceUsagePattern(insuranceCard)\n  }\n  \n  /**\n   * ゲーム完了を分析\n   */\n  analyzeGameCompletion(game: Game): void {\n    const sessionDuration = Date.now() - this.sessionStartTime.getTime()\n    \n    this.recordAction({\n      type: 'game_complete',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        finalStats: game.stats,\n        sessionDuration,\n        totalActions: this.currentSessionActions.length,\n        efficiency: this.calculateSessionEfficiency(),\n        outcome: game.status\n      }\n    })\n    \n    // セッション統計を更新\n    this.updateSessionStatistics(game, sessionDuration)\n    \n    // 学習進度を更新\n    this.updateLearningProgress(game)\n    \n    // セッションをリセット\n    this.resetSession()\n  }\n  \n  /**\n   * 戦略パターンを分析\n   */\n  getStrategyPatterns(): StrategyPattern[] {\n    const patterns: StrategyPattern[] = []\n    \n    // 保険重視戦略\n    const insuranceActions = this.actionHistory.filter(a => a.type === 'insurance_purchase')\n    if (insuranceActions.length > 0) {\n      patterns.push({\n        name: '保険重視戦略',\n        description: '早期から積極的に保険を購入する戦略',\n        frequency: insuranceActions.length / this.actionHistory.length,\n        successRate: this.calculateInsuranceStrategySuccessRate(),\n        averageVitality: this.calculateAverageVitalityForStrategy('insurance_heavy'),\n        stages: ['youth', 'middle', 'fulfillment']\n      })\n    }\n    \n    // 攻撃的戦略\n    const aggressiveActions = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && \n      a.data.playerPower > a.data.challengePower * 1.5\n    )\n    if (aggressiveActions.length > 0) {\n      patterns.push({\n        name: '攻撃的戦略',\n        description: '高いパワーでチャレンジに挑む戦略',\n        frequency: aggressiveActions.length / this.actionHistory.length,\n        successRate: aggressiveActions.filter(a => a.data.success).length / aggressiveActions.length,\n        averageVitality: aggressiveActions.reduce((sum, a) => sum + a.vitality, 0) / aggressiveActions.length,\n        stages: ['youth', 'middle']\n      })\n    }\n    \n    // 保守的戦略\n    const conservativeActions = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && \n      a.data.playerPower < a.data.challengePower * 1.2\n    )\n    if (conservativeActions.length > 0) {\n      patterns.push({\n        name: '保守的戦略',\n        description: 'リスクを避けて慎重にプレイする戦略',\n        frequency: conservativeActions.length / this.actionHistory.length,\n        successRate: conservativeActions.filter(a => a.data.success).length / conservativeActions.length,\n        averageVitality: conservativeActions.reduce((sum, a) => sum + a.vitality, 0) / conservativeActions.length,\n        stages: ['middle', 'fulfillment']\n      })\n    }\n    \n    return patterns.sort((a, b) => b.frequency - a.frequency).slice(0, 5)\n  }\n  \n  /**\n   * プレイ効率を計算\n   */\n  getEfficiencyMetrics(): EfficiencyMetrics {\n    const challengeActions = this.actionHistory.filter(a => a.type === 'challenge_attempt')\n    const cardSelectionActions = this.actionHistory.filter(a => a.type === 'card_selection')\n    \n    // 決定速度の計算\n    const averageDecisionTime = cardSelectionActions.reduce(\n      (sum, action) => sum + (action.data.selectionTime || 5), 0\n    ) / Math.max(cardSelectionActions.length, 1)\n    \n    // 最適プレイ率の計算\n    const optimalPlays = challengeActions.filter(a => \n      a.data.success && a.data.playerPower >= a.data.challengePower * 1.1\n    ).length\n    const optimalPlayRate = (optimalPlays / Math.max(challengeActions.length, 1)) * 100\n    \n    // リソース効率性の計算\n    const resourceEfficiency = this.calculateResourceEfficiency()\n    \n    // 適応性スコアの計算\n    const adaptabilityScore = this.calculateAdaptabilityScore()\n    \n    return {\n      decisionSpeed: averageDecisionTime,\n      optimalPlayRate,\n      resourceEfficiency,\n      adaptabilityScore\n    }\n  }\n  \n  /**\n   * 学習進度を取得\n   */\n  getLearningProgress(): LearningProgress {\n    const stats = this.stateManager.getEnhancedStats()\n    \n    // 習得した概念の判定\n    const masteredConcepts: string[] = []\n    if (stats.successfulChallenges > 10) masteredConcepts.push('基本的なチャレンジ')\n    if (stats.insuranceUsagePatterns.length > 3) masteredConcepts.push('保険活用')\n    if (stats.gamesCompleted > 5) masteredConcepts.push('ゲーム進行')\n    \n    // 苦手分野の特定\n    const strugglingAreas: string[] = []\n    const challengeSuccessRate = stats.successfulChallenges / Math.max(stats.totalChallenges, 1)\n    if (challengeSuccessRate < 0.6) strugglingAreas.push('チャレンジ成功率')\n    if (stats.averageTurnsPerGame > 20) strugglingAreas.push('効率的なプレイ')\n    \n    // 改善率の計算\n    const improvementRate = this.calculateImprovementRate()\n    \n    // スキルレベルの判定\n    let skillLevel: LearningProgress['skillLevel'] = 'beginner'\n    if (stats.gamesCompleted > 10 && challengeSuccessRate > 0.7) skillLevel = 'intermediate'\n    if (stats.gamesCompleted > 25 && challengeSuccessRate > 0.8) skillLevel = 'advanced'\n    if (stats.gamesCompleted > 50 && challengeSuccessRate > 0.9) skillLevel = 'expert'\n    \n    // 次のマイルストーン\n    let nextMilestone = '初回ゲームクリア'\n    if (stats.gamesCompleted >= 1) nextMilestone = '10回クリア達成'\n    if (stats.gamesCompleted >= 10) nextMilestone = '成功率80%達成'\n    if (challengeSuccessRate >= 0.8) nextMilestone = 'エキスパートレベル到達'\n    \n    return {\n      masteredConcepts,\n      strugglingAreas,\n      improvementRate,\n      skillLevel,\n      nextMilestone\n    }\n  }\n  \n  /**\n   * 実績の進行状況をチェック\n   */\n  checkAchievementProgress(): { unlocked: Achievement[]; progress: Record<string, number> } {\n    const unlocked: Achievement[] = []\n    const progress: Record<string, number> = {}\n    \n    const stats = this.stateManager.getEnhancedStats()\n    \n    // チャレンジ系実績\n    progress['challenge_master'] = Math.min(stats.successfulChallenges / 100, 1) * 100\n    if (stats.successfulChallenges >= 100 && !stats.achievements.some(a => a.id === 'challenge_master')) {\n      unlocked.push({\n        id: 'challenge_master',\n        name: 'チャレンジマスター',\n        description: '100回のチャレンジに成功しました',\n        unlockedAt: new Date(),\n        category: 'gameplay'\n      })\n    }\n    \n    // 保険系実績\n    const insuranceTypes = new Set(stats.insuranceUsagePatterns.map(p => p.insuranceType))\n    progress['insurance_expert'] = Math.min(insuranceTypes.size / 5, 1) * 100\n    if (insuranceTypes.size >= 5 && !stats.achievements.some(a => a.id === 'insurance_expert')) {\n      unlocked.push({\n        id: 'insurance_expert',\n        name: '保険エキスパート',\n        description: '5種類以上の保険を活用しました',\n        unlockedAt: new Date(),\n        category: 'strategy'\n      })\n    }\n    \n    // 効率系実績\n    const efficiency = this.getEfficiencyMetrics()\n    progress['speed_runner'] = Math.min(efficiency.decisionSpeed <= 3 ? 1 : 0, 1) * 100\n    if (efficiency.decisionSpeed <= 3 && !stats.achievements.some(a => a.id === 'speed_runner')) {\n      unlocked.push({\n        id: 'speed_runner',\n        name: 'スピードランナー',\n        description: '平均決定時間3秒以下を達成しました',\n        unlockedAt: new Date(),\n        category: 'gameplay'\n      })\n    }\n    \n    return { unlocked, progress }\n  }\n  \n  /**\n   * 個人化されたアドバイスを生成\n   */\n  generatePersonalizedAdvice(): string[] {\n    const advice: string[] = []\n    const stats = this.stateManager.getEnhancedStats()\n    const efficiency = this.getEfficiencyMetrics()\n    const patterns = this.getStrategyPatterns()\n    \n    // 成功率が低い場合\n    const successRate = stats.successfulChallenges / Math.max(stats.totalChallenges, 1)\n    if (successRate < 0.6) {\n      advice.push('💡 チャレンジの成功率を上げるため、より強力なカードの組み合わせを試してみましょう')\n    }\n    \n    // 保険の活用度が低い場合\n    if (stats.insuranceUsagePatterns.length < 3) {\n      advice.push('🛡️ 保険カードを積極的に活用することで、より安定したプレイが可能になります')\n    }\n    \n    // 決定が遅い場合\n    if (efficiency.decisionSpeed > 10) {\n      advice.push('⚡ 決定時間を短縮することで、より集中してプレイできるようになります')\n    }\n    \n    // 戦略パターンに基づくアドバイス\n    const dominantPattern = patterns[0]\n    if (dominantPattern) {\n      if (dominantPattern.successRate < 0.7) {\n        advice.push(`📊 ${dominantPattern.name}の成功率が低めです。他の戦略も試してみてください`)\n      }\n    }\n    \n    // プレイ回数に応じたアドバイス\n    if (stats.gamesCompleted < 5) {\n      advice.push('🌟 まずは様々な戦略を試して、自分に合ったプレイスタイルを見つけましょう')\n    } else if (stats.gamesCompleted > 20) {\n      advice.push('🏆 経験豊富なプレイヤーですね！より高難度のチャレンジに挑戦してみてください')\n    }\n    \n    return advice.slice(0, 3) // 最大3つのアドバイス\n  }\n  \n  /**\n   * 統計データをリセット\n   */\n  resetAnalytics(): void {\n    this.actionHistory = []\n    this.resetSession()\n  }\n  \n  // === プライベートメソッド ===\n  \n  private generateActionId(): string {\n    return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n  \n  private resetSession(): void {\n    this.sessionStartTime = new Date()\n    this.currentSessionActions = []\n  }\n  \n  private calculateSelectionTime(): number {\n    // 実際の実装では、カード選択開始から決定までの時間を測定\n    // ここでは仮の値を返す\n    return Math.random() * 10 + 2\n  }\n  \n  private calculateChallengeDifficulty(result: ChallengeResult): number {\n    // 難易度 = チャレンジパワー / プレイヤーパワー\n    return result.challengePower / Math.max(result.playerPower, 1)\n  }\n  \n  private analyzeRecentActions(): void {\n    // 最近のアクションを分析してリアルタイムフィードバックを生成\n    const recentActions = this.actionHistory.slice(-10)\n    \n    // 連続失敗の検出\n    const recentChallenges = recentActions.filter(a => a.type === 'challenge_attempt')\n    const recentFailures = recentChallenges.filter(a => !a.data.success)\n    \n    if (recentFailures.length >= 3) {\n      // 失敗が連続している場合の分析とアドバイス\n      console.log('連続失敗を検出。戦略の見直しを提案')\n    }\n  }\n  \n  private updateChallengeSuccessRates(stage: GameStage, success: boolean): void {\n    const stats = this.stateManager.getEnhancedStats()\n    const current = stats.challengeSuccessRates[stage] || 0\n    const total = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && a.gameStage === stage\n    ).length\n    \n    // 成功率を更新\n    const successCount = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && a.gameStage === stage && a.data.success\n    ).length\n    \n    stats.challengeSuccessRates[stage] = successCount / total\n    this.stateManager.updateStatistics({ challengeSuccessRates: stats.challengeSuccessRates })\n  }\n  \n  private updateInsuranceUsagePattern(insuranceCard: Card): void {\n    const stats = this.stateManager.getEnhancedStats()\n    const insuranceType = insuranceCard.insuranceType || 'unknown'\n    \n    let pattern = stats.insuranceUsagePatterns.find(p => p.insuranceType === insuranceType)\n    if (!pattern) {\n      pattern = {\n        insuranceType,\n        usageCount: 0,\n        successRate: 0,\n        averageBenefit: 0\n      }\n      stats.insuranceUsagePatterns.push(pattern)\n    }\n    \n    pattern.usageCount++\n    // 成功率と平均利益は後続のチャレンジ結果で更新\n    \n    this.stateManager.updateStatistics({ insuranceUsagePatterns: stats.insuranceUsagePatterns })\n  }\n  \n  private calculateSessionEfficiency(): number {\n    const sessionActions = this.currentSessionActions\n    const challengeActions = sessionActions.filter(a => a.type === 'challenge_attempt')\n    \n    if (challengeActions.length === 0) return 0\n    \n    const successfulActions = challengeActions.filter(a => a.data.success)\n    return successfulActions.length / challengeActions.length\n  }\n  \n  private updateSessionStatistics(game: Game, sessionDuration: number): void {\n    const stats = this.stateManager.getEnhancedStats()\n    \n    // セッション統計を更新\n    stats.sessionsPlayed++\n    stats.totalPlaytime += sessionDuration\n    \n    // ベストスコアを更新\n    const currentScore = game.stats.score || 0\n    if (currentScore > stats.bestScore) {\n      stats.bestScore = currentScore\n    }\n    \n    this.stateManager.updateStatistics(stats)\n  }\n  \n  private updateLearningProgress(game: Game): void {\n    // 学習進度の更新ロジック\n    // 実装は今後拡張予定\n  }\n  \n  private calculateInsuranceStrategySuccessRate(): number {\n    const insuranceGames = this.actionHistory.filter(a => \n      a.type === 'game_complete' && \n      this.actionHistory.some(ia => \n        ia.type === 'insurance_purchase' && \n        ia.timestamp < a.timestamp\n      )\n    )\n    \n    const successfulInsuranceGames = insuranceGames.filter(a => \n      a.data.outcome === 'victory' || a.data.finalStats.successfulChallenges > 0\n    )\n    \n    return successfulInsuranceGames.length / Math.max(insuranceGames.length, 1)\n  }\n  \n  private calculateAverageVitalityForStrategy(strategy: string): number {\n    // 戦略別の平均活力計算\n    // 実装は戦略によって異なる\n    return 0\n  }\n  \n  private calculateResourceEfficiency(): number {\n    const cardSelections = this.actionHistory.filter(a => a.type === 'card_selection')\n    if (cardSelections.length === 0) return 0\n    \n    const totalEfficiency = cardSelections.reduce((sum, action) => {\n      const selectedPower = action.data.selectedPower || 0\n      const maxPossiblePower = action.data.maxPossiblePower || 1\n      return sum + (selectedPower / maxPossiblePower)\n    }, 0)\n    \n    return (totalEfficiency / cardSelections.length) * 100\n  }\n  \n  private calculateAdaptabilityScore(): number {\n    // 異なるステージでの戦略変更を測定\n    const stageTransitions = this.actionHistory.filter(a => a.type === 'stage_progression')\n    \n    // 簡易的な適応性スコア\n    return Math.min(stageTransitions.length * 25, 100)\n  }\n  \n  private calculateImprovementRate(): number {\n    const completedGames = this.actionHistory.filter(a => a.type === 'game_complete')\n    if (completedGames.length < 2) return 0\n    \n    // 最初の5ゲームと最新の5ゲームを比較\n    const earlyGames = completedGames.slice(0, 5)\n    const recentGames = completedGames.slice(-5)\n    \n    const earlyAvgScore = earlyGames.reduce((sum, g) => sum + (g.data.finalStats.score || 0), 0) / earlyGames.length\n    const recentAvgScore = recentGames.reduce((sum, g) => sum + (g.data.finalStats.score || 0), 0) / recentGames.length\n    \n    return ((recentAvgScore - earlyAvgScore) / Math.max(earlyAvgScore, 1)) * 100\n  }\n}