import type { Game } from '@/domain/entities/Game'
import type { Card } from '@/domain/entities/Card'
import type { GameStage } from '@/domain/types/card.types'
import type { PlayerStats, ChallengeResult } from '@/domain/types/game.types'
import { GameStateManager, type EnhancedPlayerStats, type Achievement } from '../state/GameStateManager'

/**
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ãƒ‡ãƒ¼ã‚¿
 */
export interface PlayerAction {
  id: string
  timestamp: Date
  type: 'card_selection' | 'challenge_attempt' | 'insurance_purchase' | 'stage_progression' | 'game_complete'
  gameStage: GameStage
  turn: number
  vitality: number
  data: Record<string, any>
}

/**
 * æˆ¦ç•¥ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æçµæœ
 */
export interface StrategyPattern {
  name: string
  description: string
  frequency: number
  successRate: number
  averageVitality: number
  stages: GameStage[]
}

/**
 * ãƒ—ãƒ¬ã‚¤åŠ¹ç‡ã®æŒ‡æ¨™
 */
export interface EfficiencyMetrics {
  decisionSpeed: number // å¹³å‡æ±ºå®šæ™‚é–“ï¼ˆç§’ï¼‰
  optimalPlayRate: number // æœ€é©ãƒ—ãƒ¬ã‚¤ç‡ï¼ˆ%ï¼‰
  resourceEfficiency: number // ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡æ€§
  adaptabilityScore: number // é©å¿œæ€§ã‚¹ã‚³ã‚¢
}

/**
 * å­¦ç¿’é€²åº¦ã®è¿½è·¡
 */
export interface LearningProgress {
  masteredConcepts: string[]
  strugglingAreas: string[]
  improvementRate: number
  skillLevel: 'beginner' | 'intermediate' | 'advanced' | 'expert'
  nextMilestone: string
}

/**
 * ã‚²ãƒ¼ãƒ åˆ†æã‚¨ãƒ³ã‚¸ãƒ³
 * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ã‚’è©³ç´°ã«åˆ†æã—ã€çµ±è¨ˆã¨ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’æä¾›
 */
export class GameAnalytics {
  private stateManager: GameStateManager
  private actionHistory: PlayerAction[] = []
  private sessionStartTime: Date = new Date()
  private currentSessionActions: PlayerAction[] = []
  
  constructor() {\n    this.stateManager = GameStateManager.getInstance()\n  }\n  \n  /**\n   * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¨˜éŒ²\n   */\n  recordAction(action: Omit<PlayerAction, 'id' | 'timestamp'>): void {\n    const fullAction: PlayerAction = {\n      id: this.generateActionId(),\n      timestamp: new Date(),\n      ...action\n    }\n    \n    this.actionHistory.push(fullAction)\n    this.currentSessionActions.push(fullAction)\n    \n    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±¥æ­´ãŒå¤šã™ãã‚‹å ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤\n    if (this.actionHistory.length > 10000) {\n      this.actionHistory = this.actionHistory.slice(-5000)\n    }\n    \n    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æã‚’å®Ÿè¡Œ\n    this.analyzeRecentActions()\n  }\n  \n  /**\n   * ã‚«ãƒ¼ãƒ‰é¸æŠã‚’åˆ†æ\n   */\n  analyzeCardSelection(selectedCards: Card[], availableCards: Card[], game: Game): void {\n    this.recordAction({\n      type: 'card_selection',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        selectedCardIds: selectedCards.map(c => c.id),\n        selectedPower: selectedCards.reduce((sum, c) => sum + c.power, 0),\n        availableCardIds: availableCards.map(c => c.id),\n        maxPossiblePower: availableCards.reduce((sum, c) => sum + c.power, 0),\n        selectionTime: this.calculateSelectionTime(),\n        insuranceCount: game.insuranceCards.length\n      }\n    })\n  }\n  \n  /**\n   * ãƒãƒ£ãƒ¬ãƒ³ã‚¸çµæœã‚’åˆ†æ\n   */\n  analyzeChallengeResult(result: ChallengeResult, game: Game): void {\n    this.recordAction({\n      type: 'challenge_attempt',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        success: result.success,\n        playerPower: result.playerPower,\n        challengePower: result.challengePower,\n        vitalityChange: result.vitalityChange,\n        powerBreakdown: result.powerBreakdown,\n        difficulty: this.calculateChallengeDifficulty(result)\n      }\n    })\n    \n    // ãƒãƒ£ãƒ¬ãƒ³ã‚¸æˆåŠŸç‡ã®æ›´æ–°\n    this.updateChallengeSuccessRates(game.stage, result.success)\n  }\n  \n  /**\n   * ä¿é™ºè³¼å…¥ã‚’åˆ†æ\n   */\n  analyzeInsurancePurchase(insuranceCard: Card, game: Game): void {\n    this.recordAction({\n      type: 'insurance_purchase',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        insuranceType: insuranceCard.insuranceType,\n        cost: insuranceCard.cost,\n        power: insuranceCard.power,\n        durationType: insuranceCard.durationType,\n        totalInsuranceCount: game.insuranceCards.length + 1,\n        vitalityRatio: game.vitality / game.maxVitality\n      }\n    })\n    \n    // ä¿é™ºä½¿ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æ›´æ–°\n    this.updateInsuranceUsagePattern(insuranceCard)\n  }\n  \n  /**\n   * ã‚²ãƒ¼ãƒ å®Œäº†ã‚’åˆ†æ\n   */\n  analyzeGameCompletion(game: Game): void {\n    const sessionDuration = Date.now() - this.sessionStartTime.getTime()\n    \n    this.recordAction({\n      type: 'game_complete',\n      gameStage: game.stage,\n      turn: game.turn,\n      vitality: game.vitality,\n      data: {\n        finalStats: game.stats,\n        sessionDuration,\n        totalActions: this.currentSessionActions.length,\n        efficiency: this.calculateSessionEfficiency(),\n        outcome: game.status\n      }\n    })\n    \n    // ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆã‚’æ›´æ–°\n    this.updateSessionStatistics(game, sessionDuration)\n    \n    // å­¦ç¿’é€²åº¦ã‚’æ›´æ–°\n    this.updateLearningProgress(game)\n    \n    // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ\n    this.resetSession()\n  }\n  \n  /**\n   * æˆ¦ç•¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ\n   */\n  getStrategyPatterns(): StrategyPattern[] {\n    const patterns: StrategyPattern[] = []\n    \n    // ä¿é™ºé‡è¦–æˆ¦ç•¥\n    const insuranceActions = this.actionHistory.filter(a => a.type === 'insurance_purchase')\n    if (insuranceActions.length > 0) {\n      patterns.push({\n        name: 'ä¿é™ºé‡è¦–æˆ¦ç•¥',\n        description: 'æ—©æœŸã‹ã‚‰ç©æ¥µçš„ã«ä¿é™ºã‚’è³¼å…¥ã™ã‚‹æˆ¦ç•¥',\n        frequency: insuranceActions.length / this.actionHistory.length,\n        successRate: this.calculateInsuranceStrategySuccessRate(),\n        averageVitality: this.calculateAverageVitalityForStrategy('insurance_heavy'),\n        stages: ['youth', 'middle', 'fulfillment']\n      })\n    }\n    \n    // æ”»æ’ƒçš„æˆ¦ç•¥\n    const aggressiveActions = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && \n      a.data.playerPower > a.data.challengePower * 1.5\n    )\n    if (aggressiveActions.length > 0) {\n      patterns.push({\n        name: 'æ”»æ’ƒçš„æˆ¦ç•¥',\n        description: 'é«˜ã„ãƒ‘ãƒ¯ãƒ¼ã§ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã«æŒ‘ã‚€æˆ¦ç•¥',\n        frequency: aggressiveActions.length / this.actionHistory.length,\n        successRate: aggressiveActions.filter(a => a.data.success).length / aggressiveActions.length,\n        averageVitality: aggressiveActions.reduce((sum, a) => sum + a.vitality, 0) / aggressiveActions.length,\n        stages: ['youth', 'middle']\n      })\n    }\n    \n    // ä¿å®ˆçš„æˆ¦ç•¥\n    const conservativeActions = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && \n      a.data.playerPower < a.data.challengePower * 1.2\n    )\n    if (conservativeActions.length > 0) {\n      patterns.push({\n        name: 'ä¿å®ˆçš„æˆ¦ç•¥',\n        description: 'ãƒªã‚¹ã‚¯ã‚’é¿ã‘ã¦æ…é‡ã«ãƒ—ãƒ¬ã‚¤ã™ã‚‹æˆ¦ç•¥',\n        frequency: conservativeActions.length / this.actionHistory.length,\n        successRate: conservativeActions.filter(a => a.data.success).length / conservativeActions.length,\n        averageVitality: conservativeActions.reduce((sum, a) => sum + a.vitality, 0) / conservativeActions.length,\n        stages: ['middle', 'fulfillment']\n      })\n    }\n    \n    return patterns.sort((a, b) => b.frequency - a.frequency).slice(0, 5)\n  }\n  \n  /**\n   * ãƒ—ãƒ¬ã‚¤åŠ¹ç‡ã‚’è¨ˆç®—\n   */\n  getEfficiencyMetrics(): EfficiencyMetrics {\n    const challengeActions = this.actionHistory.filter(a => a.type === 'challenge_attempt')\n    const cardSelectionActions = this.actionHistory.filter(a => a.type === 'card_selection')\n    \n    // æ±ºå®šé€Ÿåº¦ã®è¨ˆç®—\n    const averageDecisionTime = cardSelectionActions.reduce(\n      (sum, action) => sum + (action.data.selectionTime || 5), 0\n    ) / Math.max(cardSelectionActions.length, 1)\n    \n    // æœ€é©ãƒ—ãƒ¬ã‚¤ç‡ã®è¨ˆç®—\n    const optimalPlays = challengeActions.filter(a => \n      a.data.success && a.data.playerPower >= a.data.challengePower * 1.1\n    ).length\n    const optimalPlayRate = (optimalPlays / Math.max(challengeActions.length, 1)) * 100\n    \n    // ãƒªã‚½ãƒ¼ã‚¹åŠ¹ç‡æ€§ã®è¨ˆç®—\n    const resourceEfficiency = this.calculateResourceEfficiency()\n    \n    // é©å¿œæ€§ã‚¹ã‚³ã‚¢ã®è¨ˆç®—\n    const adaptabilityScore = this.calculateAdaptabilityScore()\n    \n    return {\n      decisionSpeed: averageDecisionTime,\n      optimalPlayRate,\n      resourceEfficiency,\n      adaptabilityScore\n    }\n  }\n  \n  /**\n   * å­¦ç¿’é€²åº¦ã‚’å–å¾—\n   */\n  getLearningProgress(): LearningProgress {\n    const stats = this.stateManager.getEnhancedStats()\n    \n    // ç¿’å¾—ã—ãŸæ¦‚å¿µã®åˆ¤å®š\n    const masteredConcepts: string[] = []\n    if (stats.successfulChallenges > 10) masteredConcepts.push('åŸºæœ¬çš„ãªãƒãƒ£ãƒ¬ãƒ³ã‚¸')\n    if (stats.insuranceUsagePatterns.length > 3) masteredConcepts.push('ä¿é™ºæ´»ç”¨')\n    if (stats.gamesCompleted > 5) masteredConcepts.push('ã‚²ãƒ¼ãƒ é€²è¡Œ')\n    \n    // è‹¦æ‰‹åˆ†é‡ã®ç‰¹å®š\n    const strugglingAreas: string[] = []\n    const challengeSuccessRate = stats.successfulChallenges / Math.max(stats.totalChallenges, 1)\n    if (challengeSuccessRate < 0.6) strugglingAreas.push('ãƒãƒ£ãƒ¬ãƒ³ã‚¸æˆåŠŸç‡')\n    if (stats.averageTurnsPerGame > 20) strugglingAreas.push('åŠ¹ç‡çš„ãªãƒ—ãƒ¬ã‚¤')\n    \n    // æ”¹å–„ç‡ã®è¨ˆç®—\n    const improvementRate = this.calculateImprovementRate()\n    \n    // ã‚¹ã‚­ãƒ«ãƒ¬ãƒ™ãƒ«ã®åˆ¤å®š\n    let skillLevel: LearningProgress['skillLevel'] = 'beginner'\n    if (stats.gamesCompleted > 10 && challengeSuccessRate > 0.7) skillLevel = 'intermediate'\n    if (stats.gamesCompleted > 25 && challengeSuccessRate > 0.8) skillLevel = 'advanced'\n    if (stats.gamesCompleted > 50 && challengeSuccessRate > 0.9) skillLevel = 'expert'\n    \n    // æ¬¡ã®ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³\n    let nextMilestone = 'åˆå›ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢'\n    if (stats.gamesCompleted >= 1) nextMilestone = '10å›ã‚¯ãƒªã‚¢é”æˆ'\n    if (stats.gamesCompleted >= 10) nextMilestone = 'æˆåŠŸç‡80%é”æˆ'\n    if (challengeSuccessRate >= 0.8) nextMilestone = 'ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆãƒ¬ãƒ™ãƒ«åˆ°é”'\n    \n    return {\n      masteredConcepts,\n      strugglingAreas,\n      improvementRate,\n      skillLevel,\n      nextMilestone\n    }\n  }\n  \n  /**\n   * å®Ÿç¸¾ã®é€²è¡ŒçŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯\n   */\n  checkAchievementProgress(): { unlocked: Achievement[]; progress: Record<string, number> } {\n    const unlocked: Achievement[] = []\n    const progress: Record<string, number> = {}\n    \n    const stats = this.stateManager.getEnhancedStats()\n    \n    // ãƒãƒ£ãƒ¬ãƒ³ã‚¸ç³»å®Ÿç¸¾\n    progress['challenge_master'] = Math.min(stats.successfulChallenges / 100, 1) * 100\n    if (stats.successfulChallenges >= 100 && !stats.achievements.some(a => a.id === 'challenge_master')) {\n      unlocked.push({\n        id: 'challenge_master',\n        name: 'ãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒã‚¹ã‚¿ãƒ¼',\n        description: '100å›ã®ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã«æˆåŠŸã—ã¾ã—ãŸ',\n        unlockedAt: new Date(),\n        category: 'gameplay'\n      })\n    }\n    \n    // ä¿é™ºç³»å®Ÿç¸¾\n    const insuranceTypes = new Set(stats.insuranceUsagePatterns.map(p => p.insuranceType))\n    progress['insurance_expert'] = Math.min(insuranceTypes.size / 5, 1) * 100\n    if (insuranceTypes.size >= 5 && !stats.achievements.some(a => a.id === 'insurance_expert')) {\n      unlocked.push({\n        id: 'insurance_expert',\n        name: 'ä¿é™ºã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ',\n        description: '5ç¨®é¡ä»¥ä¸Šã®ä¿é™ºã‚’æ´»ç”¨ã—ã¾ã—ãŸ',\n        unlockedAt: new Date(),\n        category: 'strategy'\n      })\n    }\n    \n    // åŠ¹ç‡ç³»å®Ÿç¸¾\n    const efficiency = this.getEfficiencyMetrics()\n    progress['speed_runner'] = Math.min(efficiency.decisionSpeed <= 3 ? 1 : 0, 1) * 100\n    if (efficiency.decisionSpeed <= 3 && !stats.achievements.some(a => a.id === 'speed_runner')) {\n      unlocked.push({\n        id: 'speed_runner',\n        name: 'ã‚¹ãƒ”ãƒ¼ãƒ‰ãƒ©ãƒ³ãƒŠãƒ¼',\n        description: 'å¹³å‡æ±ºå®šæ™‚é–“3ç§’ä»¥ä¸‹ã‚’é”æˆã—ã¾ã—ãŸ',\n        unlockedAt: new Date(),\n        category: 'gameplay'\n      })\n    }\n    \n    return { unlocked, progress }\n  }\n  \n  /**\n   * å€‹äººåŒ–ã•ã‚ŒãŸã‚¢ãƒ‰ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ\n   */\n  generatePersonalizedAdvice(): string[] {\n    const advice: string[] = []\n    const stats = this.stateManager.getEnhancedStats()\n    const efficiency = this.getEfficiencyMetrics()\n    const patterns = this.getStrategyPatterns()\n    \n    // æˆåŠŸç‡ãŒä½ã„å ´åˆ\n    const successRate = stats.successfulChallenges / Math.max(stats.totalChallenges, 1)\n    if (successRate < 0.6) {\n      advice.push('ğŸ’¡ ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã®æˆåŠŸç‡ã‚’ä¸Šã’ã‚‹ãŸã‚ã€ã‚ˆã‚Šå¼·åŠ›ãªã‚«ãƒ¼ãƒ‰ã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã—ã¦ã¿ã¾ã—ã‚‡ã†')\n    }\n    \n    // ä¿é™ºã®æ´»ç”¨åº¦ãŒä½ã„å ´åˆ\n    if (stats.insuranceUsagePatterns.length < 3) {\n      advice.push('ğŸ›¡ï¸ ä¿é™ºã‚«ãƒ¼ãƒ‰ã‚’ç©æ¥µçš„ã«æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šå®‰å®šã—ãŸãƒ—ãƒ¬ã‚¤ãŒå¯èƒ½ã«ãªã‚Šã¾ã™')\n    }\n    \n    // æ±ºå®šãŒé…ã„å ´åˆ\n    if (efficiency.decisionSpeed > 10) {\n      advice.push('âš¡ æ±ºå®šæ™‚é–“ã‚’çŸ­ç¸®ã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šé›†ä¸­ã—ã¦ãƒ—ãƒ¬ã‚¤ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™')\n    }\n    \n    // æˆ¦ç•¥ãƒ‘ã‚¿ãƒ¼ãƒ³ã«åŸºã¥ãã‚¢ãƒ‰ãƒã‚¤ã‚¹\n    const dominantPattern = patterns[0]\n    if (dominantPattern) {\n      if (dominantPattern.successRate < 0.7) {\n        advice.push(`ğŸ“Š ${dominantPattern.name}ã®æˆåŠŸç‡ãŒä½ã‚ã§ã™ã€‚ä»–ã®æˆ¦ç•¥ã‚‚è©¦ã—ã¦ã¿ã¦ãã ã•ã„`)\n      }\n    }\n    \n    // ãƒ—ãƒ¬ã‚¤å›æ•°ã«å¿œã˜ãŸã‚¢ãƒ‰ãƒã‚¤ã‚¹\n    if (stats.gamesCompleted < 5) {\n      advice.push('ğŸŒŸ ã¾ãšã¯æ§˜ã€…ãªæˆ¦ç•¥ã‚’è©¦ã—ã¦ã€è‡ªåˆ†ã«åˆã£ãŸãƒ—ãƒ¬ã‚¤ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¦‹ã¤ã‘ã¾ã—ã‚‡ã†')\n    } else if (stats.gamesCompleted > 20) {\n      advice.push('ğŸ† çµŒé¨“è±Šå¯Œãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã™ã­ï¼ã‚ˆã‚Šé«˜é›£åº¦ã®ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã«æŒ‘æˆ¦ã—ã¦ã¿ã¦ãã ã•ã„')\n    }\n    \n    return advice.slice(0, 3) // æœ€å¤§3ã¤ã®ã‚¢ãƒ‰ãƒã‚¤ã‚¹\n  }\n  \n  /**\n   * çµ±è¨ˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ\n   */\n  resetAnalytics(): void {\n    this.actionHistory = []\n    this.resetSession()\n  }\n  \n  // === ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ ===\n  \n  private generateActionId(): string {\n    return `action_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n  \n  private resetSession(): void {\n    this.sessionStartTime = new Date()\n    this.currentSessionActions = []\n  }\n  \n  private calculateSelectionTime(): number {\n    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚«ãƒ¼ãƒ‰é¸æŠé–‹å§‹ã‹ã‚‰æ±ºå®šã¾ã§ã®æ™‚é–“ã‚’æ¸¬å®š\n    // ã“ã“ã§ã¯ä»®ã®å€¤ã‚’è¿”ã™\n    return Math.random() * 10 + 2\n  }\n  \n  private calculateChallengeDifficulty(result: ChallengeResult): number {\n    // é›£æ˜“åº¦ = ãƒãƒ£ãƒ¬ãƒ³ã‚¸ãƒ‘ãƒ¯ãƒ¼ / ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‘ãƒ¯ãƒ¼\n    return result.challengePower / Math.max(result.playerPower, 1)\n  }\n  \n  private analyzeRecentActions(): void {\n    // æœ€è¿‘ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆ†æã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’ç”Ÿæˆ\n    const recentActions = this.actionHistory.slice(-10)\n    \n    // é€£ç¶šå¤±æ•—ã®æ¤œå‡º\n    const recentChallenges = recentActions.filter(a => a.type === 'challenge_attempt')\n    const recentFailures = recentChallenges.filter(a => !a.data.success)\n    \n    if (recentFailures.length >= 3) {\n      // å¤±æ•—ãŒé€£ç¶šã—ã¦ã„ã‚‹å ´åˆã®åˆ†æã¨ã‚¢ãƒ‰ãƒã‚¤ã‚¹\n      console.log('é€£ç¶šå¤±æ•—ã‚’æ¤œå‡ºã€‚æˆ¦ç•¥ã®è¦‹ç›´ã—ã‚’ææ¡ˆ')\n    }\n  }\n  \n  private updateChallengeSuccessRates(stage: GameStage, success: boolean): void {\n    const stats = this.stateManager.getEnhancedStats()\n    const current = stats.challengeSuccessRates[stage] || 0\n    const total = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && a.gameStage === stage\n    ).length\n    \n    // æˆåŠŸç‡ã‚’æ›´æ–°\n    const successCount = this.actionHistory.filter(a => \n      a.type === 'challenge_attempt' && a.gameStage === stage && a.data.success\n    ).length\n    \n    stats.challengeSuccessRates[stage] = successCount / total\n    this.stateManager.updateStatistics({ challengeSuccessRates: stats.challengeSuccessRates })\n  }\n  \n  private updateInsuranceUsagePattern(insuranceCard: Card): void {\n    const stats = this.stateManager.getEnhancedStats()\n    const insuranceType = insuranceCard.insuranceType || 'unknown'\n    \n    let pattern = stats.insuranceUsagePatterns.find(p => p.insuranceType === insuranceType)\n    if (!pattern) {\n      pattern = {\n        insuranceType,\n        usageCount: 0,\n        successRate: 0,\n        averageBenefit: 0\n      }\n      stats.insuranceUsagePatterns.push(pattern)\n    }\n    \n    pattern.usageCount++\n    // æˆåŠŸç‡ã¨å¹³å‡åˆ©ç›Šã¯å¾Œç¶šã®ãƒãƒ£ãƒ¬ãƒ³ã‚¸çµæœã§æ›´æ–°\n    \n    this.stateManager.updateStatistics({ insuranceUsagePatterns: stats.insuranceUsagePatterns })\n  }\n  \n  private calculateSessionEfficiency(): number {\n    const sessionActions = this.currentSessionActions\n    const challengeActions = sessionActions.filter(a => a.type === 'challenge_attempt')\n    \n    if (challengeActions.length === 0) return 0\n    \n    const successfulActions = challengeActions.filter(a => a.data.success)\n    return successfulActions.length / challengeActions.length\n  }\n  \n  private updateSessionStatistics(game: Game, sessionDuration: number): void {\n    const stats = this.stateManager.getEnhancedStats()\n    \n    // ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ±è¨ˆã‚’æ›´æ–°\n    stats.sessionsPlayed++\n    stats.totalPlaytime += sessionDuration\n    \n    // ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’æ›´æ–°\n    const currentScore = game.stats.score || 0\n    if (currentScore > stats.bestScore) {\n      stats.bestScore = currentScore\n    }\n    \n    this.stateManager.updateStatistics(stats)\n  }\n  \n  private updateLearningProgress(game: Game): void {\n    // å­¦ç¿’é€²åº¦ã®æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯\n    // å®Ÿè£…ã¯ä»Šå¾Œæ‹¡å¼µäºˆå®š\n  }\n  \n  private calculateInsuranceStrategySuccessRate(): number {\n    const insuranceGames = this.actionHistory.filter(a => \n      a.type === 'game_complete' && \n      this.actionHistory.some(ia => \n        ia.type === 'insurance_purchase' && \n        ia.timestamp < a.timestamp\n      )\n    )\n    \n    const successfulInsuranceGames = insuranceGames.filter(a => \n      a.data.outcome === 'victory' || a.data.finalStats.successfulChallenges > 0\n    )\n    \n    return successfulInsuranceGames.length / Math.max(insuranceGames.length, 1)\n  }\n  \n  private calculateAverageVitalityForStrategy(strategy: string): number {\n    // æˆ¦ç•¥åˆ¥ã®å¹³å‡æ´»åŠ›è¨ˆç®—\n    // å®Ÿè£…ã¯æˆ¦ç•¥ã«ã‚ˆã£ã¦ç•°ãªã‚‹\n    return 0\n  }\n  \n  private calculateResourceEfficiency(): number {\n    const cardSelections = this.actionHistory.filter(a => a.type === 'card_selection')\n    if (cardSelections.length === 0) return 0\n    \n    const totalEfficiency = cardSelections.reduce((sum, action) => {\n      const selectedPower = action.data.selectedPower || 0\n      const maxPossiblePower = action.data.maxPossiblePower || 1\n      return sum + (selectedPower / maxPossiblePower)\n    }, 0)\n    \n    return (totalEfficiency / cardSelections.length) * 100\n  }\n  \n  private calculateAdaptabilityScore(): number {\n    // ç•°ãªã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã®æˆ¦ç•¥å¤‰æ›´ã‚’æ¸¬å®š\n    const stageTransitions = this.actionHistory.filter(a => a.type === 'stage_progression')\n    \n    // ç°¡æ˜“çš„ãªé©å¿œæ€§ã‚¹ã‚³ã‚¢\n    return Math.min(stageTransitions.length * 25, 100)\n  }\n  \n  private calculateImprovementRate(): number {\n    const completedGames = this.actionHistory.filter(a => a.type === 'game_complete')\n    if (completedGames.length < 2) return 0\n    \n    // æœ€åˆã®5ã‚²ãƒ¼ãƒ ã¨æœ€æ–°ã®5ã‚²ãƒ¼ãƒ ã‚’æ¯”è¼ƒ\n    const earlyGames = completedGames.slice(0, 5)\n    const recentGames = completedGames.slice(-5)\n    \n    const earlyAvgScore = earlyGames.reduce((sum, g) => sum + (g.data.finalStats.score || 0), 0) / earlyGames.length\n    const recentAvgScore = recentGames.reduce((sum, g) => sum + (g.data.finalStats.score || 0), 0) / recentGames.length\n    \n    return ((recentAvgScore - earlyAvgScore) / Math.max(earlyAvgScore, 1)) * 100\n  }\n}