import { secureLocalStorage } from '@/utils/security'\n\n/**\n * ãƒ‡ãƒ¼ã‚¿åœ§ç¸®ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n */\nexport interface CompressionOptions {\n  enabled: boolean\n  level: 'fast' | 'balanced' | 'maximum'\n  threshold: number // åœ§ç¸®ã‚’é–‹å§‹ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆï¼‰\n}\n\n/**\n * ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n */\nexport interface CacheOptions {\n  enabled: boolean\n  maxSize: number // MB\n  ttl: number // Time To Liveï¼ˆç§’ï¼‰\n  strategy: 'lru' | 'lfu' | 'fifo'\n}\n\n/**\n * ãƒãƒƒãƒå‡¦ç†ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n */\nexport interface BatchOptions {\n  enabled: boolean\n  batchSize: number\n  flushInterval: number // ãƒŸãƒªç§’\n  maxPendingOperations: number\n}\n\n/**\n * ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æœ€é©åŒ–ã®è¨­å®š\n */\nexport interface StorageOptimizerConfig {\n  compression: CompressionOptions\n  cache: CacheOptions\n  batch: BatchOptions\n  enablePerformanceMonitoring: boolean\n  enableCleanup: boolean\n  cleanupInterval: number // ãƒŸãƒªç§’\n}\n\n/**\n * ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æ“ä½œã®çµ±è¨ˆ\n */\nexport interface StorageStats {\n  totalOperations: number\n  readOperations: number\n  writeOperations: number\n  deleteOperations: number\n  cacheHits: number\n  cacheMisses: number\n  compressionSaved: number // ãƒã‚¤ãƒˆ\n  averageOperationTime: number // ãƒŸãƒªç§’\n  errorCount: number\n}\n\n/**\n * ãƒãƒƒãƒæ“ä½œ\n */\ninterface BatchOperation {\n  id: string\n  type: 'set' | 'get' | 'remove'\n  key: string\n  value?: any\n  timestamp: number\n  resolve: (result: any) => void\n  reject: (error: Error) => void\n}\n\n/**\n * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒª\n */\ninterface CacheEntry {\n  data: any\n  timestamp: number\n  accessCount: number\n  lastAccess: number\n  size: number\n}\n\n/**\n * LocalStorageæ´»ç”¨æœ€é©åŒ–ã‚·ã‚¹ãƒ†ãƒ \n * ãƒ‡ãƒ¼ã‚¿åœ§ç¸®ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€ãƒãƒƒãƒå‡¦ç†ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚’æä¾›\n */\nexport class StorageOptimizer {\n  private static instance: StorageOptimizer | null = null\n  private config: StorageOptimizerConfig\n  private storage = secureLocalStorage()\n  private cache = new Map<string, CacheEntry>()\n  private pendingOperations: BatchOperation[] = []\n  private stats: StorageStats\n  private batchTimer: number | null = null\n  private cleanupTimer: number | null = null\n  \n  private constructor(config?: Partial<StorageOptimizerConfig>) {\n    this.config = {\n      compression: {\n        enabled: true,\n        level: 'balanced',\n        threshold: 1024 // 1KB\n      },\n      cache: {\n        enabled: true,\n        maxSize: 10, // MB\n        ttl: 3600, // 1æ™‚é–“\n        strategy: 'lru'\n      },\n      batch: {\n        enabled: true,\n        batchSize: 10,\n        flushInterval: 100, // 100ms\n        maxPendingOperations: 100\n      },\n      enablePerformanceMonitoring: true,\n      enableCleanup: true,\n      cleanupInterval: 300000, // 5åˆ†\n      ...config\n    }\n    \n    this.stats = this.initializeStats()\n    this.setupTimers()\n  }\n  \n  /**\n   * ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—\n   */\n  static getInstance(config?: Partial<StorageOptimizerConfig>): StorageOptimizer {\n    if (!StorageOptimizer.instance) {\n      StorageOptimizer.instance = new StorageOptimizer(config)\n    }\n    return StorageOptimizer.instance\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆæœ€é©åŒ–ä»˜ãï¼‰\n   */\n  async setItem(key: string, value: any): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      if (this.config.batch.enabled) {\n        return await this.addToBatch('set', key, value)\n      } else {\n        return await this.performSet(key, value)\n      }\n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    } finally {\n      this.updateOperationStats('write', Date.now() - startTime)\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ãï¼‰\n   */\n  async getItem<T>(key: string): Promise<T | null> {\n    const startTime = Date.now()\n    \n    try {\n      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ç¢ºèª\n      if (this.config.cache.enabled) {\n        const cached = this.getFromCache(key)\n        if (cached !== null) {\n          this.stats.cacheHits++\n          this.updateOperationStats('read', Date.now() - startTime)\n          return cached\n        }\n        this.stats.cacheMisses++\n      }\n      \n      // ãƒãƒƒãƒå‡¦ç†ãŒæœ‰åŠ¹ãªå ´åˆ\n      if (this.config.batch.enabled) {\n        const result = await this.addToBatch<T>('get', key)\n        this.updateOperationStats('read', Date.now() - startTime)\n        return result\n      }\n      \n      // ç›´æ¥èª­ã¿è¾¼ã¿\n      const result = await this.performGet<T>(key)\n      \n      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜\n      if (this.config.cache.enabled && result !== null) {\n        this.addToCache(key, result)\n      }\n      \n      this.updateOperationStats('read', Date.now() - startTime)\n      return result\n      \n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤\n   */\n  async removeItem(key: string): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      if (this.config.batch.enabled) {\n        await this.addToBatch('remove', key)\n      } else {\n        await this.performRemove(key)\n      }\n      \n      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰ã‚‚å‰Šé™¤\n      this.cache.delete(key)\n      \n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    } finally {\n      this.updateOperationStats('delete', Date.now() - startTime)\n    }\n  }\n  \n  /**\n   * ãƒãƒƒãƒå‡¦ç†ã‚’å³åº§ã«å®Ÿè¡Œ\n   */\n  async flushBatch(): Promise<void> {\n    if (this.pendingOperations.length === 0) return\n    \n    const operations = [...this.pendingOperations]\n    this.pendingOperations = []\n    \n    try {\n      await this.executeBatchOperations(operations)\n    } catch (error) {\n      // å¤±æ•—ã—ãŸæ“ä½œã‚’å†ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ \n      this.pendingOperations.unshift(...operations)\n      throw error\n    }\n  }\n  \n  /**\n   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢\n   */\n  clearCache(): void {\n    this.cache.clear()\n  }\n  \n  /**\n   * å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n   */\n  async cleanup(): Promise<{\n    removedKeys: string[]\n    freedSpace: number\n    cacheEvictions: number\n  }> {\n    const removedKeys: string[] = []\n    let freedSpace = 0\n    let cacheEvictions = 0\n    \n    // æœŸé™åˆ‡ã‚Œã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤\n    const now = Date.now()\n    const ttlMs = this.config.cache.ttl * 1000\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > ttlMs) {\n        freedSpace += entry.size\n        this.cache.delete(key)\n        cacheEvictions++\n      }\n    }\n    \n    // LocalStorageã®å¤ã„ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n    if (this.config.enableCleanup) {\n      const gameKeys = this.getGameRelatedKeys()\n      \n      for (const key of gameKeys) {\n        const data = this.storage.getItem(key)\n        if (data && this.isExpiredData(data)) {\n          const size = this.estimateSize(data)\n          this.storage.removeItem(key)\n          removedKeys.push(key)\n          freedSpace += size\n        }\n      }\n    }\n    \n    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºã®åˆ¶é™ã‚’å¼·åˆ¶\n    await this.enforceCache Limits()\n    \n    return { removedKeys, freedSpace, cacheEvictions }\n  }\n  \n  /**\n   * ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ä½¿ç”¨çŠ¶æ³ã‚’å–å¾—\n   */\n  getStorageInfo(): {\n    totalUsed: number\n    gameDataUsed: number\n    cacheSize: number\n    pendingOperations: number\n    compressionRatio: number\n  } {\n    let totalUsed = 0\n    let gameDataUsed = 0\n    \n    // LocalStorageã®ä½¿ç”¨é‡ã‚’è¨ˆç®—\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i)\n      if (key) {\n        const value = localStorage.getItem(key)\n        if (value) {\n          const size = key.length + value.length\n          totalUsed += size\n          \n          if (key.startsWith('game_')) {\n            gameDataUsed += size\n          }\n        }\n      }\n    }\n    \n    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºã‚’è¨ˆç®—\n    const cacheSize = Array.from(this.cache.values())\n      .reduce((sum, entry) => sum + entry.size, 0)\n    \n    // åœ§ç¸®ç‡ã‚’è¨ˆç®—\n    const compressionRatio = this.stats.compressionSaved > 0 \n      ? totalUsed / (totalUsed + this.stats.compressionSaved)\n      : 1\n    \n    return {\n      totalUsed,\n      gameDataUsed,\n      cacheSize,\n      pendingOperations: this.pendingOperations.length,\n      compressionRatio\n    }\n  }\n  \n  /**\n   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆã‚’å–å¾—\n   */\n  getStats(): StorageStats {\n    return { ...this.stats }\n  }\n  \n  /**\n   * çµ±è¨ˆã‚’ãƒªã‚»ãƒƒãƒˆ\n   */\n  resetStats(): void {\n    this.stats = this.initializeStats()\n  }\n  \n  /**\n   * è¨­å®šã‚’æ›´æ–°\n   */\n  updateConfig(newConfig: Partial<StorageOptimizerConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // ã‚¿ã‚¤ãƒãƒ¼ã‚’å†è¨­å®š\n    this.setupTimers()\n    \n    console.log('ğŸ”§ StorageOptimizerè¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸ')\n  }\n  \n  /**\n   * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å–å¾—\n   */\n  getDebugInfo(): {\n    config: StorageOptimizerConfig\n    cacheEntries: number\n    pendingOperations: number\n    stats: StorageStats\n    memoryUsage: number\n  } {\n    return {\n      config: this.config,\n      cacheEntries: this.cache.size,\n      pendingOperations: this.pendingOperations.length,\n      stats: this.stats,\n      memoryUsage: this.estimateMemoryUsage()\n    }\n  }\n  \n  /**\n   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n   */\n  destroy(): void {\n    if (this.batchTimer) {\n      clearInterval(this.batchTimer)\n      this.batchTimer = null\n    }\n    \n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = null\n    }\n    \n    // æ®‹ã‚Šã®ãƒãƒƒãƒæ“ä½œã‚’å®Ÿè¡Œ\n    this.flushBatch().catch(console.error)\n    \n    this.cache.clear()\n    this.pendingOperations = []\n  }\n  \n  // === ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ ===\n  \n  /**\n   * çµ±è¨ˆã‚’åˆæœŸåŒ–\n   */\n  private initializeStats(): StorageStats {\n    return {\n      totalOperations: 0,\n      readOperations: 0,\n      writeOperations: 0,\n      deleteOperations: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      compressionSaved: 0,\n      averageOperationTime: 0,\n      errorCount: 0\n    }\n  }\n  \n  /**\n   * ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š\n   */\n  private setupTimers(): void {\n    // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n    if (this.batchTimer) clearInterval(this.batchTimer)\n    if (this.cleanupTimer) clearInterval(this.cleanupTimer)\n    \n    // ãƒãƒƒãƒå‡¦ç†ã‚¿ã‚¤ãƒãƒ¼\n    if (this.config.batch.enabled) {\n      this.batchTimer = window.setInterval(() => {\n        this.flushBatch().catch(console.error)\n      }, this.config.batch.flushInterval)\n    }\n    \n    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒãƒ¼\n    if (this.config.enableCleanup) {\n      this.cleanupTimer = window.setInterval(() => {\n        this.cleanup().catch(console.error)\n      }, this.config.cleanupInterval)\n    }\n  }\n  \n  /**\n   * ãƒãƒƒãƒæ“ä½œã«è¿½åŠ \n   */\n  private async addToBatch<T>(type: 'set' | 'get' | 'remove', key: string, value?: any): Promise<T | void> {\n    return new Promise((resolve, reject) => {\n      const operation: BatchOperation = {\n        id: this.generateOperationId(),\n        type,\n        key,\n        value,\n        timestamp: Date.now(),\n        resolve,\n        reject\n      }\n      \n      this.pendingOperations.push(operation)\n      \n      // ãƒãƒƒãƒã‚µã‚¤ã‚ºã«é”ã—ãŸã‚‰å³åº§ã«å®Ÿè¡Œ\n      if (this.pendingOperations.length >= this.config.batch.batchSize) {\n        this.flushBatch().catch(reject)\n      }\n      \n      // æœ€å¤§ä¿ç•™æ“ä½œæ•°ã‚’è¶…ãˆãŸå ´åˆã¯ã‚¨ãƒ©ãƒ¼\n      if (this.pendingOperations.length > this.config.batch.maxPendingOperations) {\n        reject(new Error('ãƒãƒƒãƒæ“ä½œã®ä¸Šé™ã‚’è¶…ãˆã¾ã—ãŸ'))\n      }\n    })\n  }\n  \n  /**\n   * ãƒãƒƒãƒæ“ä½œã‚’å®Ÿè¡Œ\n   */\n  private async executeBatchOperations(operations: BatchOperation[]): Promise<void> {\n    for (const operation of operations) {\n      try {\n        let result: any\n        \n        switch (operation.type) {\n          case 'set':\n            await this.performSet(operation.key, operation.value)\n            result = undefined\n            break\n          case 'get':\n            result = await this.performGet(operation.key)\n            break\n          case 'remove':\n            await this.performRemove(operation.key)\n            result = undefined\n            break\n        }\n        \n        operation.resolve(result)\n      } catch (error) {\n        operation.reject(error as Error)\n      }\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’å®Ÿéš›ã«ä¿å­˜\n   */\n  private async performSet(key: string, value: any): Promise<void> {\n    let data = JSON.stringify(value)\n    \n    // åœ§ç¸®ã‚’é©ç”¨\n    if (this.config.compression.enabled && data.length > this.config.compression.threshold) {\n      const compressed = this.compressData(data)\n      if (compressed.length < data.length) {\n        this.stats.compressionSaved += data.length - compressed.length\n        data = compressed\n      }\n    }\n    \n    this.storage.setItem(key, data)\n    \n    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¿½åŠ \n    if (this.config.cache.enabled) {\n      this.addToCache(key, value)\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’å®Ÿéš›ã«å–å¾—\n   */\n  private async performGet<T>(key: string): Promise<T | null> {\n    const data = this.storage.getItem(key)\n    if (!data) return null\n    \n    try {\n      // åœ§ç¸®ãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹åˆ¤å®šã—ã¦è§£å‡\n      const decompressed = this.isCompressedData(data) \n        ? this.decompressData(data) \n        : data\n      \n      return JSON.parse(decompressed)\n    } catch (error) {\n      console.error(`ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ (key: ${key}):`, error)\n      return null\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’å®Ÿéš›ã«å‰Šé™¤\n   */\n  private async performRemove(key: string): Promise<void> {\n    this.storage.removeItem(key)\n  }\n  \n  /**\n   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—\n   */\n  private getFromCache(key: string): any | null {\n    const entry = this.cache.get(key)\n    if (!entry) return null\n    \n    // TTLãƒã‚§ãƒƒã‚¯\n    const now = Date.now()\n    if (now - entry.timestamp > this.config.cache.ttl * 1000) {\n      this.cache.delete(key)\n      return null\n    }\n    \n    // ã‚¢ã‚¯ã‚»ã‚¹æƒ…å ±ã‚’æ›´æ–°\n    entry.accessCount++\n    entry.lastAccess = now\n    \n    return entry.data\n  }\n  \n  /**\n   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«è¿½åŠ \n   */\n  private addToCache(key: string, data: any): void {\n    const size = this.estimateSize(data)\n    const entry: CacheEntry = {\n      data,\n      timestamp: Date.now(),\n      accessCount: 1,\n      lastAccess: Date.now(),\n      size\n    }\n    \n    this.cache.set(key, entry)\n    \n    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ã‚’ç¢ºèª\n    this.enforceCache Limits()\n  }\n  \n  /**\n   * ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™ã‚’å¼·åˆ¶\n   */\n  private async enforceCache Limits(): Promise<void> {\n    const maxSizeBytes = this.config.cache.maxSize * 1024 * 1024 // MB to bytes\n    let currentSize = 0\n    \n    // ç¾åœ¨ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºã‚’è¨ˆç®—\n    for (const entry of this.cache.values()) {\n      currentSize += entry.size\n    }\n    \n    if (currentSize <= maxSizeBytes) return\n    \n    // æˆ¦ç•¥ã«å¿œã˜ã¦ã‚¨ãƒ³ãƒˆãƒªã‚’å‰Šé™¤\n    const entries = Array.from(this.cache.entries())\n    \n    switch (this.config.cache.strategy) {\n      case 'lru': // Least Recently Used\n        entries.sort(([, a], [, b]) => a.lastAccess - b.lastAccess)\n        break\n      case 'lfu': // Least Frequently Used  \n        entries.sort(([, a], [, b]) => a.accessCount - b.accessCount)\n        break\n      case 'fifo': // First In First Out\n        entries.sort(([, a], [, b]) => a.timestamp - b.timestamp)\n        break\n    }\n    \n    // ã‚µã‚¤ã‚ºåˆ¶é™å†…ã«ãªã‚‹ã¾ã§å‰Šé™¤\n    while (currentSize > maxSizeBytes && entries.length > 0) {\n      const [key, entry] = entries.shift()!\n      this.cache.delete(key)\n      currentSize -= entry.size\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’åœ§ç¸®\n   */\n  private compressData(data: string): string {\n    // ç°¡æ˜“åœ§ç¸®å®Ÿè£…ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šé«˜åº¦ãªåœ§ç¸®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨ï¼‰\n    try {\n      // LZ77ãƒ™ãƒ¼ã‚¹ã®ç°¡æ˜“åœ§ç¸®\n      return this.simpleLZCompression(data)\n    } catch (error) {\n      console.warn('åœ§ç¸®ã«å¤±æ•—ã—ã¾ã—ãŸ:', error)\n      return data\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚’è§£å‡\n   */\n  private decompressData(data: string): string {\n    try {\n      return this.simpleLZDecompression(data)\n    } catch (error) {\n      console.warn('è§£å‡ã«å¤±æ•—ã—ã¾ã—ãŸ:', error)\n      return data\n    }\n  }\n  \n  /**\n   * åœ§ç¸®ãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹åˆ¤å®š\n   */\n  private isCompressedData(data: string): boolean {\n    return data.startsWith('LZ_COMPRESSED:')\n  }\n  \n  /**\n   * ç°¡æ˜“LZåœ§ç¸®\n   */\n  private simpleLZCompression(input: string): string {\n    // ç°¡æ˜“å®Ÿè£…ï¼šç¹°ã‚Šè¿”ã—ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡ºã—ã¦åœ§ç¸®\n    const compressed: string[] = []\n    let i = 0\n    \n    while (i < input.length) {\n      let bestMatch = { length: 0, distance: 0 }\n      \n      // å‰æ–¹ã®æ–‡å­—åˆ—ã‹ã‚‰æœ€é•·ä¸€è‡´ã‚’æ¤œç´¢\n      for (let j = Math.max(0, i - 255); j < i; j++) {\n        let matchLength = 0\n        while (i + matchLength < input.length && \n               input[j + matchLength] === input[i + matchLength] &&\n               matchLength < 255) {\n          matchLength++\n        }\n        \n        if (matchLength > bestMatch.length) {\n          bestMatch = { length: matchLength, distance: i - j }\n        }\n      }\n      \n      if (bestMatch.length > 2) {\n        compressed.push(`[${bestMatch.distance},${bestMatch.length}]`)\n        i += bestMatch.length\n      } else {\n        compressed.push(input[i])\n        i++\n      }\n    }\n    \n    const result = 'LZ_COMPRESSED:' + compressed.join('')\n    return result.length < input.length ? result : input\n  }\n  \n  /**\n   * ç°¡æ˜“LZè§£å‡\n   */\n  private simpleLZDecompression(input: string): string {\n    if (!input.startsWith('LZ_COMPRESSED:')) {\n      return input\n    }\n    \n    const compressed = input.substring('LZ_COMPRESSED:'.length)\n    const result: string[] = []\n    let i = 0\n    \n    while (i < compressed.length) {\n      if (compressed[i] === '[') {\n        // åœ§ç¸®ã•ã‚ŒãŸéƒ¨åˆ†ã‚’è§£å‡\n        const endBracket = compressed.indexOf(']', i)\n        const match = compressed.substring(i + 1, endBracket)\n        const [distance, length] = match.split(',').map(Number)\n        \n        const startPos = result.length - distance\n        for (let j = 0; j < length; j++) {\n          result.push(result[startPos + j])\n        }\n        \n        i = endBracket + 1\n      } else {\n        result.push(compressed[i])\n        i++\n      }\n    }\n    \n    return result.join('')\n  }\n  \n  /**\n   * æ“ä½œçµ±è¨ˆã‚’æ›´æ–°\n   */\n  private updateOperationStats(type: 'read' | 'write' | 'delete', duration: number): void {\n    this.stats.totalOperations++\n    \n    switch (type) {\n      case 'read':\n        this.stats.readOperations++\n        break\n      case 'write':\n        this.stats.writeOperations++\n        break\n      case 'delete':\n        this.stats.deleteOperations++\n        break\n    }\n    \n    // å¹³å‡æ“ä½œæ™‚é–“ã‚’æ›´æ–°\n    this.stats.averageOperationTime = \n      (this.stats.averageOperationTime * (this.stats.totalOperations - 1) + duration) / \n      this.stats.totalOperations\n  }\n  \n  /**\n   * ã‚²ãƒ¼ãƒ é–¢é€£ã®ã‚­ãƒ¼ã‚’å–å¾—\n   */\n  private getGameRelatedKeys(): string[] {\n    const keys: string[] = []\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i)\n      if (key && key.startsWith('game_')) {\n        keys.push(key)\n      }\n    }\n    \n    return keys\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ãŒæœŸé™åˆ‡ã‚Œã‹ã©ã†ã‹åˆ¤å®š\n   */\n  private isExpiredData(data: any): boolean {\n    try {\n      if (data.metadata && data.metadata.savedAt) {\n        const savedAt = new Date(data.metadata.savedAt)\n        const now = new Date()\n        const daysDiff = (now.getTime() - savedAt.getTime()) / (1000 * 60 * 60 * 24)\n        \n        // 30æ—¥ä»¥ä¸Šå¤ã„ãƒ‡ãƒ¼ã‚¿ã¯æœŸé™åˆ‡ã‚Œã¨ã¿ãªã™\n        return daysDiff > 30\n      }\n      return false\n    } catch {\n      return false\n    }\n  }\n  \n  /**\n   * ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºã‚’æ¨å®š\n   */\n  private estimateSize(data: any): number {\n    try {\n      return JSON.stringify(data).length\n    } catch {\n      return 0\n    }\n  }\n  \n  /**\n   * ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’æ¨å®š\n   */\n  private estimateMemoryUsage(): number {\n    let memoryUsage = 0\n    \n    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡\n    for (const entry of this.cache.values()) {\n      memoryUsage += entry.size\n    }\n    \n    // ãƒãƒƒãƒæ“ä½œã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡\n    memoryUsage += this.pendingOperations.length * 1024 // 1KB per operation\n    \n    return memoryUsage\n  }\n  \n  /**\n   * æ“ä½œIDã‚’ç”Ÿæˆ\n   */\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n}