import { secureLocalStorage } from '@/utils/security'\n\n/**\n * データ圧縮のオプション\n */\nexport interface CompressionOptions {\n  enabled: boolean\n  level: 'fast' | 'balanced' | 'maximum'\n  threshold: number // 圧縮を開始するデータサイズ（バイト）\n}\n\n/**\n * キャッシュ戦略のオプション\n */\nexport interface CacheOptions {\n  enabled: boolean\n  maxSize: number // MB\n  ttl: number // Time To Live（秒）\n  strategy: 'lru' | 'lfu' | 'fifo'\n}\n\n/**\n * バッチ処理のオプション\n */\nexport interface BatchOptions {\n  enabled: boolean\n  batchSize: number\n  flushInterval: number // ミリ秒\n  maxPendingOperations: number\n}\n\n/**\n * ストレージ最適化の設定\n */\nexport interface StorageOptimizerConfig {\n  compression: CompressionOptions\n  cache: CacheOptions\n  batch: BatchOptions\n  enablePerformanceMonitoring: boolean\n  enableCleanup: boolean\n  cleanupInterval: number // ミリ秒\n}\n\n/**\n * ストレージ操作の統計\n */\nexport interface StorageStats {\n  totalOperations: number\n  readOperations: number\n  writeOperations: number\n  deleteOperations: number\n  cacheHits: number\n  cacheMisses: number\n  compressionSaved: number // バイト\n  averageOperationTime: number // ミリ秒\n  errorCount: number\n}\n\n/**\n * バッチ操作\n */\ninterface BatchOperation {\n  id: string\n  type: 'set' | 'get' | 'remove'\n  key: string\n  value?: any\n  timestamp: number\n  resolve: (result: any) => void\n  reject: (error: Error) => void\n}\n\n/**\n * キャッシュエントリ\n */\ninterface CacheEntry {\n  data: any\n  timestamp: number\n  accessCount: number\n  lastAccess: number\n  size: number\n}\n\n/**\n * LocalStorage活用最適化システム\n * データ圧縮、キャッシュ、バッチ処理、パフォーマンス監視を提供\n */\nexport class StorageOptimizer {\n  private static instance: StorageOptimizer | null = null\n  private config: StorageOptimizerConfig\n  private storage = secureLocalStorage()\n  private cache = new Map<string, CacheEntry>()\n  private pendingOperations: BatchOperation[] = []\n  private stats: StorageStats\n  private batchTimer: number | null = null\n  private cleanupTimer: number | null = null\n  \n  private constructor(config?: Partial<StorageOptimizerConfig>) {\n    this.config = {\n      compression: {\n        enabled: true,\n        level: 'balanced',\n        threshold: 1024 // 1KB\n      },\n      cache: {\n        enabled: true,\n        maxSize: 10, // MB\n        ttl: 3600, // 1時間\n        strategy: 'lru'\n      },\n      batch: {\n        enabled: true,\n        batchSize: 10,\n        flushInterval: 100, // 100ms\n        maxPendingOperations: 100\n      },\n      enablePerformanceMonitoring: true,\n      enableCleanup: true,\n      cleanupInterval: 300000, // 5分\n      ...config\n    }\n    \n    this.stats = this.initializeStats()\n    this.setupTimers()\n  }\n  \n  /**\n   * シングルトンインスタンスを取得\n   */\n  static getInstance(config?: Partial<StorageOptimizerConfig>): StorageOptimizer {\n    if (!StorageOptimizer.instance) {\n      StorageOptimizer.instance = new StorageOptimizer(config)\n    }\n    return StorageOptimizer.instance\n  }\n  \n  /**\n   * データを保存（最適化付き）\n   */\n  async setItem(key: string, value: any): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      if (this.config.batch.enabled) {\n        return await this.addToBatch('set', key, value)\n      } else {\n        return await this.performSet(key, value)\n      }\n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    } finally {\n      this.updateOperationStats('write', Date.now() - startTime)\n    }\n  }\n  \n  /**\n   * データを取得（キャッシュ付き）\n   */\n  async getItem<T>(key: string): Promise<T | null> {\n    const startTime = Date.now()\n    \n    try {\n      // キャッシュから確認\n      if (this.config.cache.enabled) {\n        const cached = this.getFromCache(key)\n        if (cached !== null) {\n          this.stats.cacheHits++\n          this.updateOperationStats('read', Date.now() - startTime)\n          return cached\n        }\n        this.stats.cacheMisses++\n      }\n      \n      // バッチ処理が有効な場合\n      if (this.config.batch.enabled) {\n        const result = await this.addToBatch<T>('get', key)\n        this.updateOperationStats('read', Date.now() - startTime)\n        return result\n      }\n      \n      // 直接読み込み\n      const result = await this.performGet<T>(key)\n      \n      // キャッシュに保存\n      if (this.config.cache.enabled && result !== null) {\n        this.addToCache(key, result)\n      }\n      \n      this.updateOperationStats('read', Date.now() - startTime)\n      return result\n      \n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    }\n  }\n  \n  /**\n   * データを削除\n   */\n  async removeItem(key: string): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      if (this.config.batch.enabled) {\n        await this.addToBatch('remove', key)\n      } else {\n        await this.performRemove(key)\n      }\n      \n      // キャッシュからも削除\n      this.cache.delete(key)\n      \n    } catch (error) {\n      this.stats.errorCount++\n      throw error\n    } finally {\n      this.updateOperationStats('delete', Date.now() - startTime)\n    }\n  }\n  \n  /**\n   * バッチ処理を即座に実行\n   */\n  async flushBatch(): Promise<void> {\n    if (this.pendingOperations.length === 0) return\n    \n    const operations = [...this.pendingOperations]\n    this.pendingOperations = []\n    \n    try {\n      await this.executeBatchOperations(operations)\n    } catch (error) {\n      // 失敗した操作を再キューに追加\n      this.pendingOperations.unshift(...operations)\n      throw error\n    }\n  }\n  \n  /**\n   * キャッシュをクリア\n   */\n  clearCache(): void {\n    this.cache.clear()\n  }\n  \n  /**\n   * 古いデータをクリーンアップ\n   */\n  async cleanup(): Promise<{\n    removedKeys: string[]\n    freedSpace: number\n    cacheEvictions: number\n  }> {\n    const removedKeys: string[] = []\n    let freedSpace = 0\n    let cacheEvictions = 0\n    \n    // 期限切れのキャッシュエントリを削除\n    const now = Date.now()\n    const ttlMs = this.config.cache.ttl * 1000\n    \n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > ttlMs) {\n        freedSpace += entry.size\n        this.cache.delete(key)\n        cacheEvictions++\n      }\n    }\n    \n    // LocalStorageの古いゲームデータをクリーンアップ\n    if (this.config.enableCleanup) {\n      const gameKeys = this.getGameRelatedKeys()\n      \n      for (const key of gameKeys) {\n        const data = this.storage.getItem(key)\n        if (data && this.isExpiredData(data)) {\n          const size = this.estimateSize(data)\n          this.storage.removeItem(key)\n          removedKeys.push(key)\n          freedSpace += size\n        }\n      }\n    }\n    \n    // キャッシュサイズの制限を強制\n    await this.enforceCache Limits()\n    \n    return { removedKeys, freedSpace, cacheEvictions }\n  }\n  \n  /**\n   * ストレージ使用状況を取得\n   */\n  getStorageInfo(): {\n    totalUsed: number\n    gameDataUsed: number\n    cacheSize: number\n    pendingOperations: number\n    compressionRatio: number\n  } {\n    let totalUsed = 0\n    let gameDataUsed = 0\n    \n    // LocalStorageの使用量を計算\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i)\n      if (key) {\n        const value = localStorage.getItem(key)\n        if (value) {\n          const size = key.length + value.length\n          totalUsed += size\n          \n          if (key.startsWith('game_')) {\n            gameDataUsed += size\n          }\n        }\n      }\n    }\n    \n    // キャッシュサイズを計算\n    const cacheSize = Array.from(this.cache.values())\n      .reduce((sum, entry) => sum + entry.size, 0)\n    \n    // 圧縮率を計算\n    const compressionRatio = this.stats.compressionSaved > 0 \n      ? totalUsed / (totalUsed + this.stats.compressionSaved)\n      : 1\n    \n    return {\n      totalUsed,\n      gameDataUsed,\n      cacheSize,\n      pendingOperations: this.pendingOperations.length,\n      compressionRatio\n    }\n  }\n  \n  /**\n   * パフォーマンス統計を取得\n   */\n  getStats(): StorageStats {\n    return { ...this.stats }\n  }\n  \n  /**\n   * 統計をリセット\n   */\n  resetStats(): void {\n    this.stats = this.initializeStats()\n  }\n  \n  /**\n   * 設定を更新\n   */\n  updateConfig(newConfig: Partial<StorageOptimizerConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // タイマーを再設定\n    this.setupTimers()\n    \n    console.log('🔧 StorageOptimizer設定を更新しました')\n  }\n  \n  /**\n   * デバッグ情報を取得\n   */\n  getDebugInfo(): {\n    config: StorageOptimizerConfig\n    cacheEntries: number\n    pendingOperations: number\n    stats: StorageStats\n    memoryUsage: number\n  } {\n    return {\n      config: this.config,\n      cacheEntries: this.cache.size,\n      pendingOperations: this.pendingOperations.length,\n      stats: this.stats,\n      memoryUsage: this.estimateMemoryUsage()\n    }\n  }\n  \n  /**\n   * クリーンアップ\n   */\n  destroy(): void {\n    if (this.batchTimer) {\n      clearInterval(this.batchTimer)\n      this.batchTimer = null\n    }\n    \n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer)\n      this.cleanupTimer = null\n    }\n    \n    // 残りのバッチ操作を実行\n    this.flushBatch().catch(console.error)\n    \n    this.cache.clear()\n    this.pendingOperations = []\n  }\n  \n  // === プライベートメソッド ===\n  \n  /**\n   * 統計を初期化\n   */\n  private initializeStats(): StorageStats {\n    return {\n      totalOperations: 0,\n      readOperations: 0,\n      writeOperations: 0,\n      deleteOperations: 0,\n      cacheHits: 0,\n      cacheMisses: 0,\n      compressionSaved: 0,\n      averageOperationTime: 0,\n      errorCount: 0\n    }\n  }\n  \n  /**\n   * タイマーを設定\n   */\n  private setupTimers(): void {\n    // 既存のタイマーをクリア\n    if (this.batchTimer) clearInterval(this.batchTimer)\n    if (this.cleanupTimer) clearInterval(this.cleanupTimer)\n    \n    // バッチ処理タイマー\n    if (this.config.batch.enabled) {\n      this.batchTimer = window.setInterval(() => {\n        this.flushBatch().catch(console.error)\n      }, this.config.batch.flushInterval)\n    }\n    \n    // クリーンアップタイマー\n    if (this.config.enableCleanup) {\n      this.cleanupTimer = window.setInterval(() => {\n        this.cleanup().catch(console.error)\n      }, this.config.cleanupInterval)\n    }\n  }\n  \n  /**\n   * バッチ操作に追加\n   */\n  private async addToBatch<T>(type: 'set' | 'get' | 'remove', key: string, value?: any): Promise<T | void> {\n    return new Promise((resolve, reject) => {\n      const operation: BatchOperation = {\n        id: this.generateOperationId(),\n        type,\n        key,\n        value,\n        timestamp: Date.now(),\n        resolve,\n        reject\n      }\n      \n      this.pendingOperations.push(operation)\n      \n      // バッチサイズに達したら即座に実行\n      if (this.pendingOperations.length >= this.config.batch.batchSize) {\n        this.flushBatch().catch(reject)\n      }\n      \n      // 最大保留操作数を超えた場合はエラー\n      if (this.pendingOperations.length > this.config.batch.maxPendingOperations) {\n        reject(new Error('バッチ操作の上限を超えました'))\n      }\n    })\n  }\n  \n  /**\n   * バッチ操作を実行\n   */\n  private async executeBatchOperations(operations: BatchOperation[]): Promise<void> {\n    for (const operation of operations) {\n      try {\n        let result: any\n        \n        switch (operation.type) {\n          case 'set':\n            await this.performSet(operation.key, operation.value)\n            result = undefined\n            break\n          case 'get':\n            result = await this.performGet(operation.key)\n            break\n          case 'remove':\n            await this.performRemove(operation.key)\n            result = undefined\n            break\n        }\n        \n        operation.resolve(result)\n      } catch (error) {\n        operation.reject(error as Error)\n      }\n    }\n  }\n  \n  /**\n   * データを実際に保存\n   */\n  private async performSet(key: string, value: any): Promise<void> {\n    let data = JSON.stringify(value)\n    \n    // 圧縮を適用\n    if (this.config.compression.enabled && data.length > this.config.compression.threshold) {\n      const compressed = this.compressData(data)\n      if (compressed.length < data.length) {\n        this.stats.compressionSaved += data.length - compressed.length\n        data = compressed\n      }\n    }\n    \n    this.storage.setItem(key, data)\n    \n    // キャッシュに追加\n    if (this.config.cache.enabled) {\n      this.addToCache(key, value)\n    }\n  }\n  \n  /**\n   * データを実際に取得\n   */\n  private async performGet<T>(key: string): Promise<T | null> {\n    const data = this.storage.getItem(key)\n    if (!data) return null\n    \n    try {\n      // 圧縮データかどうか判定して解凍\n      const decompressed = this.isCompressedData(data) \n        ? this.decompressData(data) \n        : data\n      \n      return JSON.parse(decompressed)\n    } catch (error) {\n      console.error(`データ取得エラー (key: ${key}):`, error)\n      return null\n    }\n  }\n  \n  /**\n   * データを実際に削除\n   */\n  private async performRemove(key: string): Promise<void> {\n    this.storage.removeItem(key)\n  }\n  \n  /**\n   * キャッシュから取得\n   */\n  private getFromCache(key: string): any | null {\n    const entry = this.cache.get(key)\n    if (!entry) return null\n    \n    // TTLチェック\n    const now = Date.now()\n    if (now - entry.timestamp > this.config.cache.ttl * 1000) {\n      this.cache.delete(key)\n      return null\n    }\n    \n    // アクセス情報を更新\n    entry.accessCount++\n    entry.lastAccess = now\n    \n    return entry.data\n  }\n  \n  /**\n   * キャッシュに追加\n   */\n  private addToCache(key: string, data: any): void {\n    const size = this.estimateSize(data)\n    const entry: CacheEntry = {\n      data,\n      timestamp: Date.now(),\n      accessCount: 1,\n      lastAccess: Date.now(),\n      size\n    }\n    \n    this.cache.set(key, entry)\n    \n    // キャッシュサイズ制限を確認\n    this.enforceCache Limits()\n  }\n  \n  /**\n   * キャッシュサイズ制限を強制\n   */\n  private async enforceCache Limits(): Promise<void> {\n    const maxSizeBytes = this.config.cache.maxSize * 1024 * 1024 // MB to bytes\n    let currentSize = 0\n    \n    // 現在のキャッシュサイズを計算\n    for (const entry of this.cache.values()) {\n      currentSize += entry.size\n    }\n    \n    if (currentSize <= maxSizeBytes) return\n    \n    // 戦略に応じてエントリを削除\n    const entries = Array.from(this.cache.entries())\n    \n    switch (this.config.cache.strategy) {\n      case 'lru': // Least Recently Used\n        entries.sort(([, a], [, b]) => a.lastAccess - b.lastAccess)\n        break\n      case 'lfu': // Least Frequently Used  \n        entries.sort(([, a], [, b]) => a.accessCount - b.accessCount)\n        break\n      case 'fifo': // First In First Out\n        entries.sort(([, a], [, b]) => a.timestamp - b.timestamp)\n        break\n    }\n    \n    // サイズ制限内になるまで削除\n    while (currentSize > maxSizeBytes && entries.length > 0) {\n      const [key, entry] = entries.shift()!\n      this.cache.delete(key)\n      currentSize -= entry.size\n    }\n  }\n  \n  /**\n   * データを圧縮\n   */\n  private compressData(data: string): string {\n    // 簡易圧縮実装（実際はより高度な圧縮アルゴリズムを使用）\n    try {\n      // LZ77ベースの簡易圧縮\n      return this.simpleLZCompression(data)\n    } catch (error) {\n      console.warn('圧縮に失敗しました:', error)\n      return data\n    }\n  }\n  \n  /**\n   * データを解凍\n   */\n  private decompressData(data: string): string {\n    try {\n      return this.simpleLZDecompression(data)\n    } catch (error) {\n      console.warn('解凍に失敗しました:', error)\n      return data\n    }\n  }\n  \n  /**\n   * 圧縮データかどうか判定\n   */\n  private isCompressedData(data: string): boolean {\n    return data.startsWith('LZ_COMPRESSED:')\n  }\n  \n  /**\n   * 簡易LZ圧縮\n   */\n  private simpleLZCompression(input: string): string {\n    // 簡易実装：繰り返しパターンを検出して圧縮\n    const compressed: string[] = []\n    let i = 0\n    \n    while (i < input.length) {\n      let bestMatch = { length: 0, distance: 0 }\n      \n      // 前方の文字列から最長一致を検索\n      for (let j = Math.max(0, i - 255); j < i; j++) {\n        let matchLength = 0\n        while (i + matchLength < input.length && \n               input[j + matchLength] === input[i + matchLength] &&\n               matchLength < 255) {\n          matchLength++\n        }\n        \n        if (matchLength > bestMatch.length) {\n          bestMatch = { length: matchLength, distance: i - j }\n        }\n      }\n      \n      if (bestMatch.length > 2) {\n        compressed.push(`[${bestMatch.distance},${bestMatch.length}]`)\n        i += bestMatch.length\n      } else {\n        compressed.push(input[i])\n        i++\n      }\n    }\n    \n    const result = 'LZ_COMPRESSED:' + compressed.join('')\n    return result.length < input.length ? result : input\n  }\n  \n  /**\n   * 簡易LZ解凍\n   */\n  private simpleLZDecompression(input: string): string {\n    if (!input.startsWith('LZ_COMPRESSED:')) {\n      return input\n    }\n    \n    const compressed = input.substring('LZ_COMPRESSED:'.length)\n    const result: string[] = []\n    let i = 0\n    \n    while (i < compressed.length) {\n      if (compressed[i] === '[') {\n        // 圧縮された部分を解凍\n        const endBracket = compressed.indexOf(']', i)\n        const match = compressed.substring(i + 1, endBracket)\n        const [distance, length] = match.split(',').map(Number)\n        \n        const startPos = result.length - distance\n        for (let j = 0; j < length; j++) {\n          result.push(result[startPos + j])\n        }\n        \n        i = endBracket + 1\n      } else {\n        result.push(compressed[i])\n        i++\n      }\n    }\n    \n    return result.join('')\n  }\n  \n  /**\n   * 操作統計を更新\n   */\n  private updateOperationStats(type: 'read' | 'write' | 'delete', duration: number): void {\n    this.stats.totalOperations++\n    \n    switch (type) {\n      case 'read':\n        this.stats.readOperations++\n        break\n      case 'write':\n        this.stats.writeOperations++\n        break\n      case 'delete':\n        this.stats.deleteOperations++\n        break\n    }\n    \n    // 平均操作時間を更新\n    this.stats.averageOperationTime = \n      (this.stats.averageOperationTime * (this.stats.totalOperations - 1) + duration) / \n      this.stats.totalOperations\n  }\n  \n  /**\n   * ゲーム関連のキーを取得\n   */\n  private getGameRelatedKeys(): string[] {\n    const keys: string[] = []\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i)\n      if (key && key.startsWith('game_')) {\n        keys.push(key)\n      }\n    }\n    \n    return keys\n  }\n  \n  /**\n   * データが期限切れかどうか判定\n   */\n  private isExpiredData(data: any): boolean {\n    try {\n      if (data.metadata && data.metadata.savedAt) {\n        const savedAt = new Date(data.metadata.savedAt)\n        const now = new Date()\n        const daysDiff = (now.getTime() - savedAt.getTime()) / (1000 * 60 * 60 * 24)\n        \n        // 30日以上古いデータは期限切れとみなす\n        return daysDiff > 30\n      }\n      return false\n    } catch {\n      return false\n    }\n  }\n  \n  /**\n   * データサイズを推定\n   */\n  private estimateSize(data: any): number {\n    try {\n      return JSON.stringify(data).length\n    } catch {\n      return 0\n    }\n  }\n  \n  /**\n   * メモリ使用量を推定\n   */\n  private estimateMemoryUsage(): number {\n    let memoryUsage = 0\n    \n    // キャッシュのメモリ使用量\n    for (const entry of this.cache.values()) {\n      memoryUsage += entry.size\n    }\n    \n    // バッチ操作のメモリ使用量\n    memoryUsage += this.pendingOperations.length * 1024 // 1KB per operation\n    \n    return memoryUsage\n  }\n  \n  /**\n   * 操作IDを生成\n   */\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n  }\n}