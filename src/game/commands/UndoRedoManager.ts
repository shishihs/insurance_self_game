import type { Game } from '@/domain/entities/Game'\nimport type { Card } from '@/domain/entities/Card'\nimport { CommandHistory, type CommandHistoryConfig, type UndoRedoResult } from './CommandHistory'\nimport { \n  CardSelectionCommand, \n  ChallengeCommand, \n  InsurancePurchaseCommand, \n  NextTurnCommand,\n  SnapshotCommand,\n  type GameCommand \n} from './GameCommand'\n\n/**\n * Undo/Redoæ“ä½œã®ã‚¤ãƒ™ãƒ³ãƒˆ\n */\nexport interface UndoRedoEvent {\n  type: 'undo' | 'redo' | 'command_executed' | 'history_cleared'\n  result: UndoRedoResult\n  historyState: {\n    canUndo: boolean\n    canRedo: boolean\n    undoableCount: number\n    redoableCount: number\n  }\n}\n\n/**\n * Undo/Redoã®è¨­å®š\n */\nexport interface UndoRedoConfig extends CommandHistoryConfig {\n  enableKeyboardShortcuts: boolean\n  enableAutoSnapshot: boolean\n  snapshotInterval: number // ã‚¿ãƒ¼ãƒ³æ•°\n  maxSnapshots: number\n}\n\n/**\n * Undo/Redoç®¡ç†ã‚·ã‚¹ãƒ†ãƒ \n * ã‚²ãƒ¼ãƒ å†…ã§ã®Undo/Redoæ“ä½œã‚’çµ±åˆç®¡ç†\n */\nexport class UndoRedoManager {\n  private commandHistory: CommandHistory\n  private currentGame: Game | null = null\n  private eventListeners: ((event: UndoRedoEvent) => void)[] = []\n  private snapshots: Map<number, any> = new Map() // ã‚¿ãƒ¼ãƒ³ç•ªå· -> ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆ\n  private config: UndoRedoConfig\n  \n  constructor(config?: Partial<UndoRedoConfig>) {\n    this.config = {\n      maxHistorySize: 50,\n      enableMerging: true,\n      mergeTimeWindow: 1000,\n      undoableTurnLimit: 3,\n      enableKeyboardShortcuts: true,\n      enableAutoSnapshot: true,\n      snapshotInterval: 5,\n      maxSnapshots: 10,\n      ...config\n    }\n    \n    this.commandHistory = new CommandHistory(this.config)\n    \n    if (this.config.enableKeyboardShortcuts) {\n      this.setupKeyboardShortcuts()\n    }\n  }\n  \n  /**\n   * ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã‚’è¨­å®š\n   */\n  setCurrentGame(game: Game): void {\n    this.currentGame = game\n    this.commandHistory.clear()\n    this.snapshots.clear()\n    \n    // åˆæœŸã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ\n    if (this.config.enableAutoSnapshot) {\n      this.createSnapshot('ã‚²ãƒ¼ãƒ é–‹å§‹')\n    }\n  }\n  \n  /**\n   * ã‚«ãƒ¼ãƒ‰é¸æŠã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ\n   */\n  async selectCard(card: Card, select: boolean): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    const command = new CardSelectionCommand(card, select)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ\n   */\n  async executeChallenge(challengeCard: Card): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    // ãƒãƒ£ãƒ¬ãƒ³ã‚¸å‰ã«ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ\n    await this.createSnapshot(`ãƒãƒ£ãƒ¬ãƒ³ã‚¸å‰ - ã‚¿ãƒ¼ãƒ³${this.currentGame.turn}`)\n    \n    const command = new ChallengeCommand(challengeCard)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * ä¿é™ºè³¼å…¥ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ\n   */\n  async purchaseInsurance(insuranceType: string, durationType: 'term' | 'whole_life'): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    const command = new InsurancePurchaseCommand(insuranceType, durationType)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * ã‚¿ãƒ¼ãƒ³é€²è¡Œã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ\n   */\n  async nextTurn(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    // ã‚¿ãƒ¼ãƒ³é€²è¡Œå‰ã«ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ\n    if (this.config.enableAutoSnapshot && \n        this.currentGame.turn % this.config.snapshotInterval === 0) {\n      await this.createSnapshot(`ã‚¿ãƒ¼ãƒ³${this.currentGame.turn}å®Œäº†`)\n    }\n    \n    const command = new NextTurnCommand()\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * Undoã‚’å®Ÿè¡Œ\n   */\n  async undo(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    const result = await this.commandHistory.undo(this.currentGame)\n    this.emitEvent('undo', result)\n    return result\n  }\n  \n  /**\n   * Redoã‚’å®Ÿè¡Œ\n   */\n  async redo(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    const result = await this.commandHistory.redo(this.currentGame)\n    this.emitEvent('redo', result)\n    return result\n  }\n  \n  /**\n   * è¤‡æ•°ã®Undoã‚’å®Ÿè¡Œ\n   */\n  async undoMultiple(count: number): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    const result = await this.commandHistory.undoMultiple(count, this.currentGame)\n    this.emitEvent('undo', result)\n    return result\n  }\n  \n  /**\n   * å‰ã®ã‚¿ãƒ¼ãƒ³ã«æˆ»ã‚‹ï¼ˆã‚¿ãƒ¼ãƒ³å˜ä½ã§ã®Undoï¼‰\n   */\n  async undoToTurn(targetTurn: number): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãŒã‚ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨\n    const snapshot = this.snapshots.get(targetTurn)\n    if (snapshot) {\n      return await this.restoreFromSnapshot(targetTurn, snapshot)\n    }\n    \n    // ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆãŒãªã„å ´åˆã¯ã‚³ãƒãƒ³ãƒ‰å±¥æ­´ã‹ã‚‰å¾©å…ƒ\n    const historyDetails = this.commandHistory.getHistoryDetails()\n    const targetCommand = historyDetails.find(detail => \n      detail.command.includes(`ã‚¿ãƒ¼ãƒ³${targetTurn}`)\n    )\n    \n    if (targetCommand) {\n      return await this.commandHistory.restoreToPoint(targetCommand.index, this.currentGame)\n    }\n    \n    return this.createErrorResult(`ã‚¿ãƒ¼ãƒ³${targetTurn}ã¸ã®å¾©å…ƒãƒã‚¤ãƒ³ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`)\n  }\n  \n  /**\n   * ç¾åœ¨ã®å±¥æ­´çŠ¶æ…‹ã‚’å–å¾—\n   */\n  getHistoryState(): {\n    canUndo: boolean\n    canRedo: boolean\n    undoableCount: number\n    redoableCount: number\n    currentCommand?: string\n    nextCommand?: string\n    availableSnapshots: number[]\n  } {\n    const state = this.commandHistory.getHistoryState()\n    return {\n      ...state,\n      availableSnapshots: Array.from(this.snapshots.keys()).sort((a, b) => b - a)\n    }\n  }\n  \n  /**\n   * å±¥æ­´ã®çµ±è¨ˆã‚’å–å¾—\n   */\n  getHistoryStats() {\n    return this.commandHistory.getStats()\n  }\n  \n  /**\n   * å±¥æ­´ã®è©³ç´°ã‚’å–å¾—ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰\n   */\n  getHistoryDetails() {\n    return this.commandHistory.getHistoryDetails()\n  }\n  \n  /**\n   * ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‚’ä½œæˆ\n   */\n  async createSnapshot(description: string): Promise<void> {\n    if (!this.currentGame) return\n    \n    const snapshotCommand = new SnapshotCommand(description)\n    await snapshotCommand.execute(this.currentGame)\n    \n    const turn = this.currentGame.turn\n    this.snapshots.set(turn, snapshotCommand.getSnapshot())\n    \n    // æœ€å¤§ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆæ•°ã®åˆ¶é™\n    if (this.snapshots.size > this.config.maxSnapshots) {\n      const oldestTurn = Math.min(...this.snapshots.keys())\n      this.snapshots.delete(oldestTurn)\n    }\n    \n    console.log(`ğŸ“¸ ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆä½œæˆ: ${description} (ã‚¿ãƒ¼ãƒ³${turn})`)\n  }\n  \n  /**\n   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ \n   */\n  addEventListener(listener: (event: UndoRedoEvent) => void): void {\n    this.eventListeners.push(listener)\n  }\n  \n  /**\n   * ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤\n   */\n  removeEventListener(listener: (event: UndoRedoEvent) => void): void {\n    const index = this.eventListeners.indexOf(listener)\n    if (index !== -1) {\n      this.eventListeners.splice(index, 1)\n    }\n  }\n  \n  /**\n   * å±¥æ­´ã‚’ã‚¯ãƒªã‚¢\n   */\n  clearHistory(): void {\n    this.commandHistory.clear()\n    this.snapshots.clear()\n    \n    const result: UndoRedoResult = {\n      success: true,\n      message: 'å±¥æ­´ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ',\n      affectedCommands: 0\n    }\n    \n    this.emitEvent('history_cleared', result)\n  }\n  \n  /**\n   * è¨­å®šã‚’æ›´æ–°\n   */\n  updateConfig(newConfig: Partial<UndoRedoConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // æ–°ã—ã„è¨­å®šã§ã‚³ãƒãƒ³ãƒ‰å±¥æ­´ã‚’å†åˆæœŸåŒ–\n    const currentState = this.commandHistory.getHistoryDetails()\n    this.commandHistory = new CommandHistory(this.config)\n    \n    console.log('ğŸ”§ Undo/Redoè¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸ')\n  }\n  \n  /**\n   * ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å–å¾—\n   */\n  getDebugInfo(): {\n    config: UndoRedoConfig\n    historySize: number\n    snapshotCount: number\n    currentTurn: number | null\n    memoryUsage: number\n  } {\n    const historyDetails = this.commandHistory.getHistoryDetails()\n    \n    return {\n      config: this.config,\n      historySize: historyDetails.length,\n      snapshotCount: this.snapshots.size,\n      currentTurn: this.currentGame?.turn || null,\n      memoryUsage: this.estimateMemoryUsage()\n    }\n  }\n  \n  /**\n   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n   */\n  destroy(): void {\n    this.clearHistory()\n    this.eventListeners = []\n    this.currentGame = null\n    \n    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤\n    if (this.config.enableKeyboardShortcuts) {\n      this.removeKeyboardShortcuts()\n    }\n  }\n  \n  // === ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ã‚½ãƒƒãƒ‰ ===\n  \n  /**\n   * ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œ\n   */\n  private async executeCommand(command: GameCommand): Promise<UndoRedoResult> {\n    const result = await this.commandHistory.executeCommand(command, this.currentGame!)\n    \n    if (result.success) {\n      this.emitEvent('command_executed', result)\n    }\n    \n    return result\n  }\n  \n  /**\n   * ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰å¾©å…ƒ\n   */\n  private async restoreFromSnapshot(turn: number, snapshot: any): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ã‚²ãƒ¼ãƒ ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“')\n    }\n    \n    try {\n      // TODO: ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆã‹ã‚‰ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’å¾©å…ƒã™ã‚‹å‡¦ç†\n      // ç¾åœ¨ã¯ç°¡æ˜“å®Ÿè£…\n      console.log(`ğŸ“¼ ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆå¾©å…ƒ: ã‚¿ãƒ¼ãƒ³${turn}`)\n      \n      return {\n        success: true,\n        message: `ã‚¿ãƒ¼ãƒ³${turn}ã®çŠ¶æ…‹ã«å¾©å…ƒã—ã¾ã—ãŸ`,\n        affectedCommands: 1\n      }\n    } catch (error) {\n      return this.createErrorResult(`å¾©å…ƒã‚¨ãƒ©ãƒ¼: ${error}`)\n    }\n  }\n  \n  /**\n   * ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’è¨­å®š\n   */\n  private setupKeyboardShortcuts(): void {\n    document.addEventListener('keydown', this.handleKeyDown.bind(this))\n  }\n  \n  /**\n   * ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’å‰Šé™¤\n   */\n  private removeKeyboardShortcuts(): void {\n    document.removeEventListener('keydown', this.handleKeyDown.bind(this))\n  }\n  \n  /**\n   * ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†\n   */\n  private handleKeyDown(event: KeyboardEvent): void {\n    if (!this.currentGame) return\n    \n    const isCtrlOrCmd = event.ctrlKey || event.metaKey\n    \n    if (isCtrlOrCmd) {\n      switch (event.key.toLowerCase()) {\n        case 'z':\n          if (event.shiftKey) {\n            // Ctrl+Shift+Z ã¾ãŸã¯ Cmd+Shift+Z ã§Redo\n            event.preventDefault()\n            this.redo()\n          } else {\n            // Ctrl+Z ã¾ãŸã¯ Cmd+Z ã§Undo\n            event.preventDefault()\n            this.undo()\n          }\n          break\n        \n        case 'y':\n          // Ctrl+Y ã§Redo (Windows)\n          if (!event.shiftKey) {\n            event.preventDefault()\n            this.redo()\n          }\n          break\n      }\n    }\n  }\n  \n  /**\n   * ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œ\n   */\n  private emitEvent(type: UndoRedoEvent['type'], result: UndoRedoResult): void {\n    const event: UndoRedoEvent = {\n      type,\n      result,\n      historyState: {\n        canUndo: this.commandHistory.canUndo(),\n        canRedo: this.commandHistory.canRedo(),\n        undoableCount: this.commandHistory.getUndoableCount(),\n        redoableCount: this.commandHistory.getRedoableCount()\n      }\n    }\n    \n    this.eventListeners.forEach(listener => {\n      try {\n        listener(event)\n      } catch (error) {\n        console.error('Undo/Redoã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚¨ãƒ©ãƒ¼:', error)\n      }\n    })\n  }\n  \n  /**\n   * ã‚¨ãƒ©ãƒ¼çµæœã‚’ä½œæˆ\n   */\n  private createErrorResult(message: string): UndoRedoResult {\n    return {\n      success: false,\n      message,\n      affectedCommands: 0\n    }\n  }\n  \n  /**\n   * ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã‚’æ¨å®š\n   */\n  private estimateMemoryUsage(): number {\n    // ç°¡æ˜“çš„ãªãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¨å®š\n    const historySize = this.commandHistory.getHistoryDetails().length\n    const snapshotSize = this.snapshots.size\n    \n    // 1ã‚³ãƒãƒ³ãƒ‰ç´„1KBã€1ã‚¹ãƒŠãƒƒãƒ—ã‚·ãƒ§ãƒƒãƒˆç´„10KBã¨ä»®å®š\n    return historySize * 1024 + snapshotSize * 10240\n  }\n}