import type { Game } from '@/domain/entities/Game'\nimport type { Card } from '@/domain/entities/Card'\nimport { CommandHistory, type CommandHistoryConfig, type UndoRedoResult } from './CommandHistory'\nimport { \n  CardSelectionCommand, \n  ChallengeCommand, \n  InsurancePurchaseCommand, \n  NextTurnCommand,\n  SnapshotCommand,\n  type GameCommand \n} from './GameCommand'\n\n/**\n * Undo/Redo操作のイベント\n */\nexport interface UndoRedoEvent {\n  type: 'undo' | 'redo' | 'command_executed' | 'history_cleared'\n  result: UndoRedoResult\n  historyState: {\n    canUndo: boolean\n    canRedo: boolean\n    undoableCount: number\n    redoableCount: number\n  }\n}\n\n/**\n * Undo/Redoの設定\n */\nexport interface UndoRedoConfig extends CommandHistoryConfig {\n  enableKeyboardShortcuts: boolean\n  enableAutoSnapshot: boolean\n  snapshotInterval: number // ターン数\n  maxSnapshots: number\n}\n\n/**\n * Undo/Redo管理システム\n * ゲーム内でのUndo/Redo操作を統合管理\n */\nexport class UndoRedoManager {\n  private commandHistory: CommandHistory\n  private currentGame: Game | null = null\n  private eventListeners: ((event: UndoRedoEvent) => void)[] = []\n  private snapshots: Map<number, any> = new Map() // ターン番号 -> スナップショット\n  private config: UndoRedoConfig\n  \n  constructor(config?: Partial<UndoRedoConfig>) {\n    this.config = {\n      maxHistorySize: 50,\n      enableMerging: true,\n      mergeTimeWindow: 1000,\n      undoableTurnLimit: 3,\n      enableKeyboardShortcuts: true,\n      enableAutoSnapshot: true,\n      snapshotInterval: 5,\n      maxSnapshots: 10,\n      ...config\n    }\n    \n    this.commandHistory = new CommandHistory(this.config)\n    \n    if (this.config.enableKeyboardShortcuts) {\n      this.setupKeyboardShortcuts()\n    }\n  }\n  \n  /**\n   * 現在のゲームを設定\n   */\n  setCurrentGame(game: Game): void {\n    this.currentGame = game\n    this.commandHistory.clear()\n    this.snapshots.clear()\n    \n    // 初期スナップショットを作成\n    if (this.config.enableAutoSnapshot) {\n      this.createSnapshot('ゲーム開始')\n    }\n  }\n  \n  /**\n   * カード選択コマンドを実行\n   */\n  async selectCard(card: Card, select: boolean): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    const command = new CardSelectionCommand(card, select)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * チャレンジコマンドを実行\n   */\n  async executeChallenge(challengeCard: Card): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    // チャレンジ前にスナップショットを作成\n    await this.createSnapshot(`チャレンジ前 - ターン${this.currentGame.turn}`)\n    \n    const command = new ChallengeCommand(challengeCard)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * 保険購入コマンドを実行\n   */\n  async purchaseInsurance(insuranceType: string, durationType: 'term' | 'whole_life'): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    const command = new InsurancePurchaseCommand(insuranceType, durationType)\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * ターン進行コマンドを実行\n   */\n  async nextTurn(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    // ターン進行前にスナップショットを作成\n    if (this.config.enableAutoSnapshot && \n        this.currentGame.turn % this.config.snapshotInterval === 0) {\n      await this.createSnapshot(`ターン${this.currentGame.turn}完了`)\n    }\n    \n    const command = new NextTurnCommand()\n    return await this.executeCommand(command)\n  }\n  \n  /**\n   * Undoを実行\n   */\n  async undo(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    const result = await this.commandHistory.undo(this.currentGame)\n    this.emitEvent('undo', result)\n    return result\n  }\n  \n  /**\n   * Redoを実行\n   */\n  async redo(): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    const result = await this.commandHistory.redo(this.currentGame)\n    this.emitEvent('redo', result)\n    return result\n  }\n  \n  /**\n   * 複数のUndoを実行\n   */\n  async undoMultiple(count: number): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    const result = await this.commandHistory.undoMultiple(count, this.currentGame)\n    this.emitEvent('undo', result)\n    return result\n  }\n  \n  /**\n   * 前のターンに戻る（ターン単位でのUndo）\n   */\n  async undoToTurn(targetTurn: number): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    // スナップショットがある場合はそれを使用\n    const snapshot = this.snapshots.get(targetTurn)\n    if (snapshot) {\n      return await this.restoreFromSnapshot(targetTurn, snapshot)\n    }\n    \n    // スナップショットがない場合はコマンド履歴から復元\n    const historyDetails = this.commandHistory.getHistoryDetails()\n    const targetCommand = historyDetails.find(detail => \n      detail.command.includes(`ターン${targetTurn}`)\n    )\n    \n    if (targetCommand) {\n      return await this.commandHistory.restoreToPoint(targetCommand.index, this.currentGame)\n    }\n    \n    return this.createErrorResult(`ターン${targetTurn}への復元ポイントが見つかりません`)\n  }\n  \n  /**\n   * 現在の履歴状態を取得\n   */\n  getHistoryState(): {\n    canUndo: boolean\n    canRedo: boolean\n    undoableCount: number\n    redoableCount: number\n    currentCommand?: string\n    nextCommand?: string\n    availableSnapshots: number[]\n  } {\n    const state = this.commandHistory.getHistoryState()\n    return {\n      ...state,\n      availableSnapshots: Array.from(this.snapshots.keys()).sort((a, b) => b - a)\n    }\n  }\n  \n  /**\n   * 履歴の統計を取得\n   */\n  getHistoryStats() {\n    return this.commandHistory.getStats()\n  }\n  \n  /**\n   * 履歴の詳細を取得（デバッグ用）\n   */\n  getHistoryDetails() {\n    return this.commandHistory.getHistoryDetails()\n  }\n  \n  /**\n   * スナップショットを作成\n   */\n  async createSnapshot(description: string): Promise<void> {\n    if (!this.currentGame) return\n    \n    const snapshotCommand = new SnapshotCommand(description)\n    await snapshotCommand.execute(this.currentGame)\n    \n    const turn = this.currentGame.turn\n    this.snapshots.set(turn, snapshotCommand.getSnapshot())\n    \n    // 最大スナップショット数の制限\n    if (this.snapshots.size > this.config.maxSnapshots) {\n      const oldestTurn = Math.min(...this.snapshots.keys())\n      this.snapshots.delete(oldestTurn)\n    }\n    \n    console.log(`📸 スナップショット作成: ${description} (ターン${turn})`)\n  }\n  \n  /**\n   * イベントリスナーを追加\n   */\n  addEventListener(listener: (event: UndoRedoEvent) => void): void {\n    this.eventListeners.push(listener)\n  }\n  \n  /**\n   * イベントリスナーを削除\n   */\n  removeEventListener(listener: (event: UndoRedoEvent) => void): void {\n    const index = this.eventListeners.indexOf(listener)\n    if (index !== -1) {\n      this.eventListeners.splice(index, 1)\n    }\n  }\n  \n  /**\n   * 履歴をクリア\n   */\n  clearHistory(): void {\n    this.commandHistory.clear()\n    this.snapshots.clear()\n    \n    const result: UndoRedoResult = {\n      success: true,\n      message: '履歴をクリアしました',\n      affectedCommands: 0\n    }\n    \n    this.emitEvent('history_cleared', result)\n  }\n  \n  /**\n   * 設定を更新\n   */\n  updateConfig(newConfig: Partial<UndoRedoConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n    \n    // 新しい設定でコマンド履歴を再初期化\n    const currentState = this.commandHistory.getHistoryDetails()\n    this.commandHistory = new CommandHistory(this.config)\n    \n    console.log('🔧 Undo/Redo設定を更新しました')\n  }\n  \n  /**\n   * デバッグ情報を取得\n   */\n  getDebugInfo(): {\n    config: UndoRedoConfig\n    historySize: number\n    snapshotCount: number\n    currentTurn: number | null\n    memoryUsage: number\n  } {\n    const historyDetails = this.commandHistory.getHistoryDetails()\n    \n    return {\n      config: this.config,\n      historySize: historyDetails.length,\n      snapshotCount: this.snapshots.size,\n      currentTurn: this.currentGame?.turn || null,\n      memoryUsage: this.estimateMemoryUsage()\n    }\n  }\n  \n  /**\n   * クリーンアップ\n   */\n  destroy(): void {\n    this.clearHistory()\n    this.eventListeners = []\n    this.currentGame = null\n    \n    // キーボードイベントリスナーを削除\n    if (this.config.enableKeyboardShortcuts) {\n      this.removeKeyboardShortcuts()\n    }\n  }\n  \n  // === プライベートメソッド ===\n  \n  /**\n   * コマンドを実行\n   */\n  private async executeCommand(command: GameCommand): Promise<UndoRedoResult> {\n    const result = await this.commandHistory.executeCommand(command, this.currentGame!)\n    \n    if (result.success) {\n      this.emitEvent('command_executed', result)\n    }\n    \n    return result\n  }\n  \n  /**\n   * スナップショットから復元\n   */\n  private async restoreFromSnapshot(turn: number, snapshot: any): Promise<UndoRedoResult> {\n    if (!this.currentGame) {\n      return this.createErrorResult('ゲームが設定されていません')\n    }\n    \n    try {\n      // TODO: スナップショットからゲーム状態を復元する処理\n      // 現在は簡易実装\n      console.log(`📼 スナップショット復元: ターン${turn}`)\n      \n      return {\n        success: true,\n        message: `ターン${turn}の状態に復元しました`,\n        affectedCommands: 1\n      }\n    } catch (error) {\n      return this.createErrorResult(`復元エラー: ${error}`)\n    }\n  }\n  \n  /**\n   * キーボードショートカットを設定\n   */\n  private setupKeyboardShortcuts(): void {\n    document.addEventListener('keydown', this.handleKeyDown.bind(this))\n  }\n  \n  /**\n   * キーボードショートカットを削除\n   */\n  private removeKeyboardShortcuts(): void {\n    document.removeEventListener('keydown', this.handleKeyDown.bind(this))\n  }\n  \n  /**\n   * キーボードイベントを処理\n   */\n  private handleKeyDown(event: KeyboardEvent): void {\n    if (!this.currentGame) return\n    \n    const isCtrlOrCmd = event.ctrlKey || event.metaKey\n    \n    if (isCtrlOrCmd) {\n      switch (event.key.toLowerCase()) {\n        case 'z':\n          if (event.shiftKey) {\n            // Ctrl+Shift+Z または Cmd+Shift+Z でRedo\n            event.preventDefault()\n            this.redo()\n          } else {\n            // Ctrl+Z または Cmd+Z でUndo\n            event.preventDefault()\n            this.undo()\n          }\n          break\n        \n        case 'y':\n          // Ctrl+Y でRedo (Windows)\n          if (!event.shiftKey) {\n            event.preventDefault()\n            this.redo()\n          }\n          break\n      }\n    }\n  }\n  \n  /**\n   * イベントを発行\n   */\n  private emitEvent(type: UndoRedoEvent['type'], result: UndoRedoResult): void {\n    const event: UndoRedoEvent = {\n      type,\n      result,\n      historyState: {\n        canUndo: this.commandHistory.canUndo(),\n        canRedo: this.commandHistory.canRedo(),\n        undoableCount: this.commandHistory.getUndoableCount(),\n        redoableCount: this.commandHistory.getRedoableCount()\n      }\n    }\n    \n    this.eventListeners.forEach(listener => {\n      try {\n        listener(event)\n      } catch (error) {\n        console.error('Undo/Redoイベントリスナーエラー:', error)\n      }\n    })\n  }\n  \n  /**\n   * エラー結果を作成\n   */\n  private createErrorResult(message: string): UndoRedoResult {\n    return {\n      success: false,\n      message,\n      affectedCommands: 0\n    }\n  }\n  \n  /**\n   * メモリ使用量を推定\n   */\n  private estimateMemoryUsage(): number {\n    // 簡易的なメモリ使用量推定\n    const historySize = this.commandHistory.getHistoryDetails().length\n    const snapshotSize = this.snapshots.size\n    \n    // 1コマンド約1KB、1スナップショット約10KBと仮定\n    return historySize * 1024 + snapshotSize * 10240\n  }\n}