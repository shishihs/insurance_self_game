{"version":3,"file":"game-logic-VqeLT8D0n26Z.js","sources":["../../src/domain/entities/Deck.ts","../../src/domain/valueObjects/CardPower.ts","../../src/domain/valueObjects/InsurancePremium.ts","../../src/common/IdGenerator.ts","../../src/domain/entities/Card.ts","../../src/domain/constants/insurance.constants.ts","../../src/domain/entities/RiskRewardChallenge.ts","../../src/domain/services/CardFactory.ts","../../src/domain/services/CardManager.ts","../../src/domain/valueObjects/RiskFactor.ts","../../src/domain/valueObjects/RiskProfile.ts","../../src/domain/services/InsurancePremiumCalculationService.ts","../../src/domain/constants/GameConstants.ts","../../src/domain/services/GameStageManager.ts","../../src/domain/services/InsuranceExpirationManager.ts","../../src/domain/types/game.types.ts","../../src/domain/services/ChallengeResolutionService.ts","../../src/domain/services/GameTurnManager.ts","../../src/domain/services/GameChallengeService.ts","../../src/domain/services/GameInsuranceService.ts","../../src/domain/services/AIStrategyService.ts","../../src/domain/services/GameStateManager.ts","../../src/domain/services/GameActionProcessor.ts","../../src/domain/valueObjects/Vitality.ts","../../src/domain/entities/Game.ts"],"sourcesContent":["import type { Card } from './Card'\nimport type { CardType } from '../types/card.types'\n\n/**\n * デッキエンティティ\n */\nexport class Deck {\n  private cards: Card[]\n  private readonly name: string\n\n  constructor(name: string, cards: Card[] = []) {\n    this.name = name\n    this.cards = [...cards]\n  }\n\n  /**\n   * デッキ名を取得\n   */\n  getName(): string {\n    return this.name\n  }\n\n  /**\n   * カード枚数を取得\n   */\n  size(): number {\n    return this.cards.length\n  }\n\n  /**\n   * デッキが空かどうか\n   */\n  isEmpty(): boolean {\n    return this.cards.length === 0\n  }\n\n  /**\n   * カードを追加\n   */\n  addCard(card: Card): void {\n    this.cards.push(card)\n  }\n\n  /**\n   * 複数のカードを追加\n   */\n  addCards(cards: Card[]): void {\n    this.cards.push(...cards)\n  }\n\n  /**\n   * カードを上から引く\n   */\n  drawCard(): Card | null {\n    return this.cards.pop() || null\n  }\n\n  /**\n   * 複数枚のカードを引く\n   */\n  drawCards(count: number): Card[] {\n    const drawn: Card[] = []\n    for (let i = 0; i < count && !this.isEmpty(); i++) {\n      const card = this.drawCard()\n      if (card) drawn.push(card)\n    }\n    return drawn\n  }\n\n  /**\n   * 特定のカードを削除\n   */\n  removeCard(cardId: string): boolean {\n    const index = this.cards.findIndex(card => card.id === cardId)\n    if (index !== -1) {\n      this.cards.splice(index, 1)\n      return true\n    }\n    return false\n  }\n\n  /**\n   * デッキをシャッフル（Fisher-Yatesアルゴリズム）\n   */\n  shuffle(): void {\n    for (let i = this.cards.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]\n    }\n  }\n\n  /**\n   * デッキの中身を確認（コピーを返す）\n   */\n  getCards(): Card[] {\n    return [...this.cards]\n  }\n\n  /**\n   * 特定のタイプのカード枚数を取得\n   */\n  countCardsByType(type: CardType): number {\n    return this.cards.filter(card => card.type === type).length\n  }\n\n  /**\n   * デッキをクリア\n   */\n  clear(): void {\n    this.cards = []\n  }\n\n  /**\n   * デッキのコピーを作成\n   */\n  clone(): Deck {\n    return new Deck(\n      this.name,\n      this.cards.map(card => card.clone())\n    )\n  }\n\n  /**\n   * デッキの統計情報を取得\n   */\n  getStats(): {\n    total: number\n    byType: Record<CardType, number>\n    averagePower: number\n    averageCost: number\n  } {\n    const stats = {\n      total: this.cards.length,\n      byType: {\n        life: 0,\n        insurance: 0,\n        pitfall: 0\n      } as Record<CardType, number>,\n      averagePower: 0,\n      averageCost: 0\n    }\n\n    let totalPower = 0\n    let totalCost = 0\n\n    this.cards.forEach(card => {\n      stats.byType[card.type]++\n      totalPower += card.power\n      totalCost += card.cost\n    })\n\n    stats.averagePower = stats.total > 0 ? totalPower / stats.total : 0\n    stats.averageCost = stats.total > 0 ? totalCost / stats.total : 0\n\n    return stats\n  }\n}","/**\n * カードのパワーを表す値オブジェクト\n * \n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\n * ビジネスルール：\n * - パワーは-99以上、999以下でなければならない（ネガティブな人生イベント対応）\n * - 演算結果が範囲を超える場合は範囲内に制限される\n */\nexport class CardPower {\n  private static readonly MIN_POWER = -99\n  private static readonly MAX_POWER = 999\n\n  private constructor(private readonly value: number) {\n    this.validate()\n  }\n\n  /**\n   * CardPower インスタンスを生成する\n   * @param value パワー値\n   * @throws {Error} 不正な値の場合\n   */\n  static create(value: number): CardPower {\n    return new CardPower(value)\n  }\n\n  /**\n   * 値の妥当性を検証する\n   * @private\n   */\n  private validate(): void {\n    if (this.value < CardPower.MIN_POWER) {\n      throw new Error(`CardPower must be at least ${CardPower.MIN_POWER}`)\n    }\n    if (this.value > CardPower.MAX_POWER) {\n      throw new Error('Card power cannot exceed maximum')\n    }\n  }\n\n  /**\n   * パワー値を取得\n   */\n  getValue(): number {\n    return this.value\n  }\n\n  /**\n   * 他のCardPowerと加算\n   * @param other 加算するCardPower\n   * @returns 新しいCardPowerインスタンス\n   */\n  add(other: CardPower): CardPower {\n    const sum = this.value + other.value\n    return new CardPower(Math.max(CardPower.MIN_POWER, Math.min(sum, CardPower.MAX_POWER)))\n  }\n\n  /**\n   * 複数のCardPowerを合計\n   * @param powers CardPowerの配列\n   * @returns 合計のCardPower\n   */\n  static sum(powers: CardPower[]): CardPower {\n    const total = powers.reduce((sum, power) => sum + power.value, 0)\n    return new CardPower(Math.max(CardPower.MIN_POWER, Math.min(total, CardPower.MAX_POWER)))\n  }\n\n  /**\n   * 倍率を適用\n   * @param multiplier 倍率（0以上）\n   * @returns 新しいCardPowerインスタンス\n   * @throws {Error} 倍率が負の場合\n   */\n  multiply(multiplier: number): CardPower {\n    if (multiplier < 0) {\n      throw new Error('Multiplier cannot be negative')\n    }\n    const result = Math.floor(this.value * multiplier)\n    return new CardPower(Math.max(CardPower.MIN_POWER, Math.min(result, CardPower.MAX_POWER)))\n  }\n\n  /**\n   * 他のCardPowerより大きいか判定\n   */\n  isGreaterThan(other: CardPower): boolean {\n    return this.value > other.value\n  }\n\n  /**\n   * 他のCardPower以上か判定\n   */\n  isGreaterThanOrEqual(other: CardPower): boolean {\n    return this.value >= other.value\n  }\n\n  /**\n   * 他のCardPowerと等価か判定\n   */\n  equals(other: CardPower): boolean {\n    return this.value === other.value\n  }\n\n  /**\n   * 文字列表現を取得\n   */\n  toString(): string {\n    return `Power: ${this.value}`\n  }\n\n  /**\n   * ゼロパワーの定数\n   */\n  static get ZERO(): CardPower {\n    return new CardPower(0)\n  }\n\n  /**\n   * 最大パワーの定数\n   */\n  static get MAX(): CardPower {\n    return new CardPower(CardPower.MAX_POWER)\n  }\n}","/**\n * 保険料を表す値オブジェクト\n * \n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\n * ビジネスルール：\n * - 保険料は0以上、99以下でなければならない\n * - 0は無料保険を表す\n * - 20以上は高額保険料とみなされる\n */\nexport class InsurancePremium {\n  private static readonly MIN_PREMIUM = 0\n  private static readonly MAX_PREMIUM = 99\n  private static readonly EXPENSIVE_THRESHOLD = 20\n\n  private constructor(private readonly value: number) {\n    this.validate()\n  }\n\n  /**\n   * InsurancePremium インスタンスを生成する\n   * @param value 保険料値\n   * @throws {Error} 不正な値の場合\n   */\n  static create(value: number): InsurancePremium {\n    return new InsurancePremium(Math.floor(value))\n  }\n\n  /**\n   * 値の妥当性を検証する\n   * @private\n   */\n  private validate(): void {\n    if (this.value < InsurancePremium.MIN_PREMIUM) {\n      throw new Error('InsurancePremium must be non-negative')\n    }\n    if (this.value > InsurancePremium.MAX_PREMIUM) {\n      throw new Error('InsurancePremium cannot exceed maximum')\n    }\n  }\n\n  /**\n   * 保険料値を取得\n   */\n  getValue(): number {\n    return this.value\n  }\n\n  /**\n   * 複数の保険料を合計\n   * @param premiums InsurancePremiumの配列\n   * @returns 合計の保険料\n   */\n  static sum(premiums: InsurancePremium[]): InsurancePremium {\n    const total = premiums.reduce((sum, premium) => sum + premium.value, 0)\n    return new InsurancePremium(Math.min(total, InsurancePremium.MAX_PREMIUM))\n  }\n\n  /**\n   * 割引率を適用\n   * @param discountRate 割引率（0.0〜1.0）\n   * @returns 新しいInsurancePremiumインスタンス\n   * @throws {Error} 割引率が不正な場合\n   */\n  applyDiscount(discountRate: number): InsurancePremium {\n    if (discountRate < 0) {\n      throw new Error('Discount rate cannot be negative')\n    }\n    if (discountRate > 1) {\n      throw new Error('Discount rate cannot exceed 100%')\n    }\n    \n    const discountedValue = Math.floor(this.value * (1 - discountRate))\n    return new InsurancePremium(discountedValue)\n  }\n\n  /**\n   * 倍率を適用\n   * @param multiplier 倍率（0以上）\n   * @returns 新しいInsurancePremiumインスタンス\n   * @throws {Error} 倍率が負の場合\n   */\n  applyMultiplier(multiplier: number): InsurancePremium {\n    if (multiplier < 0) {\n      throw new Error('Multiplier cannot be negative')\n    }\n    \n    const multipliedValue = Math.floor(this.value * multiplier)\n    return new InsurancePremium(Math.min(multipliedValue, InsurancePremium.MAX_PREMIUM))\n  }\n\n  /**\n   * 無料保険かどうか判定\n   */\n  isFree(): boolean {\n    return this.value === 0\n  }\n\n  /**\n   * 高額保険料かどうか判定\n   */\n  isExpensive(): boolean {\n    return this.value >= InsurancePremium.EXPENSIVE_THRESHOLD\n  }\n\n  /**\n   * 他の保険料より高いか判定\n   */\n  isHigherThan(other: InsurancePremium): boolean {\n    return this.value > other.value\n  }\n\n  /**\n   * 指定された活力で負担可能か判定\n   * @param availableVitality 利用可能な活力\n   */\n  isAffordableWith(availableVitality: number): boolean {\n    return availableVitality >= this.value\n  }\n\n  /**\n   * 他のInsurancePremiumと等価か判定\n   */\n  equals(other: InsurancePremium): boolean {\n    return this.value === other.value\n  }\n\n  /**\n   * 文字列表現を取得\n   */\n  toString(): string {\n    if (this.isFree()) {\n      return '保険料: 無料'\n    }\n    return `保険料: ${this.value}`\n  }\n\n  /**\n   * 無料保険の定数\n   */\n  static get FREE(): InsurancePremium {\n    return new InsurancePremium(0)\n  }\n}","/**\n * 統一されたID生成ユーティリティ\n * \n * システム全体で一貫したID生成ロジックを提供し、\n * 重複コードを排除します。\n */\nexport class IdGenerator {\n  private static counter = 0\n  \n  /**\n   * 汎用的なユニークIDを生成\n   * @param prefix プレフィックス（例: 'card', 'game', 'cmd'）\n   * @returns ユニークなID文字列\n   */\n  static generate(prefix: string = 'id'): string {\n    return `${prefix}_${Date.now()}_${this.getRandomString()}`\n  }\n\n  /**\n   * カード用IDを生成\n   */\n  static generateCardId(): string {\n    return this.generate('card')\n  }\n\n  /**\n   * ゲーム用IDを生成\n   */\n  static generateGameId(): string {\n    return this.generate('game')\n  }\n\n  /**\n   * コマンド用IDを生成\n   */\n  static generateCommandId(): string {\n    return this.generate('cmd')\n  }\n\n  /**\n   * 通知用IDを生成\n   */\n  static generateNotificationId(): string {\n    return this.generate('notification')\n  }\n\n  /**\n   * フィードバック用IDを生成\n   */\n  static generateFeedbackId(): string {\n    return this.generate('feedback')\n  }\n\n  /**\n   * 連番付きIDを生成（テスト時の予測可能性のため）\n   */\n  static generateSequential(prefix: string = 'seq'): string {\n    return `${prefix}_${++this.counter}`\n  }\n\n  /**\n   * UUIDライクなIDを生成（より強固な一意性が必要な場合）\n   */\n  static generateUUID(prefix?: string): string {\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n      const r = Math.random() * 16 | 0\n      const v = c === 'x' ? r : (r & 0x3 | 0x8)\n      return v.toString(16)\n    })\n    return prefix ? `${prefix}_${uuid}` : uuid\n  }\n\n  /**\n   * ランダム文字列を生成（内部用）\n   */\n  private static getRandomString(length: number = 9): string {\n    return Math.random().toString(36).substr(2, length)\n  }\n\n  /**\n   * カウンターをリセット（テスト用）\n   */\n  static resetCounter(): void {\n    this.counter = 0\n  }\n\n  /**\n   * 現在のカウンター値を取得（テスト用）\n   */\n  static getCurrentCounter(): number {\n    return this.counter\n  }\n}\n\n/**\n * IDの妥当性をチェックするユーティリティ\n */\nexport class IdValidator {\n  /**\n   * IDが有効な形式かチェック\n   */\n  static isValid(id: string): boolean {\n    if (!id || typeof id !== 'string') return false\n    \n    // 基本的なパターンチェック: prefix_timestamp_randomstring\n    const basicPattern = /^[a-zA-Z_]+_\\d+_[a-zA-Z0-9]+$/\n    if (basicPattern.test(id)) return true\n    \n    // UUIDパターンチェック\n    const uuidPattern = /^[a-zA-Z_]*_?[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\n    return uuidPattern.test(id)\n  }\n\n  /**\n   * IDからプレフィックスを抽出\n   */\n  static extractPrefix(id: string): string | null {\n    if (!this.isValid(id)) return null\n    \n    const parts = id.split('_')\n    return parts.length > 0 ? parts[0] : null\n  }\n\n  /**\n   * IDがSpecificなプレフィックスを持っているかチェック\n   */\n  static hasPrefix(id: string, expectedPrefix: string): boolean {\n    const prefix = this.extractPrefix(id)\n    return prefix === expectedPrefix\n  }\n}","import type {\n  CardEffect,\n  CardEffectType,\n  CardType,\n  ComboCardProperties,\n  DreamCategory,\n  EventCardProperties,\n  IAdvancedCard,\n  ICard,\n  InsuranceDurationType,\n  InsuranceEffectType,\n  InsuranceType,\n  LifeCardCategory,\n  RewardType,\n  SkillCardProperties,\n  SkillRarity,\n  InsuranceTriggerType // 追加\n} from '../types/card.types'\nimport { CardPower } from '../valueObjects/CardPower'\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\nimport { IdGenerator } from '../../common/IdGenerator'\nimport { MAX_DAMAGE_REDUCTION_PER_INSURANCE, INSURANCE_EFFECTIVENESS_RATE } from '../constants/insurance.constants'\n\n/**\n * カードエンティティ - ゲーム内のすべてのカードの基底クラス\n * \n * このクラスは値オブジェクトを使用してビジネスルールを表現します：\n * - power: CardPower値オブジェクト（カードの効果値）\n * - cost: InsurancePremium値オブジェクト（保険カードの場合）\n * \n * @implements {IAdvancedCard} 拡張カードインターフェース\n * \n * @example\n * // 人生カードの作成\n * const lifeCard = Card.createLifeCard('アルバイト収入', 1);\n * \n * // 保険カードの作成\n * const insuranceCard = Card.createInsuranceCard('健康保険', 2);\n * \n * // スキルカードの作成\n * const skillCard = Card.createSkillCard('プロフェッショナル', 'rare', 3);\n */\nexport class Card implements IAdvancedCard {\n  readonly id: string\n  readonly name: string\n  readonly description: string\n  readonly type: CardType\n  private readonly _power: CardPower\n  private readonly _cost: InsurancePremium\n  readonly effects: CardEffect[]\n  readonly imageUrl?: string\n  readonly category?: LifeCardCategory\n  readonly insuranceType?: InsuranceType\n  readonly coverage?: number\n  readonly penalty?: number\n  // 保険カード用プロパティ\n  readonly ageBonus?: number\n  readonly durationType?: InsuranceDurationType\n  remainingTurns?: number // 可変プロパティ（ターンごとに減少）\n  readonly insuranceEffectType?: InsuranceEffectType\n  readonly insuranceTriggerType?: InsuranceTriggerType // トリガー型保険の発動条件\n  // Phase 4 夢カード用プロパティ\n  readonly dreamCategory?: DreamCategory\n\n  // 拡張カード用プロパティ\n  readonly skillProperties?: SkillCardProperties\n  readonly comboProperties?: ComboCardProperties\n  readonly eventProperties?: EventCardProperties\n  readonly isUnlockable?: boolean\n  readonly unlockCondition?: string\n  readonly rewardType?: RewardType\n\n  /**\n   * Cardインスタンスを作成\n   * @param {IAdvancedCard} params - カードのパラメータ\n   */\n  constructor(params: IAdvancedCard) {\n    this.id = params.id\n    this.name = params.name\n    this.description = params.description\n    this.type = params.type\n\n    // 値オブジェクトでラップ\n    this._power = CardPower.create(params.power)\n    this._cost = InsurancePremium.create(params.cost)\n\n    this.effects = params.effects\n    this.imageUrl = params.imageUrl\n    this.category = params.category\n    this.insuranceType = params.insuranceType\n    this.coverage = params.coverage\n    this.penalty = params.penalty\n\n    // 年齢ボーナスのプロパティ\n    if ('ageBonus' in params) {\n      this.ageBonus = params.ageBonus\n    }\n\n    // 保険期間のプロパティ\n    if ('durationType' in params) {\n      this.durationType = params.durationType\n    }\n    if ('remainingTurns' in params) {\n      this.remainingTurns = params.remainingTurns\n    }\n    if ('insuranceEffectType' in params) {\n      this.insuranceEffectType = params.insuranceEffectType\n    }\n    if ('insuranceTriggerType' in params) {\n      this.insuranceTriggerType = params.insuranceTriggerType\n    }\n\n    // Phase 4 夢カードのプロパティ\n    if ('dreamCategory' in params) {\n      this.dreamCategory = params.dreamCategory\n    }\n\n    // 拡張カード用プロパティ\n    if ('skillProperties' in params) {\n      this.skillProperties = params.skillProperties\n    }\n    if ('comboProperties' in params) {\n      this.comboProperties = params.comboProperties\n    }\n    if ('eventProperties' in params) {\n      this.eventProperties = params.eventProperties\n    }\n    if ('isUnlockable' in params) {\n      this.isUnlockable = params.isUnlockable\n    }\n    if ('unlockCondition' in params) {\n      this.unlockCondition = params.unlockCondition\n    }\n    if ('rewardType' in params) {\n      this.rewardType = params.rewardType\n    }\n  }\n\n  /**\n   * 後方互換性のためのgetter - カードのパワー値を取得\n   * @returns {number} カードのパワー値\n   */\n  get power(): number {\n    return this._power.getValue()\n  }\n\n  /**\n   * カードのコストを取得\n   * @returns {number} カードのコスト\n   */\n  get cost(): number {\n    return this._cost.getValue()\n  }\n\n  /**\n   * 値オブジェクトとしてのpower取得\n   * @returns {CardPower} カードパワー値オブジェクト\n   */\n  getPower(): CardPower {\n    return this._power\n  }\n\n  /**\n   * 値オブジェクトとしてのcost取得\n   * @returns {InsurancePremium} 保険料値オブジェクト\n   */\n  getCost(): InsurancePremium {\n    return this._cost\n  }\n\n  /**\n   * カードが特定の効果を持っているか判定\n   * @param {CardEffectType} effectType - 確認する効果タイプ\n   * @returns {boolean} 効果を持っている場合true\n   */\n  hasEffect(effectType: CardEffectType): boolean {\n    return this.effects.some(effect => effect.type === effectType)\n  }\n\n  /**\n   * 特定の効果を取得\n   * @param {CardEffectType} effectType - 取得する効果タイプ\n   * @returns {CardEffect | undefined} 効果オブジェクトまたはundefined\n   */\n  getEffect(effectType: CardEffectType): CardEffect | undefined {\n    return this.effects.find(effect => effect.type === effectType)\n  }\n\n  /**\n   * 保険カードかどうか判定\n   * @returns {boolean} 保険カードの場合true\n   */\n  isInsurance(): boolean {\n    return this.type === 'insurance'\n  }\n\n  /**\n   * 定期保険かどうか判定\n   * @returns {boolean} 定期保険の場合true\n   */\n  isTermInsurance(): boolean {\n    return this.isInsurance() && this.durationType === 'term'\n  }\n\n  /**\n   * 終身保険かどうか判定\n   * @returns {boolean} 終身保険の場合true\n   */\n  isWholeLifeInsurance(): boolean {\n    return this.isInsurance() && this.durationType === 'whole_life'\n  }\n\n  /**\n   * 保険効果タイプを取得\n   * @returns {InsuranceEffectType | undefined} 保険効果タイプ\n   */\n  getInsuranceEffectType(): InsuranceEffectType | undefined {\n    if (!this.isInsurance()) return undefined\n    return this.insuranceEffectType || 'offensive' // デフォルトは攻撃型\n  }\n\n  /**\n   * 防御型保険かどうか判定\n   * @returns {boolean} 防御型保険の場合true\n   */\n  isDefensiveInsurance(): boolean {\n    return this.isInsurance() && this.getInsuranceEffectType() === 'defensive'\n  }\n\n  /**\n   * 回復型保険かどうか判定\n   * @returns {boolean} 回復型保険の場合true\n   */\n  isRecoveryInsurance(): boolean {\n    return this.isInsurance() && this.getInsuranceEffectType() === 'recovery'\n  }\n\n  /**\n   * 特化型保険かどうか判定\n   * @returns {boolean} 特化型保険の場合true\n   */\n  isSpecializedInsurance(): boolean {\n    return this.isInsurance() && this.getInsuranceEffectType() === 'specialized'\n  }\n\n  /**\n   * ダメージ軽減量を計算（防御型保険用）\n   * Issue #24: 保険効果の上限を設定して過度な軽減を防ぐ\n   * @returns {number} ダメージ軽減量\n   */\n  calculateDamageReduction(): number {\n    // 保険カードでない場合は0\n    if (!this.isInsurance()) return 0\n\n    // ダメージ軽減効果を持つかチェック\n    const hasDefensiveEffect = this.isDefensiveInsurance() || this.hasEffect('damage_reduction')\n    if (!hasDefensiveEffect) return 0\n\n    let totalReduction = 0\n\n    // 防御型保険の場合、カバレッジベースの軽減\n    if (this.isDefensiveInsurance()) {\n      totalReduction += (this.coverage || 0) * INSURANCE_EFFECTIVENESS_RATE\n    }\n\n    // damage_reduction効果がある場合はその値を加算（効果率適用）\n    const reductionEffect = this.getEffect('damage_reduction')\n    if (reductionEffect) {\n      totalReduction += reductionEffect.value * INSURANCE_EFFECTIVENESS_RATE\n    }\n\n    // 1枚の保険カードあたりの上限を適用\n    return Math.min(totalReduction, MAX_DAMAGE_REDUCTION_PER_INSURANCE)\n  }\n\n  /**\n   * ターン回復量を計算（回復型保険用）\n   * @returns {number} ターン回復量\n   */\n  calculateTurnHeal(): number {\n    if (!this.isRecoveryInsurance()) return 0\n\n    // カバレッジに基づいて回復量を計算\n    const baseHeal = Math.floor((this.coverage || 0) / 20)\n\n    // ターン回復効果がある場合はその値を加算\n    const healEffect = this.getEffect('turn_heal')\n    const effectHeal = healEffect ? healEffect.value : 0\n\n    return baseHeal + effectHeal\n  }\n\n  /**\n   * 特定チャレンジへのボーナスを計算（特化型保険用）\n   * @param {string} challengeType チャレンジタイプ\n   * @returns {number} ボーナスパワー\n   */\n  calculateChallengeBonus(challengeType: string): number {\n    if (!this.isSpecializedInsurance()) return 0\n\n    // 特定チャレンジボーナス効果を確認\n    const bonusEffect = this.getEffect('challenge_bonus')\n    if (!bonusEffect?.condition) return 0\n\n    // 条件が一致する場合のみボーナスを返す\n    if (bonusEffect.condition.includes(challengeType)) {\n      return bonusEffect.value\n    }\n\n    return 0\n  }\n\n  /**\n   * Phase 4: 夢カードかどうか判定\n   * @returns {boolean} 夢カードの場合true\n   */\n  isDreamCard(): boolean {\n    return this.type === 'dream'\n  }\n\n  /**\n   * カードのコピーを作成（一部のプロパティを更新可能）\n   * @param {Partial<IAdvancedCard>} [updates] - 更新するプロパティ\n   * @returns {Card} 新しいCardインスタンス\n   */\n  copy(updates?: Partial<IAdvancedCard>): Card {\n    return new Card({\n      ...this,\n      power: this.power, // getter経由で取得\n      cost: this.cost,   // getter経由で取得\n      effects: [...this.effects], // 配列の深いコピー\n      ...updates\n    })\n  }\n\n  /**\n   * カードのクローンを作成（後方互換性のため）\n   * @returns {Card} カードの完全なコピー\n   * @deprecated copy()メソッドの使用を推奨\n   */\n  clone(): Card {\n    return this.copy()\n  }\n\n  /**\n   * 残りターン数を減少させる（定期保険用）\n   * @returns {Card} ターン数を減らした新しいCardインスタンス\n   */\n  decrementRemainingTurns(): Card {\n    if (!this.isTermInsurance() || !this.remainingTurns) {\n      return this\n    }\n\n    return this.copy({\n      remainingTurns: Math.max(0, this.remainingTurns - 1)\n    })\n  }\n\n  /**\n   * 保険が有効期限切れかどうか判定\n   * @returns {boolean} 期限切れの場合true\n   */\n  isExpired(): boolean {\n    if (!this.isTermInsurance()) {\n      return false\n    }\n    return this.remainingTurns === 0\n  }\n\n  /**\n   * パワーが指定値以上か判定（値オブジェクトを使用）\n   * @param {number} threshold - 闾値\n   * @returns {boolean} パワーが闾値以上の場合true\n   */\n  hasPowerAtLeast(requiredPower: number): boolean {\n    const required = CardPower.create(requiredPower)\n    return this._power.isGreaterThanOrEqual(required)\n  }\n\n  /**\n   * コストが支払い可能か判定（値オブジェクトを使用）\n   */\n  isAffordableWith(availableVitality: number): boolean {\n    return this._cost.isAffordableWith(availableVitality)\n  }\n\n  /**\n   * 効果的なパワーを計算（年齢ボーナス等を含む）\n   * @param {number} [bonus] - 追加ボーナス（オプション）\n   */\n  calculateEffectivePower(bonus?: number): number {\n    let effectivePower = this.power\n\n    // 保険カードの年齢ボーナスを適用\n    if (this.isInsurance() && this.ageBonus) {\n      effectivePower += this.ageBonus\n    }\n\n    // 引数で渡されたボーナスを加算\n    if (bonus !== undefined) {\n      effectivePower += bonus\n    }\n\n    // 攻撃型保険以外はパワーを提供しない\n    if (this.isInsurance() && this.getInsuranceEffectType() !== 'offensive') {\n      return 0\n    }\n\n    return Math.max(0, effectivePower)\n  }\n\n  /**\n   * ライフカードかどうか判定\n   */\n  isLifeCard(): boolean {\n    return this.type === 'life'\n  }\n\n  /**\n   * 保険カードかどうか判定（エイリアス）\n   */\n  isInsuranceCard(): boolean {\n    return this.isInsurance()\n  }\n\n  /**\n   * 落とし穴カードかどうか判定\n   */\n  isPitfallCard(): boolean {\n    return this.type === 'pitfall'\n  }\n\n  /**\n   * スキルカードかどうか判定\n   */\n  isSkillCard(): boolean {\n    return this.type === 'skill'\n  }\n\n  /**\n   * コンボカードかどうか判定\n   */\n  isComboCard(): boolean {\n    return this.type === 'combo'\n  }\n\n  /**\n   * イベントカードかどうか判定\n   */\n  isEventCard(): boolean {\n    return this.type === 'event'\n  }\n\n  /**\n   * レジェンダリーカードかどうか判定\n   */\n  isLegendaryCard(): boolean {\n    return this.type === 'legendary'\n  }\n\n  /**\n   * チャレンジカードかどうか判定\n   */\n  isChallengeCard(): boolean {\n    return this.type === 'challenge'\n  }\n\n  /**\n   * カードの表示用文字列を生成\n   */\n  toDisplayString(): string {\n    let display = `${this.name} - Power: ${this.power}, Cost: ${this.cost}`\n\n    if (this.effects.length > 0) {\n      const effectDescriptions = this.effects.map(effect => effect.description).join(', ')\n      display += ` - Effects: ${effectDescriptions}`\n    }\n\n    return display\n  }\n\n  /**\n   * ターン数を減少させる（mutableな操作）\n   */\n  decrementTurn(): void {\n    if (this.remainingTurns !== undefined && this.remainingTurns > 0) {\n      this.remainingTurns--\n    }\n  }\n\n  // === 静的ファクトリーメソッド（TDD: Green Phase） ===\n\n  /**\n   * ライフカードを作成\n   */\n  static createLifeCard(name: string, power: number): Card {\n    const powerSign = power > 0 ? '+' : ''\n    return new Card({\n      id: IdGenerator.generate('life'),\n      name,\n      description: `パワー: ${powerSign}${power}`,\n      type: 'life',\n      power,\n      cost: 0,\n      effects: []\n    })\n  }\n\n  /**\n   * チャレンジカードを作成\n   */\n  static createChallengeCard(name: string, power: number): Card {\n    const card = new Card({\n      id: IdGenerator.generate('challenge'),\n      name,\n      description: `必要パワー: ${power}`,\n      type: 'challenge',\n      power,\n      cost: 0,\n      effects: []\n    })\n\n    return card\n  }\n\n  /**\n   * 保険カードを作成\n   */\n  static createInsuranceCard(name: string, power: number, cost: number = 1, ...effects: CardEffect[]): Card {\n    return new Card({\n      id: IdGenerator.generate('insurance'),\n      name,\n      description: `保険カード - パワー: +${power}`,\n      type: 'insurance',\n      power,\n      cost,\n      effects\n    })\n  }\n\n  /**\n   * スキルカードを作成\n   */\n  static createSkillCard(name: string, rarity: SkillRarity, power: number, cooldown?: number): Card {\n    const rarityDescriptions = {\n      common: 'コモン',\n      rare: 'レア',\n      epic: 'エピック',\n      legendary: 'レジェンダリー'\n    }\n\n    return new Card({\n      id: IdGenerator.generate('skill'),\n      name,\n      description: `${rarityDescriptions[rarity]}スキル - パワー: +${power}`,\n      type: 'skill',\n      power,\n      cost: 0,\n      effects: [],\n      skillProperties: {\n        rarity,\n        cooldown,\n        remainingCooldown: 0,\n        masteryLevel: 1\n      }\n    })\n  }\n\n  /**\n   * コンボカードを作成\n   */\n  static createComboCard(name: string, power: number, requiredCards: string[], comboBonus: number): Card {\n    return new Card({\n      id: IdGenerator.generate('combo'),\n      name,\n      description: `コンボカード - パワー: +${power} (コンボ時: +${comboBonus})`,\n      type: 'combo',\n      power,\n      cost: 0,\n      effects: [],\n      comboProperties: {\n        requiredCards,\n        comboBonus\n      }\n    })\n  }\n\n  /**\n   * イベントカードを作成\n   */\n  static createEventCard(name: string, power: number, duration: number, globalEffect = false): Card {\n    return new Card({\n      id: IdGenerator.generate('event'),\n      name,\n      description: `イベントカード - ${duration}ターン継続`,\n      type: 'event',\n      power,\n      cost: 0,\n      effects: [],\n      eventProperties: {\n        duration,\n        globalEffect\n      }\n    })\n  }\n\n  /**\n   * レジェンダリーカードを作成\n   */\n  static createLegendaryCard(name: string, power: number, unlockCondition: string): Card {\n    return new Card({\n      id: IdGenerator.generate('legendary'),\n      name,\n      description: `レジェンダリーカード - パワー: +${power}`,\n      type: 'legendary',\n      power,\n      cost: 0,\n      effects: [],\n      isUnlockable: true,\n      unlockCondition\n    })\n  }\n}","/**\n * 保険システムのバランス調整用定数\n * Issue #24: 保険効果の過度な強力さを緩和するための設定\n */\n\n/**\n * 保険によるダメージ軽減の上限値\n * 1枚の保険カードで軽減できる最大ダメージ量\n */\nexport const MAX_DAMAGE_REDUCTION_PER_INSURANCE = 50\n\n/**\n * 保険によるダメージ軽減の合計上限値\n * 複数の保険を持っていても、これ以上はダメージを軽減できない\n */\nexport const MAX_TOTAL_DAMAGE_REDUCTION = 100\n\n/**\n * 保険効果の段階的な適用レート\n * カバレッジ値に対する実際の軽減率\n */\nexport const INSURANCE_EFFECTIVENESS_RATE = 0.5 // 50%の効果\n\n/**\n * 保険の最小ダメージ保証\n * どんなに保険があっても、最低限このダメージは受ける\n */\nexport const MINIMUM_DAMAGE_AFTER_INSURANCE = 1","import { Card } from './Card'\nimport type { CardEffect, DreamCategory } from '../types/card.types'\nimport { IdGenerator } from '../../common/IdGenerator'\n\n/**\n * リスク・リワードチャレンジカード\n * \n * 高リスク・高リワードの意思決定を促すチャレンジカード。\n * 失敗時のペナルティが大きいが、成功時の報酬も大きい。\n */\nexport class RiskRewardChallenge extends Card {\n  readonly riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n  readonly successBonus: number\n  readonly failurePenalty: number\n  readonly insuranceImmunity: boolean // 保険が効かないかどうか\n\n  constructor(params: {\n    name: string\n    description: string\n    power: number\n    riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n    successBonus: number\n    failurePenalty: number\n    insuranceImmunity?: boolean\n    dreamCategory?: DreamCategory\n  }) {\n    const effects: CardEffect[] = []\n    \n    // リスクレベルに応じた特殊効果\n    if (params.riskLevel === 'extreme') {\n      effects.push({\n        type: 'special_action',\n        value: 0,\n        description: '保険効果無効化',\n        condition: 'このチャレンジでは保険カードのパワーが無効'\n      })\n    }\n\n    super({\n      id: IdGenerator.generateCardId(),\n      type: 'challenge',\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: 0,\n      effects,\n      dreamCategory: params.dreamCategory\n    })\n\n    this.riskLevel = params.riskLevel\n    this.successBonus = params.successBonus\n    this.failurePenalty = params.failurePenalty\n    this.insuranceImmunity = params.insuranceImmunity || params.riskLevel === 'extreme'\n  }\n\n  /**\n   * リスク倍率を取得\n   */\n  getRiskMultiplier(): number {\n    const multipliers = {\n      low: 1.2,\n      medium: 1.5,\n      high: 2.0,\n      extreme: 3.0\n    }\n    return multipliers[this.riskLevel]\n  }\n\n  /**\n   * 成功時の実際の報酬を計算\n   */\n  calculateActualReward(baseReward: number): number {\n    return Math.floor(baseReward * this.getRiskMultiplier()) + this.successBonus\n  }\n\n  /**\n   * 失敗時の実際のペナルティを計算\n   */\n  calculateActualPenalty(basePenalty: number): number {\n    return Math.floor(basePenalty * this.getRiskMultiplier()) + this.failurePenalty\n  }\n\n  /**\n   * リスクレベルの説明を取得\n   */\n  getRiskDescription(): string {\n    const descriptions = {\n      low: '低リスク: 少し危険だが、失敗してもダメージは軽い',\n      medium: '中リスク: 成功と失敗のバランスが取れている',\n      high: '高リスク: 失敗時のダメージが大きいが、報酬も魅力的',\n      extreme: '極限リスク: 保険も効かない危険な挑戦。成功すれば大きな報酬'\n    }\n    return descriptions[this.riskLevel]\n  }\n\n  /**\n   * チャレンジの詳細情報を取得\n   */\n  getChallengeDetails(): string {\n    const details = [\n      `必要パワー: ${this.power}`,\n      `リスクレベル: ${this.riskLevel.toUpperCase()}`,\n      `成功ボーナス: +${this.successBonus} 活力`,\n      `失敗ペナルティ: -${this.failurePenalty} 活力`,\n      this.insuranceImmunity ? '⚠️ 保険無効' : ''\n    ].filter(Boolean)\n\n    return details.join('\\n')\n  }\n\n  /**\n   * ファクトリーメソッド: リスクレベルに応じたチャレンジを作成\n   */\n  static createRiskChallenge(\n    stage: 'youth' | 'middle' | 'fulfillment',\n    riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n  ): RiskRewardChallenge {\n    const challengeTemplates = {\n      youth: {\n        low: {\n          name: '新しいスポーツへの挑戦',\n          description: '未経験の分野に挑戦する勇気',\n          power: 5,\n          successBonus: 2,\n          failurePenalty: 1\n        },\n        medium: {\n          name: '起業への第一歩',\n          description: '安定を捨てて夢を追う決断',\n          power: 7,\n          successBonus: 5,\n          failurePenalty: 3\n        },\n        high: {\n          name: '海外留学',\n          description: '未知の世界への大きな飛躍',\n          power: 9,\n          successBonus: 8,\n          failurePenalty: 5\n        },\n        extreme: {\n          name: '人生を賭けた大勝負',\n          description: '全てを投げ打って挑む最大の挑戦',\n          power: 12,\n          successBonus: 15,\n          failurePenalty: 10\n        }\n      },\n      middle: {\n        low: {\n          name: '副業の開始',\n          description: '新たな収入源への挑戦',\n          power: 6,\n          successBonus: 3,\n          failurePenalty: 2\n        },\n        medium: {\n          name: '独立開業',\n          description: '会社を辞めて独立する決断',\n          power: 9,\n          successBonus: 7,\n          failurePenalty: 5\n        },\n        high: {\n          name: '大型投資',\n          description: '将来を見据えた大胆な投資',\n          power: 11,\n          successBonus: 10,\n          failurePenalty: 7\n        },\n        extreme: {\n          name: '人生の大転換',\n          description: '全てをリセットして新しい道へ',\n          power: 15,\n          successBonus: 20,\n          failurePenalty: 15\n        }\n      },\n      fulfillment: {\n        low: {\n          name: '新しい趣味への挑戦',\n          description: '年齢に関係なく新しいことを始める',\n          power: 7,\n          successBonus: 4,\n          failurePenalty: 2\n        },\n        medium: {\n          name: 'ボランティア活動',\n          description: '社会貢献への新たな一歩',\n          power: 10,\n          successBonus: 8,\n          failurePenalty: 4\n        },\n        high: {\n          name: '遺産の活用',\n          description: '次世代への大きな投資',\n          power: 13,\n          successBonus: 12,\n          failurePenalty: 8\n        },\n        extreme: {\n          name: '人生最後の大冒険',\n          description: '残された時間での究極の挑戦',\n          power: 18,\n          successBonus: 25,\n          failurePenalty: 20\n        }\n      }\n    }\n\n    const template = challengeTemplates[stage][riskLevel]\n    \n    return new RiskRewardChallenge({\n      ...template,\n      riskLevel,\n      dreamCategory: riskLevel === 'extreme' ? 'mixed' : 'physical'\n    })\n  }\n}","import { Card } from '../entities/Card'\nimport type {\n  DreamCategory,\n  GameStage,\n  InsuranceType,\n  LifeCardCategory,\n  RewardType,\n  SkillRarity,\n  InsuranceEffectType,\n  InsuranceTriggerType\n} from '../types/card.types'\nimport type { InsuranceTypeChoice } from '../types/game.types'\nimport { IdGenerator } from '../../common/IdGenerator'\nimport { RiskRewardChallenge } from '../entities/RiskRewardChallenge'\n\n/**\n * カードファクトリー\n * ゲーム用のカードを生成する\n */\nexport class CardFactory {\n\n  /**\n   * 年齢ボーナスを計算\n   */\n  private static calculateAgeBonus(stage: GameStage): number {\n    switch (stage) {\n      case 'middle': return 0.5\n      case 'fulfillment': return 1.0\n      default: return 0\n    }\n  }\n\n  /**\n   * カード配列から実際のカードを生成\n   */\n  private static createCardsFromDefinitions<T extends { name: string }>(definitions: T[], createFn: (def: T) => Card): Card[] {\n    return definitions.map(def => createFn(def))\n  }\n\n  /**\n   * 初期デッキ用の人生カードを生成\n   */\n  static createStarterLifeCards(): Card[] {\n    const starterCardDefinitions = [\n      // 健康カード\n      { name: '朝のジョギング', description: '健康的な一日の始まり', category: 'health' as LifeCardCategory, power: 3, cost: 1 },\n      { name: '栄養バランスの良い食事', description: '体調管理の基本', category: 'health' as LifeCardCategory, power: 5, cost: 2 },\n      // キャリアカード\n      { name: '新しいスキルの習得', description: '成長への投資', category: 'career' as LifeCardCategory, power: 5, cost: 2 },\n      { name: 'チームワーク', description: '仲間との協力', category: 'career' as LifeCardCategory, power: 3, cost: 1 },\n      // 家族カード\n      { name: '家族との団らん', description: '心の充電', category: 'family' as LifeCardCategory, power: 3, cost: 1 },\n      // 趣味カード\n      { name: '趣味の時間', description: 'リフレッシュタイム', category: 'hobby' as LifeCardCategory, power: 3, cost: 1 },\n      // 金融カード\n      { name: '計画的な貯蓄', description: '将来への備え', category: 'finance' as LifeCardCategory, power: 5, cost: 2 }\n    ]\n\n    return this.createCardsFromDefinitions(starterCardDefinitions, def => this.createLifeCard(def))\n  }\n\n  /**\n   * 基本的な保険カードを生成（簡素化版：すべて終身保険、永続効果）\n   */\n  static createBasicInsuranceCards(stage: GameStage = 'youth'): Card[] {\n    const ageBonus = this.calculateAgeBonus(stage)\n\n    const basicInsuranceDefinitions = [\n      { name: '医療保険', description: '病気やケガに備える永続保障', insuranceType: 'medical' as InsuranceType, power: 4, cost: 3, coverage: 100 },\n      { name: '生命保険', description: '家族を守る永続保障', insuranceType: 'life' as InsuranceType, power: 5, cost: 4, coverage: 200 },\n      { name: '収入保障保険', description: '働けなくなった時の永続保障', insuranceType: 'income' as InsuranceType, power: 4, cost: 3, coverage: 150 }\n    ]\n\n    return this.createCardsFromDefinitions(basicInsuranceDefinitions, def =>\n      this.createInsuranceCard({ ...def, ageBonus })\n    )\n  }\n\n  /**\n   * 拡張保険カードを生成（簡素化版：すべて永続効果）\n   */\n  static createExtendedInsuranceCards(stage: GameStage = 'youth'): Card[] {\n    const extendedCards: Card[] = []\n\n    // 年齢ボーナスの設定\n    const ageBonus = this.calculateAgeBonus(stage)\n\n    // 基本保険カード\n    const baseInsurances = [\n      { name: '医療保険', insuranceType: 'medical' as InsuranceType, power: 5, cost: 4, coverage: 100 },\n      { name: '生命保険', insuranceType: 'life' as InsuranceType, power: 6, cost: 5, coverage: 200 },\n      { name: '収入保障保険', insuranceType: 'income' as InsuranceType, power: 5, cost: 4, coverage: 150 }\n    ]\n\n    // 基本保険カードを追加\n    const baseCards = this.createCardsFromDefinitions(baseInsurances, insurance =>\n      this.createInsuranceCard({\n        name: insurance.name,\n        description: `${insurance.name}の永続保障`,\n        insuranceType: insurance.insuranceType,\n        power: insurance.power,\n        cost: insurance.cost,\n        coverage: insurance.coverage,\n        ageBonus\n      })\n    )\n    extendedCards.push(...baseCards)\n\n    // 追加の特殊保険カード\n    const additionalInsurances = [\n      { name: '傷害保険', insuranceType: 'medical' as InsuranceType, power: 4, cost: 3, coverage: 80 },\n      { name: '就業不能保険', insuranceType: 'income' as InsuranceType, power: 7, cost: 6, coverage: 250 },\n      { name: '介護保険', insuranceType: 'medical' as InsuranceType, power: 6, cost: 5, coverage: 180 },\n      { name: 'がん保険', insuranceType: 'medical' as InsuranceType, power: 5, cost: 4, coverage: 120 },\n      { name: '個人年金保険', insuranceType: 'income' as InsuranceType, power: 4, cost: 4, coverage: 100 },\n      { name: '学資保険', insuranceType: 'life' as InsuranceType, power: 4, cost: 3, coverage: 90 }\n    ]\n\n    // 追加保険カードを追加\n    const additionalCards = this.createCardsFromDefinitions(additionalInsurances, insurance =>\n      this.createInsuranceCard({\n        name: insurance.name,\n        description: `${insurance.name}の永続保障`,\n        insuranceType: insurance.insuranceType,\n        power: insurance.power,\n        cost: insurance.cost,\n        coverage: insurance.coverage,\n        ageBonus\n      })\n    )\n    extendedCards.push(...additionalCards)\n\n    return extendedCards\n  }\n\n  /**\n   * 多様な効果タイプの保険カードを生成\n   */\n  static createDiverseInsuranceCards(stage: GameStage = 'youth'): Card[] {\n    const cards: Card[] = []\n    const ageBonus = this.calculateAgeBonus(stage)\n\n    // 攻撃型保険\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '攻撃特化生命保険',\n      description: 'チャレンジ時に大きなパワーを提供',\n      power: 8,\n      cost: 5,\n      insuranceType: 'life',\n      insuranceEffectType: 'offensive',\n      coverage: 150,\n      effects: [],\n      ageBonus,\n      durationType: 'whole_life'\n    }))\n\n    // 防御型保険\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '防御特化医療保険',\n      description: 'ダメージを軽減する防御的保障',\n      power: 0,\n      cost: 4,\n      insuranceType: 'medical',\n      insuranceEffectType: 'defensive',\n      coverage: 100,\n      effects: [{\n        type: 'damage_reduction',\n        value: 3,\n        description: 'ダメージを3ポイント軽減'\n      }],\n      ageBonus: 0,\n      durationType: 'whole_life'\n    }))\n\n    // 回復型保険\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '回復特化健康保険',\n      description: '毎ターン活力を回復',\n      power: 0,\n      cost: 3,\n      insuranceType: 'health',\n      insuranceEffectType: 'recovery',\n      coverage: 80,\n      effects: [{\n        type: 'turn_heal',\n        value: 2,\n        description: '毎ターン終了時に2点回復'\n      }],\n      ageBonus: 0,\n      durationType: 'whole_life'\n    }))\n\n    // 特化型保険\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '仕事特化収入保障保険',\n      description: '仕事関連のチャレンジに特化',\n      power: 3,\n      cost: 4,\n      insuranceType: 'income',\n      insuranceEffectType: 'specialized',\n      coverage: 120,\n      effects: [{\n        type: 'challenge_bonus',\n        value: 5,\n        description: '「就職」「明進」チャレンジ時+5パワー',\n        condition: '就職,明進,転職,仕事'\n      }],\n      ageBonus,\n      durationType: 'whole_life'\n    }))\n\n    // 包括型保険\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: 'オールインワン総合保険',\n      description: '複数の効果を持つ高コスト保障',\n      power: 3,\n      cost: 7,\n      insuranceType: 'life',\n      insuranceEffectType: 'comprehensive',\n      coverage: 200,\n      effects: [\n        {\n          type: 'power_boost',\n          value: 3,\n          description: 'パワー+3'\n        },\n        {\n          type: 'damage_reduction',\n          value: 2,\n          description: 'ダメージ-2'\n        },\n        {\n          type: 'turn_heal',\n          value: 1,\n          description: '毎ターン+1回復'\n        }\n      ],\n      ageBonus,\n      durationType: 'whole_life'\n    }))\n\n    return cards\n  }\n\n  /**\n   * トリガー型保険カードを生成\n   * 特定の条件で一回限り発動し、契約終了となる保険\n   */\n  static createTriggerInsuranceCards(stage: GameStage = 'youth'): Card[] {\n    const cards: Card[] = []\n    const ageBonus = this.calculateAgeBonus(stage)\n\n    // 生命保険（活力0で復活）\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '生命保険',\n      description: '活力が0になる瞬間、活力10で復活。請求後は契約終了。',\n      power: 0,\n      cost: 2,\n      insuranceType: 'life',\n      insuranceEffectType: 'trigger',\n      insuranceTriggerType: 'on_death',\n      coverage: 10, // 復活時の活力\n      effects: [],\n      ageBonus,\n      durationType: 'whole_life'\n    } as any))\n\n    // 医療保険（10ダメージ以上を1に軽減）\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '医療保険',\n      description: '10ダメージ以上受ける時、1ダメージに軽減。請求後は契約終了。',\n      power: 0,\n      cost: 3,\n      insuranceType: 'medical',\n      insuranceEffectType: 'trigger',\n      insuranceTriggerType: 'on_heavy_damage',\n      coverage: 10, // 発動閾値（10ダメージ以上）\n      effects: [],\n      ageBonus,\n      durationType: 'whole_life'\n    } as any))\n\n    // 障害保険（老化カード3枚で手札リセット）\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '障害保険',\n      description: '老化カードが3枚揃った時、手札を全て引き直し。請求後は契約終了。',\n      power: 0,\n      cost: 2,\n      insuranceType: 'disability',\n      insuranceEffectType: 'trigger',\n      insuranceTriggerType: 'on_aging_gameover',\n      coverage: 0,\n      effects: [],\n      ageBonus,\n      durationType: 'whole_life'\n    } as any))\n\n    // 就業不能保険（課題スキップ）\n    cards.push(new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: '就業不能保険',\n      description: 'いつでも発動可能。現在の課題をスキップ（ダメージなし）。請求後は契約終了。',\n      power: 0,\n      cost: 3,\n      insuranceType: 'income',\n      insuranceEffectType: 'trigger',\n      insuranceTriggerType: 'on_demand',\n      coverage: 0,\n      effects: [],\n      ageBonus,\n      durationType: 'whole_life'\n    } as any))\n\n    return cards\n  }\n\n  /**\n   * 保険種類選択肢を生成（V3: 1つの保険タイプを提示し、プランA/Bを選ばせる）\n   */\n  static createInsuranceTypeChoices(stage: GameStage = 'youth'): InsuranceTypeChoice[] {\n    const ageBonus = this.calculateAgeBonus(stage)\n\n    // 新・保険ラインナップ（全3種）\n    const insuranceDefinitions = [\n      {\n        type: 'medical' as InsuranceType,\n        name: 'じぶんへの保険',\n        description: '失敗時のリスクを軽減する医療保険',\n        power: 0,\n        // Plan A: お守り (軽減3)\n        planA: { cost: 1, duration: 10, cut: 3, desc: '定額支払プラン（失敗ダメージ-3・コスト1）' },\n        // Plan B: 鉄壁 (軽減8)\n        planB: { cost: 2, cut: 8, desc: '充実保障プラン（失敗ダメージ-8・コスト2）' },\n        effectType: 'defensive' as InsuranceEffectType,\n        triggerType: 'on_heavy_damage' as InsuranceTriggerType\n      },\n      {\n        type: 'cancer' as InsuranceType, // がん保険\n        name: 'がん保険',\n        description: '予期せぬ大病（大ダメージ）に備える',\n        power: 0,\n        // Plan A: 一時金 (1回使い切り)\n        planA: { cost: 1, duration: 5, limit: 1, desc: '診断給付金プラン（20以上の損害を1回無効化・コスト1）' },\n        // Plan B: プレミアム (何度でも)\n        planB: { cost: 3, limit: -1, desc: '通院治療プラン（20以上の損害を何度でも無効化・コスト3）' },\n        effectType: 'defensive' as InsuranceEffectType,\n        triggerType: 'on_heavy_damage' as InsuranceTriggerType // 20以上の判定は別途\n      },\n      {\n        type: 'income' as InsuranceType,\n        name: 'はたらく人への保険',\n        description: '手札事故（就業不能）時のリセット保障',\n        power: 0,\n        // Plan A: スタンダード (2ターンに1回)\n        planA: { cost: 1, duration: 10, cooldown: 2, desc: '標準月額プラン（2ターンに1回マリガン可能・コスト1）' },\n        // Plan B: ワイド (毎ターン)\n        planB: { cost: 2, cooldown: 1, desc: 'あんしん手当プラン（毎ターンマリガン可能・コスト2）' },\n        effectType: 'specialized' as InsuranceEffectType, // Special action\n        triggerType: 'on_demand' as InsuranceTriggerType\n      }\n    ]\n\n    // ランダムに1つ選択\n    const selectedDef = insuranceDefinitions[Math.floor(Math.random() * insuranceDefinitions.length)]!\n\n    const choice: InsuranceTypeChoice = {\n      insuranceType: selectedDef.type,\n      name: selectedDef.name,\n      description: selectedDef.description,\n      baseCard: {\n        name: selectedDef.name,\n        description: selectedDef.description,\n        type: 'insurance',\n        power: selectedDef.power,\n        cost: 1, // Placeholder\n        insuranceType: selectedDef.type,\n        coverage: 0, // Placeholder\n        insuranceEffectType: selectedDef.effectType,\n        insuranceTriggerType: selectedDef.triggerType,\n        effects: [],\n        ageBonus\n      },\n      // Plan A (mapped to termOption)\n      termOption: {\n        cost: selectedDef.planA.cost,\n        duration: selectedDef.planA.duration,\n        description: selectedDef.planA.desc\n      },\n      // Plan B (mapped to wholeLifeOption)\n      wholeLifeOption: {\n        cost: selectedDef.planB.cost,\n        description: selectedDef.planB.desc\n      }\n    }\n\n    // カード生成時にこれらのプラン情報を引き継ぐため、\n    // ゲーム側で選択時に metadata を付与する仕組みが必要だが、\n    // 現状は createTermInsuranceCard / createWholeLifeInsuranceCard で生成される。\n    // それらのメソッドで、Plan A/B の具体的な数値（cut, cooldown）を反映させる必要がある。\n    // いったんここではChoiceのガワを作る。\n\n    return [choice]\n  }\n\n  /**\n   * 定期保険カードを作成\n   */\n  static createTermInsuranceCard(choice: InsuranceTypeChoice): Card {\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: `定期${choice.name}`,\n      description: `${choice.baseCard.description}（${choice.termOption.duration}ターン限定）`,\n      power: choice.baseCard.power,\n      cost: choice.termOption.cost,\n      insuranceType: choice.insuranceType,\n      coverage: choice.baseCard.coverage,\n      effects: choice.baseCard.effects,\n      ageBonus: choice.baseCard.ageBonus,\n      insuranceEffectType: choice.baseCard.insuranceEffectType,\n      insuranceTriggerType: choice.baseCard.insuranceTriggerType, // トリガータイプを追加\n      durationType: 'term',\n      remainingTurns: choice.termOption.duration\n    } as any)\n  }\n\n  /**\n   * 終身保険カードを作成\n   */\n  static createWholeLifeInsuranceCard(choice: InsuranceTypeChoice): Card {\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: `終身${choice.name}`,\n      description: `${choice.baseCard.description}（永続保障）`,\n      power: choice.baseCard.power,\n      cost: choice.wholeLifeOption.cost,\n      insuranceType: choice.insuranceType,\n      coverage: choice.baseCard.coverage,\n      effects: choice.baseCard.effects,\n      ageBonus: choice.baseCard.ageBonus,\n      insuranceEffectType: choice.baseCard.insuranceEffectType,\n      insuranceTriggerType: choice.baseCard.insuranceTriggerType, // トリガータイプを追加\n      durationType: 'whole_life'\n    } as any)\n  }\n\n  /**\n   * チャレンジカードを生成\n   */\n  static createChallengeCards(stage: GameStage): Card[] {\n    const challengeDefinitionsByStage = {\n      youth: [\n        // 基本チャレンジ（難易度: 低〜中）- Hand Size 5に合わせて調整 (Power ~10-15 needed to challenge typical hand)\n        // Starter Deck Avg Power ~1.4 * 5 = 7.0 (Nerfed).\n        // Challenge Power should be 8-12.\n        // V3.2 Balance: Hardcore. Power 10-16. 2 fails = death.\n        { name: 'アルバイト探し', description: '初めての収入を得る', power: 10, damage: 10, dreamCategory: 'physical' as DreamCategory },\n        { name: '一人暮らし', description: '独立への第一歩', power: 12, damage: 12, dreamCategory: 'physical' as DreamCategory },\n        { name: '資格試験', description: 'スキルアップのチャンス', power: 14, damage: 14, dreamCategory: 'intellectual' as DreamCategory },\n        { name: '就職活動', description: '新たなキャリアの始まり', power: 16, damage: 16, dreamCategory: 'physical' as DreamCategory },\n        // 中級チャレンジ\n        { name: '恋人との別れ', description: '初めての大きな失意', power: 13, damage: 13, dreamCategory: 'mixed' as DreamCategory },\n        { name: '転職活動', description: 'キャリアの分岐点', power: 15, damage: 15, dreamCategory: 'intellectual' as DreamCategory }\n      ],\n      middle: [\n        // 基本チャレンジ（難易度: 中）\n        // V3.1 Balance: Late game too easy (100% win rate). Buffing significantly.\n        { name: '結婚資金', description: '新しい家族のスタート', power: 22, damage: 8, dreamCategory: 'mixed' as DreamCategory },\n        { name: '子育て', description: '家族の成長', power: 24, damage: 8, dreamCategory: 'physical' as DreamCategory },\n        { name: '両親の健康', description: '家族の支え合い', power: 22, damage: 7, dreamCategory: 'mixed' as DreamCategory },\n        { name: '住宅購入', description: '大きな決断', power: 28, damage: 10, dreamCategory: 'physical' as DreamCategory },\n        // 高難度チャレンジ\n        { name: '親の介護', description: '家族の責任', power: 32, damage: 12, dreamCategory: 'mixed' as DreamCategory },\n        { name: '教育資金', description: '子供の将来への投資', power: 26, damage: 9, dreamCategory: 'intellectual' as DreamCategory }\n      ],\n      fulfillment: [\n        // 充実期（難易度: 高 - 人生の集大成、より壮大な目標へ）\n        // V3.1 Balance: Advanced players must face lethal threats.\n        { name: '次世代の育成', description: '若者たちに知識と経験を伝える', power: 25, damage: 8, dreamCategory: 'intellectual' as DreamCategory },\n        { name: '地域社会の変革', description: '住みよい社会を作るための活動', power: 28, damage: 10, dreamCategory: 'mixed' as DreamCategory },\n        { name: '生涯の研究発表', description: '長年の探究の成果を世に出す', power: 30, damage: 10, dreamCategory: 'intellectual' as DreamCategory },\n        { name: '世界平和への貢献', description: '国境を越えた慈善活動', power: 35, damage: 12, dreamCategory: 'mixed' as DreamCategory },\n        // 最高難度チャレンジ\n        { name: '宇宙旅行', description: '人類の夢、星々の海へ', power: 45, damage: 15, dreamCategory: 'physical' as DreamCategory, isDream: true },\n        { name: '伝説の継承', description: '自身の生き様を伝説として残す', power: 50, damage: 20, dreamCategory: 'mixed' as DreamCategory, isDream: true }\n      ]\n    }\n\n    const definitions = challengeDefinitionsByStage[stage] || challengeDefinitionsByStage.fulfillment\n\n    // ステージごとに適切な難易度のチャレンジを選択\n    // ランダムに3-4枚選ぶが、難易度のバランスを考慮\n    const shuffled = [...definitions].sort(() => Math.random() - 0.5)\n    const selectedCount = 3 + Math.floor(Math.random() * 2) // 3-4枚\n    const selected = shuffled.slice(0, selectedCount)\n\n    const normalChallenges = this.createCardsFromDefinitions(selected, def => this.createChallengeCard({ ...def, penalty: def.damage, isDream: (def as any).isDream || false }))\n\n    // リスク・リワードチャレンジを追加（20%の確率）\n    const riskChallenges = this.createRiskRewardChallenges(stage)\n\n    // fulfillmentステージでは夢カードを大量に追加（夢達成で勝利できる）\n    const challenges = [...normalChallenges, ...riskChallenges]\n\n    // すべてのステージで夢カードが出現するチャンス（ユーザー要望）\n    // V3.2 Hardcore: Youthステージでも夢（理不尽な死）が出現する\n    const dreamCards = this.createDreamCards()\n    const dreamCount = Math.floor(Math.random() * 2) + 1 // 1-2枚\n    for (let i = 0; i < dreamCount; i++) {\n      const randomDream = dreamCards[Math.floor(Math.random() * dreamCards.length)]\n      if (randomDream) {\n        challenges.push(randomDream)\n      }\n    }\n\n    return challenges\n  }\n\n  /**\n   * 夢カード（最終目標）を生成\n   */\n  static createDreamCards(): Card[] {\n    const dreamDefinitions = [\n      // 夢カード: 超高難易度チャレンジ（失敗・回避で難易度上昇）\n      // ユーザー要望: 難易度80\n      { name: '世界一周旅行', description: '未知の世界を体験する大冒険', power: 80, damage: 40, dreamCategory: 'physical' as DreamCategory },\n      { name: '本の出版', description: '自分の知識を世に残す挑戦', power: 80, damage: 40, dreamCategory: 'intellectual' as DreamCategory },\n      { name: '幸せな家庭', description: '愛に満ちた生活を築く', power: 75, damage: 35, dreamCategory: 'mixed' as DreamCategory },\n      { name: '起業して成功', description: '自分のビジネスで成功を掴む', power: 85, damage: 50, dreamCategory: 'mixed' as DreamCategory },\n      { name: '隠居生活', description: '静かで穏やかな余生を送る', power: 70, damage: 30, dreamCategory: 'physical' as DreamCategory }\n    ]\n\n    return this.createCardsFromDefinitions(dreamDefinitions, def => this.createChallengeCard({ ...def, penalty: def.damage, isDream: true }))\n  }\n\n  /**\n   * リスク・リワードチャレンジを生成\n   */\n  static createRiskRewardChallenges(stage: GameStage): Card[] {\n    const challenges: Card[] = []\n\n    // ステージに応じたリスクレベルの分布\n    const riskDistribution = {\n      youth: { low: 0.5, medium: 0.3, high: 0.15, extreme: 0.05 },\n      middle: { low: 0.3, medium: 0.4, high: 0.2, extreme: 0.1 },\n      fulfillment: { low: 0.2, medium: 0.3, high: 0.3, extreme: 0.2 }\n    }\n\n    const distribution = riskDistribution[stage as 'youth' | 'middle' | 'fulfillment'] || riskDistribution.youth\n\n    // 各リスクレベルのチャレンジを生成（確率に基づく）\n    const random = Math.random()\n\n    if (random < 0.2) { // 20%の確率でリスクチャレンジを追加\n      let riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n      const levelRandom = Math.random()\n\n      if (levelRandom < distribution.low) {\n        riskLevel = 'low'\n      } else if (levelRandom < distribution.low + distribution.medium) {\n        riskLevel = 'medium'\n      } else if (levelRandom < distribution.low + distribution.medium + distribution.high) {\n        riskLevel = 'high'\n      } else {\n        riskLevel = 'extreme'\n      }\n\n      const riskChallenge = RiskRewardChallenge.createRiskChallenge(\n        stage as 'youth' | 'middle' | 'fulfillment',\n        riskLevel\n      )\n\n      challenges.push(riskChallenge)\n    }\n\n    return challenges\n  }\n\n  /**\n   * 落とし穴カードを生成\n   */\n  static createPitfallCards(): Card[] {\n    const pitfallDefinitions = [\n      { name: '急な入院', description: '予期せぬ医療費', power: 0, penalty: 3 },\n      { name: '失業', description: '収入の途絶', power: 0, penalty: 4 },\n      { name: '事故', description: '予期せぬトラブル', power: 0, penalty: 2 }\n    ]\n\n    return this.createCardsFromDefinitions(pitfallDefinitions, def => this.createPitfallCard(def))\n  }\n\n  /**\n   * 人生カードを作成（テスト用にpublicインスタンスメソッドも追加）\n   */\n  createLifeCard(params: {\n    category: LifeCardCategory\n    basePower: number\n    baseCost: number\n  }): Card {\n    return CardFactory.createLifeCard({\n      name: `テスト${params.category}カード`,\n      description: `${params.category}のテストカード`,\n      category: params.category,\n      power: params.basePower,\n      cost: params.baseCost\n    })\n  }\n\n  /**\n   * 人生カードを作成（静的メソッド）\n   */\n  private static createLifeCard(params: {\n    name: string\n    description: string\n    category: LifeCardCategory\n    power: number\n    cost: number\n  }): Card {\n    if (params.power < 0) throw new Error('Life card power cannot be negative')\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'life',\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: params.cost,\n      category: params.category,\n      effects: []\n    })\n  }\n\n  /**\n   * 保険カードを作成（Phase 2対応）\n   */\n  private static createInsuranceCard(params: {\n    name: string\n    description: string\n    insuranceType: InsuranceType\n    power: number\n    cost: number\n    coverage: number\n    ageBonus?: number\n  }): Card {\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'insurance',\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: params.cost,\n      insuranceType: params.insuranceType,\n      coverage: params.coverage,\n      effects: [{\n        type: 'shield',\n        value: params.coverage,\n        description: `${params.coverage}ポイントの保障`\n      }],\n      ageBonus: params.ageBonus || 0\n    })\n  }\n\n  /**\n   * チャレンジカードを作成\n   */\n  private static createChallengeCard(params: {\n    name: string\n    description: string\n    power: number\n    penalty: number\n    dreamCategory?: DreamCategory\n    isDream?: boolean\n  }): Card {\n    const type = params.isDream ? 'dream' : 'challenge'\n    // チャレンジの難易度に基づいて報酬タイプを決定\n    const rewardType = this.determineRewardType(params.power, type)\n\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type,\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: 0,\n      penalty: params.penalty,\n      effects: [],\n      dreamCategory: params.dreamCategory,\n      rewardType // 報酬タイプを追加\n    } as any)\n  }\n\n  /**\n   * チャレンジの難易度と種類に基づいて報酬タイプを決定\n   */\n  private static determineRewardType(power: number, type: string): RewardType {\n    // 夢カードの場合は活力回復\n    if (type === 'dream') {\n      return 'vitality'\n    }\n\n    // パワーレベルに基づいて報酬を決定\n    if (power <= 3) {\n      return 'insurance' // 低難易度：保険獲得\n    } if (power <= 6) {\n      return 'insurance' // 中難易度：保険獲得（基本）\n    }\n    return 'card' // 高難易度：追加カード獲得\n  }\n\n  /**\n   * 落とし穴カードを作成\n   */\n  private static createPitfallCard(params: {\n    name: string\n    description: string\n    power: number\n    penalty: number\n  }): Card {\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'trouble',\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: 0,\n      penalty: params.penalty,\n      effects: []\n    })\n  }\n\n\n\n  /**\n   * 汎用カード作成（テスト用）\n   */\n  static createCard(params: {\n    base: { name: string, type: string, description: string, id?: string },\n    variant: string,\n    effects?: any[]\n  }): Card {\n    const { base, effects } = params\n    return new Card({\n      id: base.id || IdGenerator.generateCardId(),\n      type: base.type as any,\n      name: base.name,\n      description: base.description,\n      power: 0,\n      cost: 0,\n      effects: effects || []\n    } as any)\n  }\n\n  /**\n   * 老化カードを作成\n   */\n  static createAgingCards(count: number): Card[] {\n    const cards: Card[] = []\n    for (let i = 0; i < count; i++) {\n      cards.push(new Card({\n        id: IdGenerator.generateCardId(),\n        type: 'aging',\n        name: '老化',\n        description: '年齢による衰え。使用不可。',\n        power: 0,\n        cost: 0,\n        effects: [{\n          type: 'aging_penalty',\n          value: 0,\n          description: '手札にあると活力が減少する可能性がある'\n        }]\n      }))\n    }\n    return cards\n  }\n\n  /**\n   * 最終試練カードを作成\n   */\n  static createFinalChallengeCard(): Card {\n    return new Card({\n      id: IdGenerator.generateCardId(),\n      type: 'final_challenge',\n      name: '人生の総決算',\n      description: 'これまでの人生のすべてを賭けた最後の挑戦',\n      power: 0, // Dynamic power based on calculation\n      cost: 0,\n      effects: []\n    })\n  }\n\n  /**\n   * スキルカードを生成\n   */\n  static createSkillCards(stage: GameStage = 'youth'): Card[] {\n    const skillDefinitionsByStage = {\n      youth: [\n        { name: '集中力', description: '集中して取り組む能力', rarity: 'common' as SkillRarity, power: 3, cooldown: 0 },\n        { name: 'コミュニケーション', description: '人との関わりを深める', rarity: 'common' as SkillRarity, power: 4, cooldown: 1 },\n        { name: 'リーダーシップ', description: 'チームを率いる力', rarity: 'rare' as SkillRarity, power: 6, cooldown: 2 },\n        { name: '創造性', description: '新しいアイデアを生み出す', rarity: 'epic' as SkillRarity, power: 8, cooldown: 3 }\n      ],\n      middle: [\n        { name: '戦略的思考', description: '長期的な視点で考える', rarity: 'rare' as SkillRarity, power: 7, cooldown: 2 },\n        { name: 'メンタリング', description: '後輩を指導する能力', rarity: 'rare' as SkillRarity, power: 6, cooldown: 1 },\n        { name: '危機管理', description: 'リスクを予測し対処する', rarity: 'epic' as SkillRarity, power: 9, cooldown: 3 },\n        { name: 'イノベーション', description: '革新的な変化を起こす', rarity: 'legendary' as SkillRarity, power: 12, cooldown: 4 }\n      ],\n      fulfillment: [\n        { name: '人生の知恵', description: '経験から得た深い洞察', rarity: 'epic' as SkillRarity, power: 10, cooldown: 2 },\n        { name: 'レガシー構築', description: '次世代への価値ある遺産', rarity: 'legendary' as SkillRarity, power: 15, cooldown: 5 },\n        { name: '精神的平和', description: '内なる調和と安定', rarity: 'legendary' as SkillRarity, power: 13, cooldown: 3 }\n      ]\n    }\n\n    const definitions = skillDefinitionsByStage[stage] || skillDefinitionsByStage.youth\n    return this.createCardsFromDefinitions(definitions, def =>\n      Card.createSkillCard(def.name, def.rarity, def.power, def.cooldown)\n    )\n  }\n\n  /**\n   * コンボカードを生成\n   */\n  static createComboCards(): Card[] {\n    const comboDefinitions = [\n      {\n        name: 'ワークライフバランス',\n        power: 2,\n        requiredCards: ['career', 'family'],\n        comboBonus: 4,\n        description: 'キャリアと家族の調和'\n      },\n      {\n        name: '健康的な成功',\n        power: 3,\n        requiredCards: ['health', 'finance'],\n        comboBonus: 5,\n        description: '健康と経済的安定の両立'\n      },\n      {\n        name: '充実した人生',\n        power: 4,\n        requiredCards: ['hobby', 'family', 'career'],\n        comboBonus: 8,\n        description: '趣味・家族・キャリアの三位一体'\n      }\n    ]\n\n    return this.createCardsFromDefinitions(comboDefinitions, def =>\n      Card.createComboCard(def.name, def.power, def.requiredCards, def.comboBonus)\n    )\n  }\n\n  /**\n   * イベントカードを生成\n   */\n  static createEventCards(stage: GameStage = 'youth'): Card[] {\n    const eventDefinitionsByStage = {\n      youth: [\n        { name: '新年の抱負', description: '新しい年への決意', power: 5, duration: 3, globalEffect: false },\n        { name: '就職ブーム', description: '雇用機会の増加', power: 4, duration: 2, globalEffect: true },\n        { name: '健康ブーム', description: '健康への意識向上', power: 3, duration: 4, globalEffect: true }\n      ],\n      middle: [\n        { name: '経済成長期', description: '社会全体の活況', power: 6, duration: 3, globalEffect: true },\n        { name: '家族の絆', description: '家族関係の深化', power: 7, duration: 2, globalEffect: false },\n        { name: '技術革新', description: 'テクノロジーの進歩', power: 8, duration: 4, globalEffect: true }\n      ],\n      fulfillment: [\n        { name: '人生の総決算', description: '経験の統合と成熟', power: 10, duration: 2, globalEffect: false },\n        { name: '世代交代', description: '次世代への継承', power: 9, duration: 3, globalEffect: true }\n      ]\n    }\n\n    const definitions = eventDefinitionsByStage[stage] || eventDefinitionsByStage.youth\n    return this.createCardsFromDefinitions(definitions, def =>\n      Card.createEventCard(def.name, def.power, def.duration, def.globalEffect)\n    )\n  }\n\n  /**\n   * レジェンダリーカードを生成（アンロック制）\n   */\n  static createLegendaryCards(): Card[] {\n    const legendaryDefinitions = [\n      {\n        name: '人生の達人',\n        power: 20,\n        unlockCondition: '全ステージで50回以上成功',\n        description: '人生経験の集大成'\n      },\n      {\n        name: '運命を変える決断',\n        power: 25,\n        unlockCondition: '連続10回チャレンジ成功',\n        description: '人生を劇的に変える瞬間'\n      },\n      {\n        name: '完璧な調和',\n        power: 30,\n        unlockCondition: '全カテゴリのカードを50枚以上獲得',\n        description: 'すべての側面が完璧にバランスした状態'\n      }\n    ]\n\n    return this.createCardsFromDefinitions(legendaryDefinitions, def =>\n      Card.createLegendaryCard(def.name, def.power, def.unlockCondition)\n    )\n  }\n  /**\n   * 報酬用カードを生成\n   */\n  static createRewardCards(stage: GameStage, count: number): Card[] {\n    // スキルカードを報酬の基本とする\n    const candidates = this.createSkillCards(stage)\n\n    // ランダムに選択\n    const shuffled = [...candidates].sort(() => Math.random() - 0.5)\n    return shuffled.slice(0, count)\n  }\n}","import type { Card } from '../entities/Card'\nimport { Deck } from '../entities/Deck'\nimport type { GameConfig } from '../types/game.types'\n\n/**\n * カード管理の状態\n */\nexport interface CardManagerState {\n  hand: Card[]\n  discardPile: Card[]\n  playerDeck: Deck\n  challengeDeck: Deck\n  selectedCards: Card[]\n  cardChoices: Card[] | undefined\n  // v2 new fields\n  agingDeck: Deck\n  insuranceMarket: Card[]\n  activeInsurances: Card[]\n}\n\n/**\n * カードドロー結果\n */\nexport interface DrawResult {\n  drawnCards: Card[]\n  discardedCards: Card[] // 手札上限により捨てられたカード\n  troubleCards: Card[] // 即時発動するトラブルカード\n}\n\n/**\n * CardManagerのインターフェース\n */\nexport interface ICardManager {\n  /**\n   * カード管理状態を初期化\n   */\n  initialize(playerDeck: Deck, challengeDeck: Deck, config: GameConfig): void\n\n  /**\n   * 現在の状態を取得\n   */\n  getState(): CardManagerState\n\n  /**\n   * 状態を復元\n   */\n  setState(state: CardManagerState): void\n\n  /**\n   * 指定した枚数のカードをドロー\n   */\n  drawCards(count: number): DrawResult\n\n  /**\n   * カードを選択/選択解除\n   */\n  toggleCardSelection(card: Card): boolean\n\n  /**\n   * 選択中のカードをクリア\n   */\n  clearSelection(): void\n\n  /**\n   * 選択されたカードを手札から捨て札に移動\n   */\n  discardSelectedCards(): Card[]\n\n  /**\n   * カードを手札に追加\n   */\n  addToHand(card: Card): void\n\n  /**\n   * カードを捨て札に追加\n   */\n  addToDiscardPile(card: Card): void\n\n  /**\n   * カードをプレイヤーデッキに追加\n   */\n  addToPlayerDeck(card: Card): void\n\n  /**\n   * 手札上限チェックと調整\n   */\n  enforceHandLimit(): Card[]\n\n  /**\n   * カード選択肢を設定\n   */\n  setCardChoices(choices: Card[]): void\n\n  /**\n   * カード選択肢をクリア\n   */\n  clearCardChoices(): void\n\n  /**\n   * 指定IDのカードを選択肢から取得\n   */\n  /**\n   * 指定IDのカードを選択肢から取得\n   */\n  getCardChoiceById(cardId: string): Card | undefined\n\n  /**\n   * チャレンジカードを引く\n   */\n  drawChallengeCard(): Card | null\n\n  // v2 methods\n  buyInsurance(card: Card): void\n  removeCardFromGame(card: Card): void\n  addAgingCardToDiscard(): void\n  getInsuranceMarket(): Card[]\n  getActiveInsurances(): Card[]\n  refillChallengeDeck(cards: Card[]): void\n  getChallengeDeckSize(): number\n  discardHand(): Card[]\n}\n\n/**\n * カード管理サービス（最適化版）\n */\nexport class CardManager implements ICardManager {\n  private hand: Card[] = []\n  private discardPile: Card[] = []\n  private playerDeck: Deck = new Deck('Player Deck')\n  private challengeDeck: Deck = new Deck('Challenge Deck')\n  private selectedCards: Card[] = []\n  private cardChoices: Card[] | undefined\n  private config?: GameConfig\n  // v2 fields\n  private agingDeck: Deck = new Deck('Aging Deck')\n  private insuranceMarket: Card[] = []\n  private activeInsurances: Card[] = []\n\n  // パフォーマンス最適化: オブジェクトプール\n  private static readonly CARD_POOLS = {\n    drawResults: [] as DrawResult[]\n  }\n\n  // IDベースの選択状態管理（インスタンスごと）\n  private selectedIdsSet = new Set<string>()\n\n  // キャッシュ\n  private _cachedState: CardManagerState | undefined\n  private _stateVersion = 0\n\n  /**\n   * カード管理状態を初期化\n   */\n  initialize(playerDeck: Deck, challengeDeck: Deck, config: GameConfig): void {\n    this.playerDeck = playerDeck\n    this.challengeDeck = challengeDeck\n    this.hand = []\n    this.discardPile = []\n    this.selectedCards = []\n    this.selectedIdsSet.clear()\n    this.cardChoices = undefined\n    this.config = config\n    // v2 init\n    this.agingDeck = new Deck('Aging Deck') // Should be populated from outside or config in real app\n    this.insuranceMarket = []\n    this.activeInsurances = []\n  }\n\n  /**\n   * 現在の状態を取得（キャッシュ最適化版）\n   */\n  getState(): CardManagerState {\n    // キャッシュが有効な場合はそれを返す\n    if (this._cachedState && this._stateVersion > 0) {\n      return this._cachedState\n    }\n\n    console.log('[CardManager] getState rebuilding cache. Hand size:', this.hand.length)\n\n    // 新しい状態を作成\n    const state: CardManagerState = {\n      hand: [...this.hand],\n      discardPile: [...this.discardPile],\n      playerDeck: this.playerDeck.clone(),\n      challengeDeck: this.challengeDeck.clone(),\n      selectedCards: [...this.selectedCards],\n      cardChoices: this.cardChoices ? [...this.cardChoices] : undefined,\n      agingDeck: this.agingDeck.clone(),\n      insuranceMarket: [...this.insuranceMarket],\n      activeInsurances: [...this.activeInsurances]\n    }\n\n    // キャッシュに保存\n    this._cachedState = state\n    this._stateVersion++\n\n    return state\n  }\n\n  /**\n   * 状態を復元\n   */\n  setState(state: CardManagerState): void {\n    this.hand = [...state.hand]\n    this.discardPile = [...state.discardPile]\n    this.playerDeck = state.playerDeck.clone()\n    this.challengeDeck = state.challengeDeck.clone()\n    this.selectedCards = [...state.selectedCards]\n    this.cardChoices = state.cardChoices ? [...state.cardChoices] : undefined\n    this.agingDeck = state.agingDeck.clone()\n    this.insuranceMarket = [...state.insuranceMarket]\n    this.activeInsurances = [...state.activeInsurances]\n\n    // キャッシュを無効化\n    this.invalidateCache()\n\n    // selectedIdsSetを再構築\n    this.selectedIdsSet.clear()\n    this.selectedCards.forEach(c => this.selectedIdsSet.add(c.id))\n  }\n\n  /**\n   * キャッシュを無効化\n   */\n  private invalidateCache(): void {\n    this._cachedState = undefined\n    this._stateVersion = 0\n  }\n\n  /**\n   * 指定した枚数のカードをドロー（最適化版）\n   */\n  drawCards(count: number): DrawResult {\n    if (!this.config) {\n      throw new Error('CardManager not initialized')\n    }\n\n    // オブジェクトプールからDrawResultを取得\n    let result = CardManager.CARD_POOLS.drawResults.pop()\n    if (!result) {\n      result = { drawnCards: [], discardedCards: [], troubleCards: [] }\n    } else {\n      // 配列をクリア\n      result.drawnCards.length = 0\n      result.discardedCards.length = 0\n      result.troubleCards.length = 0\n    }\n\n    for (let i = 0; i < count; i++) {\n      // デッキが空の場合、捨て札をシャッフルして山札に戻す\n      if (this.playerDeck.isEmpty() && this.discardPile.length > 0) {\n        this.reshuffleDeck()\n      }\n\n      const card = this.playerDeck.drawCard()\n      if (card) {\n        if (card.type === 'trouble') {\n          // トラブルカードは手札に入らず即時発動用に分離\n          result.troubleCards.push(card)\n          this.discardPile.push(card) // 即座に捨て札へ (効果は別途処理)\n          console.log('[CardManager] Drawn Trouble card:', card.name)\n        } else {\n          result.drawnCards.push(card)\n          this.hand.push(card)\n          console.log('[CardManager] Added card to hand. Hand size:', this.hand.length, 'Card:', card.name)\n        }\n      } else {\n        console.warn('[CardManager] Failed to draw card (deck empty?)')\n      }\n    }\n\n    // 手札上限チェック\n    const discardedCards = this.enforceHandLimit()\n    result.discardedCards.push(...discardedCards)\n\n    console.log('[CardManager] drawCards finished. Final hand size:', this.hand.length)\n\n    // キャッシュを無効化\n    this.invalidateCache()\n\n    return result\n  }\n\n  /**\n   * カードを選択/選択解除（最適化版）\n   */\n  toggleCardSelection(card: Card): boolean {\n    const cardId = card.id\n\n    // SetベースのIDチェックで高速化\n    if (this.selectedIdsSet.has(cardId)) {\n      // 選択解除\n      this.selectedIdsSet.delete(cardId)\n      const index = this.selectedCards.findIndex(c => c.id === cardId)\n      if (index !== -1) {\n        this.selectedCards.splice(index, 1)\n      }\n      this.invalidateCache()\n      return false // 選択解除\n    }\n    // 選択\n    this.selectedIdsSet.add(cardId)\n    this.selectedCards.push(card)\n    this.invalidateCache()\n    return true // 選択\n\n  }\n\n  /**\n   * 選択中のカードをクリア（最適化版）\n   */\n  clearSelection(): void {\n    this.selectedCards.length = 0\n    this.selectedIdsSet.clear()\n    this.invalidateCache()\n  }\n\n  /**\n   * 選択されたカードを手札から捨て札に移動\n   */\n  discardSelectedCards(): Card[] {\n    const discardedCards: Card[] = []\n\n    this.selectedCards.forEach(card => {\n      const index = this.hand.findIndex(c => c.id === card.id)\n      if (index !== -1) {\n        const removedCard = this.hand.splice(index, 1)[0]\n        if (removedCard) {\n          this.discardPile.push(removedCard)\n          discardedCards.push(removedCard)\n        }\n      }\n    })\n\n    this.selectedCards = []\n    return discardedCards\n  }\n\n  /**\n   * カードを手札に追加\n   */\n  addToHand(card: Card): void {\n    this.hand.push(card)\n    this.invalidateCache()\n  }\n\n  /**\n   * カードを捨て札に追加\n   */\n  addToDiscardPile(card: Card): void {\n    this.discardPile.push(card)\n    this.invalidateCache()\n  }\n\n  /**\n   * カードをプレイヤーデッキに追加\n   */\n  addToPlayerDeck(card: Card): void {\n    this.playerDeck.addCard(card)\n    this.invalidateCache()\n  }\n\n  /**\n   * 手札上限チェックと調整\n   */\n  enforceHandLimit(): Card[] {\n    if (!this.config) {\n      return []\n    }\n\n    const discardedCards: Card[] = []\n\n    // 手札上限チェック - 古いカードを捨て札に\n    while (this.hand.length > this.config.maxHandSize) {\n      const discarded = this.hand.shift()\n      if (discarded) {\n        this.discardPile.push(discarded)\n        discardedCards.push(discarded)\n      }\n    }\n\n    return discardedCards\n  }\n\n  /**\n   * カード選択肢を設定\n   */\n  setCardChoices(choices: Card[]): void {\n    this.cardChoices = [...choices]\n    this.invalidateCache()\n  }\n\n  /**\n   * カード選択肢をクリア\n   */\n  clearCardChoices(): void {\n    this.cardChoices = undefined\n    this.invalidateCache()\n  }\n\n  /**\n   * 指定IDのカードを選択肢から取得\n   */\n  getCardChoiceById(cardId: string): Card | undefined {\n    return this.cardChoices?.find(card => card.id === cardId)\n  }\n\n  /**\n   * 捨て札をシャッフルして山札に戻す\n   */\n  private reshuffleDeck(): void {\n    this.playerDeck.addCards(this.discardPile)\n    this.playerDeck.shuffle()\n    this.discardPile = []\n\n    // v2: Reshuffle Penalty (Aging Card)\n    this.addAgingCardToDiscard()\n  }\n\n  // v2 Methods\n\n  /**\n   * 保険を購入\n   */\n  buyInsurance(card: Card): void {\n    // Remove from market\n    const index = this.insuranceMarket.findIndex(c => c.id === card.id)\n    if (index !== -1) {\n      this.insuranceMarket.splice(index, 1)\n      this.activeInsurances.push(card)\n      this.invalidateCache()\n    }\n  }\n\n  /**\n   * カードをゲームから除外 (Deck Compression)\n   */\n  removeCardFromGame(card: Card): void {\n    // Check hand\n    let index = this.hand.findIndex(c => c.id === card.id)\n    if (index !== -1) {\n      this.hand.splice(index, 1)\n      this.invalidateCache()\n      return\n    }\n    // Check discard\n    index = this.discardPile.findIndex(c => c.id === card.id)\n    if (index !== -1) {\n      this.discardPile.splice(index, 1)\n      this.invalidateCache()\n      return\n    }\n    // Check deck (expensive but needed)\n    if (this.playerDeck.removeCard(card.id)) {\n      this.invalidateCache()\n      return\n    }\n  }\n\n  /**\n   * 老化カードを捨て札に追加\n   */\n  addAgingCardToDiscard(): void {\n    const agingCard = this.agingDeck.drawCard()\n    if (agingCard) {\n      this.discardPile.push(agingCard)\n      console.log('[CardManager] Aging card added to discard pile due to reshuffle')\n    } else {\n      console.warn('[CardManager] No aging cards left! (Game Over Condition usually)')\n    }\n  }\n\n  getInsuranceMarket(): Card[] {\n    return this.insuranceMarket\n  }\n\n  getActiveInsurances(): Card[] {\n    return this.activeInsurances\n  }\n\n  /**\n   * チャレンジカードを引く\n   */\n  drawChallengeCard(): Card | null {\n    const card = this.challengeDeck.drawCard()\n    if (card) {\n      this.invalidateCache()\n    }\n    return card\n  }\n\n  /**\n   * チャレンジデッキを補充する\n   */\n  refillChallengeDeck(cards: Card[]): void {\n    this.challengeDeck.clear()\n    this.challengeDeck.addCards(cards)\n    this.challengeDeck.shuffle()\n    this.invalidateCache()\n  }\n\n  /**\n   * チャレンジデッキのカード数を取得\n   */\n  getChallengeDeckSize(): number {\n    return this.challengeDeck.getCards().length\n  }\n\n  /**\n   * 手札をすべて捨て札に移動\n   */\n  discardHand(): Card[] {\n    const discarded = [...this.hand]\n    this.discardPile.push(...discarded)\n    this.hand = []\n    this.invalidateCache()\n    return discarded\n  }\n}","/**\n * リスクファクター値オブジェクト\n * \n * 保険料計算に使用されるリスク要因を表現する値オブジェクト。\n * 各要因は0.0〜1.0の範囲で表現され、高いほどリスクが高いことを示す。\n */\nexport class RiskFactor {\n  private constructor(\n    private readonly value: number,\n    private readonly factorType: RiskFactorType\n  ) { }\n\n  /**\n   * リスクファクターを作成\n   * @param value リスク値（0.0-1.0）\n   * @param factorType リスクの種類\n   * @returns RiskFactorインスタンス\n   * @throws {Error} 値が範囲外の場合\n   */\n  static create(value: number, factorType: RiskFactorType): RiskFactor {\n    if (value < 0 || value > 1) {\n      throw new Error(`Risk factor value must be between 0 and 1, got ${value}`)\n    }\n    return new RiskFactor(value, factorType)\n  }\n\n  /**\n   * リスク値を取得\n   */\n  getValue(): number {\n    return this.value\n  }\n\n  /**\n   * リスクタイプを取得\n   */\n  getType(): RiskFactorType {\n    return this.factorType\n  }\n\n  /**\n   * リスクレベルを取得（低・中・高）\n   */\n  getRiskLevel(): RiskLevel {\n    if (this.value <= 0.3) return 'low'\n    if (this.value <= 0.7) return 'medium'\n    return 'high'\n  }\n\n  /**\n   * 保険料への影響倍率を計算\n   * @returns 保険料倍率（1.0が基準）\n   */\n  getPremiumMultiplier(): number {\n    // リスクタイプごとに異なる影響度\n    const impactFactors: Record<RiskFactorType, number> = {\n      age: 0.5,         // 年齢は50%の影響\n      health: 0.3,      // 健康状態は30%の影響\n      claims: 0.4,      // 請求履歴は40%の影響\n      lifestyle: 0.2    // ライフスタイルは20%の影響\n    }\n\n    const impact = impactFactors[this.factorType] || 0.3\n    // 基準1.0に対して、リスク値に応じて倍率を調整\n    return 1.0 + (this.value * impact)\n  }\n\n  /**\n   * リスクを調整（イベントによる変動）\n   * @param adjustment 調整値（-1.0〜1.0）\n   * @returns 新しいRiskFactorインスタンス\n   */\n  adjust(adjustment: number): RiskFactor {\n    const newValue = Math.max(0, Math.min(1, this.value + adjustment))\n    return new RiskFactor(newValue, this.factorType)\n  }\n\n  /**\n   * 他のリスクファクターと結合\n   * @param other 他のリスクファクター\n   * @param weight 結合時の重み（0.0-1.0）\n   * @returns 新しいRiskFactorインスタンス\n   */\n  combine(other: RiskFactor, weight: number = 0.5): RiskFactor {\n    if (this.factorType !== other.factorType) {\n      throw new Error('Cannot combine different risk factor types')\n    }\n\n    const combinedValue = this.value * (1 - weight) + other.value * weight\n    return new RiskFactor(combinedValue, this.factorType)\n  }\n\n  /**\n   * 等価性の確認\n   */\n  equals(other: RiskFactor): boolean {\n    return this.value === other.value && this.factorType === other.factorType\n  }\n\n  /**\n   * 文字列表現\n   */\n  toString(): string {\n    return `RiskFactor(${this.factorType}: ${this.value.toFixed(2)} - ${this.getRiskLevel()})`\n  }\n}\n\n/**\n * リスクファクターの種類\n */\nexport type RiskFactorType = 'age' | 'health' | 'claims' | 'lifestyle'\n\n/**\n * リスクレベル\n */\nexport type RiskLevel = 'low' | 'medium' | 'high'\n","import { RiskFactor, type RiskFactorType } from './RiskFactor'\n\n/**\n * リスクプロファイル - 複数のリスクファクターの集合\n */\nexport class RiskProfile {\n  private constructor(\n    private readonly factors: Map<RiskFactorType, RiskFactor>\n  ) { }\n\n  /**\n   * 空のリスクプロファイルを作成\n   */\n  static empty(): RiskProfile {\n    return new RiskProfile(new Map())\n  }\n\n  /**\n   * デフォルトのリスクプロファイルを作成\n   */\n  static default(): RiskProfile {\n    const factors = new Map<RiskFactorType, RiskFactor>()\n    factors.set('age', RiskFactor.create(0.3, 'age'))\n    factors.set('health', RiskFactor.create(0.2, 'health'))\n    factors.set('claims', RiskFactor.create(0.0, 'claims'))\n    factors.set('lifestyle', RiskFactor.create(0.3, 'lifestyle'))\n    return new RiskProfile(factors)\n  }\n\n  /**\n   * リスクファクターを追加/更新\n   */\n  withFactor(factor: RiskFactor): RiskProfile {\n    const newFactors = new Map(this.factors)\n    newFactors.set(factor.getType(), factor)\n    return new RiskProfile(newFactors)\n  }\n\n  /**\n   * 特定のリスクファクターを取得\n   */\n  getFactor(type: RiskFactorType): RiskFactor | undefined {\n    return this.factors.get(type)\n  }\n\n  /**\n   * 全体のリスクスコアを計算（0.0-1.0）\n   */\n  getOverallRiskScore(): number {\n    if (this.factors.size === 0) return 0\n\n    let totalScore = 0\n    this.factors.forEach(factor => {\n      totalScore += factor.getValue()\n    })\n\n    return totalScore / this.factors.size\n  }\n\n  /**\n   * 保険料への総合的な影響倍率を計算\n   */\n  getTotalPremiumMultiplier(): number {\n    if (this.factors.size === 0) return 1.0\n\n    let multiplier = 1.0\n    this.factors.forEach(factor => {\n      // 各ファクターの倍率を乗算的に適用\n      multiplier *= factor.getPremiumMultiplier()\n    })\n\n    return multiplier\n  }\n\n  /**\n   * リスクプロファイルの要約を取得\n   */\n  getSummary(): string {\n    const overallScore = this.getOverallRiskScore()\n    const level = overallScore <= 0.3 ? '低リスク' :\n      overallScore <= 0.7 ? '中リスク' : '高リスク'\n\n    return `${level} (スコア: ${overallScore.toFixed(2)})`\n  }\n}","import { InsurancePremium } from '../valueObjects/InsurancePremium'\nimport type { Card } from '../entities/Card'\nimport type { GameStage } from '../types/card.types'\nimport type { InsuranceType } from '../types/card.types'\nimport { RiskFactor, type RiskFactorType } from '../valueObjects/RiskFactor'\nimport { RiskProfile } from '../valueObjects/RiskProfile'\n\n/**\n * 保険料計算ドメインサービス\n * \n * 保険料に関する複雑なビジネスロジックを集約し、\n * 年齢調整、保険種別調整、リスク調整等を統一的に管理します。\n * \n * このサービスは状態を持たず、純粋なビジネスロジックのみを提供します。\n */\nexport class InsurancePremiumCalculationService {\n  /**\n   * 年齢ステージによる保険料倍率\n   */\n  private static readonly AGE_MULTIPLIERS: Record<GameStage, number> = {\n    'youth': 1.0,          // 青年期: 基準倍率\n    'middle': 1.2,         // 中年期: 20%増し\n    'fulfillment': 1.3     // 充実期: 30%増し\n  }\n\n  /**\n   * 保険種別による基本料率\n   */\n  private static readonly INSURANCE_TYPE_RATES: Record<InsuranceType, number> = {\n    'health': 1.0,         // 健康保険(deprecated? -> medical in v2)\n    'medical': 1.0,        // 医療保険: 基準料率\n    'life': 1.2,           // 生命保険: 20%高\n    'income': 1.0,         // 収入保障: 基準料率\n    'asset': 0.5,          // 資産形成保険: 50%安 (長期投資前提)\n    'disability': 0.8,     // 障害保険: 20%安\n    'accident': 0.6,       // 事故保険: 40%安\n    'cancer': 1.5,         // がん保険: 50%高\n    'dental': 0.4,         // 歯科保険: 60%安\n    'travel': 0.3          // 旅行保険: 70%安\n  }\n\n  /**\n   * 年齢調整済み保険料を計算\n   * \n   * @param basePremium 基本保険料\n   * @param stage プレイヤーの現在ステージ\n   * @returns 年齢調整済み保険料\n   */\n  calculateAgeAdjustedPremium(basePremium: InsurancePremium, stage: GameStage): InsurancePremium {\n    const multiplier = InsurancePremiumCalculationService.AGE_MULTIPLIERS[stage] || 1.0\n    return basePremium.applyMultiplier(multiplier)\n  }\n\n  /**\n   * 保険カードの総合保険料を計算\n   * \n   * 基本料金 + 年齢調整 + 保険種別調整 + カバレッジ調整 + リスク調整を総合的に計算\n   * \n   * @param card 保険カード\n   * @param stage プレイヤーの現在ステージ\n   * @param riskProfile プレイヤーのリスクプロファイル（オプション）\n   * @returns 総合保険料\n   */\n  calculateComprehensivePremium(\n    card: Card,\n    stage: GameStage,\n    riskProfile?: RiskProfile\n  ): InsurancePremium {\n    if (card.type !== 'insurance') {\n      throw new Error('Card must be an insurance card')\n    }\n\n    // 基本保険料取得\n    const basePremium = card.getCost()\n\n    // 年齢調整\n    const ageAdjustedPremium = this.calculateAgeAdjustedPremium(basePremium, stage)\n\n    // 保険種別調整\n    const typeAdjustedPremium = this.applyInsuranceTypeAdjustment(ageAdjustedPremium, card.insuranceType)\n\n    // カバレッジ調整\n    const coverageAdjustedPremium = this.applyCoverageAdjustment(typeAdjustedPremium, card.coverage)\n\n    // リスクプロファイル調整\n    if (riskProfile) {\n      const riskMultiplier = this.calculateRiskAdjustment(riskProfile, card.insuranceType)\n      return coverageAdjustedPremium.applyMultiplier(riskMultiplier)\n    }\n\n    return coverageAdjustedPremium\n  }\n\n  /**\n   * 保険料負担の総計算\n   * \n   * 複数の保険を持つプレイヤーの総保険料負担を計算\n   * 3枚ごとの負担増加ルールを適用\n   * \n   * @param insuranceCards アクティブな保険カード配列\n   * @param stage プレイヤーの現在ステージ\n   * @param riskProfile プレイヤーのリスクプロファイル（オプション）\n   * @returns 総保険料負担\n   */\n  calculateTotalInsuranceBurden(\n    insuranceCards: Card[],\n    stage: GameStage,\n    riskProfile?: RiskProfile\n  ): InsurancePremium {\n    // 各保険の個別料金計算\n    const individualPremiums = insuranceCards\n      .filter(card => card && card.type === 'insurance')\n      .map(card =>\n        this.calculateComprehensivePremium(card, stage, riskProfile)\n      )\n\n    // 基本合計\n    const baseTotalPremium = InsurancePremium.sum(individualPremiums)\n\n    // 3枚ごとの負担増加ルール\n    const penaltyMultiplier = this.calculateMultiInsurancePenalty(insuranceCards.length)\n\n    return baseTotalPremium.applyMultiplier(penaltyMultiplier)\n  }\n\n  /**\n   * 保険更新時の料金計算\n   * \n   * 既存保険の更新時における料金調整\n   * 継続割引、経験調整、年齢変化を考慮\n   * \n   * @param card 更新対象の保険カード\n   * @param currentStage 現在のステージ\n   * @param usageHistory 使用履歴（使用回数）\n   * @returns 更新時保険料\n   */\n  calculateRenewalPremium(card: Card, currentStage: GameStage, usageHistory: number): InsurancePremium {\n    // 基本更新料金\n    const basePremium = this.calculateComprehensivePremium(card, currentStage)\n\n    // 継続割引適用（長期継続者優遇）\n    const continuityDiscount = this.calculateContinuityDiscount(usageHistory)\n    const discountedPremium = basePremium.applyDiscount(continuityDiscount)\n\n    // 使用実績による調整（リスク評価）\n    const riskMultiplier = this.calculateRiskMultiplier(usageHistory)\n\n    return discountedPremium.applyMultiplier(riskMultiplier)\n  }\n\n  /**\n   * 最適保険ポートフォリオの提案\n   * \n   * プレイヤーの状況に応じた最適な保険組み合わせを計算\n   * \n   * @param availableBudget 利用可能予算（活力）\n   * @param _stage 現在ステージ (未使用)\n   * @param riskProfile リスクプロファイル\n   * @returns 推奨保険料上限\n   */\n  calculateOptimalInsuranceBudget(\n    availableBudget: number,\n    _stage: GameStage,\n    riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'\n  ): InsurancePremium {\n    const budgetRatios = {\n      'conservative': 0.15,  // 予算の15%\n      'balanced': 0.25,      // 予算の25%\n      'aggressive': 0.35     // 予算の35%\n    }\n\n    const ratio = budgetRatios[riskProfile]\n    const recommendedBudget = Math.floor(availableBudget * ratio)\n\n    return InsurancePremium.create(recommendedBudget)\n  }\n\n  /**\n   * 保険種別調整を適用\n   * @private\n   */\n  private applyInsuranceTypeAdjustment(\n    premium: InsurancePremium,\n    insuranceType?: InsuranceType\n  ): InsurancePremium {\n    if (!insuranceType) {\n      return premium\n    }\n\n    const typeRate = InsurancePremiumCalculationService.INSURANCE_TYPE_RATES[insuranceType] || 1.0\n    return premium.applyMultiplier(typeRate)\n  }\n\n  /**\n   * カバレッジ調整を適用\n   * @private\n   */\n  private applyCoverageAdjustment(premium: InsurancePremium, coverage?: number): InsurancePremium {\n    if (!coverage || coverage <= 0) {\n      // カバレッジ0の場合は基本料金の50%割引\n      return premium.applyMultiplier(0.5)\n    }\n\n    // カバレッジ調整\n    // カバレッジ200を基準（1.0倍）として、緩やかに変動させる\n    // 以前の計算式 (coverage / 50) は過度な負担を生んでいたため修正\n    const coverageMultiplier = 0.5 + (coverage / 400)\n\n    return premium.applyMultiplier(coverageMultiplier)\n  }\n\n  /**\n   * 複数保険ペナルティを計算\n   * @private\n   */\n  private calculateMultiInsurancePenalty(insuranceCount: number): number {\n    // 改善版: 5枚ごとに10%ずつ負担増加、上限30%\n    const penaltySteps = Math.floor(insuranceCount / 5)\n    const penaltyRate = Math.min(penaltySteps * 0.1, 0.3)  // 最大30%増\n    return 1.0 + penaltyRate\n  }\n\n  /**\n   * 継続割引率を計算\n   * @private\n   */\n  private calculateContinuityDiscount(usageHistory: number): number {\n    // 使用履歴が少ないほど継続割引率が高い（優良顧客）\n    if (usageHistory === 0) return 0.1      // 10%割引\n    if (usageHistory <= 2) return 0.05      // 5%割引\n    return 0                                 // 割引なし\n  }\n\n  /**\n   * リスク倍率を計算\n   * @private\n   */\n  private calculateRiskMultiplier(usageHistory: number): number {\n    // 使用履歴が多いほどリスクが高いとみなして料金増加\n    if (usageHistory >= 5) return 1.3       // 30%増し\n    if (usageHistory >= 3) return 1.1       // 10%増し\n    return 1.0                               // 基準料金\n  }\n\n  /**\n   * リスクプロファイルに基づく保険料調整を計算\n   * @private\n   */\n  private calculateRiskAdjustment(riskProfile: RiskProfile, insuranceType?: InsuranceType): number {\n    // 基本的なリスク倍率\n    let baseMultiplier = riskProfile.getTotalPremiumMultiplier()\n\n    // 保険種類ごとに特定のリスクファクターの影響を強化\n    if (insuranceType) {\n      const typeSpecificAdjustments: Partial<Record<InsuranceType, RiskFactorType>> = {\n        'health': 'health',      // 健康保険は健康リスクの影響大\n        'life': 'age',          // 生命保険は年齢リスクの影響大\n        'disability': 'health',  // 障害保険は健康リスクの影響大\n        'accident': 'lifestyle', // 事故保険はライフスタイルの影響大\n        'cancer': 'health',      // がん保険は健康リスクの影響大\n      }\n\n      const relevantFactorType = typeSpecificAdjustments[insuranceType]\n      if (relevantFactorType) {\n        const specificFactor = riskProfile.getFactor(relevantFactorType)\n        if (specificFactor) {\n          // 特定リスクの影響を20%強化\n          const specificMultiplier = specificFactor.getPremiumMultiplier()\n          baseMultiplier = baseMultiplier * 0.8 + specificMultiplier * 0.2\n        }\n      }\n    }\n\n    return baseMultiplier\n  }\n\n  /**\n   * プレイヤーの行動履歴からリスクプロファイルを生成\n   * \n   * @param playerHistory プレイヤーの行動履歴\n   * @param currentStage 現在のステージ\n   * @returns 計算されたリスクプロファイル\n   */\n  generateRiskProfile(playerHistory: PlayerHistory, currentStage: GameStage): RiskProfile {\n    let profile = RiskProfile.default()\n\n    // 年齢リスクの計算\n    const ageRiskValue = this.calculateAgeRisk(currentStage)\n    profile = profile.withFactor(RiskFactor.create(ageRiskValue, 'age'))\n\n    // 健康リスクの計算（ダメージ履歴から）\n    const healthRiskValue = this.calculateHealthRisk(playerHistory)\n    profile = profile.withFactor(RiskFactor.create(healthRiskValue, 'health'))\n\n    // 請求履歴リスクの計算\n    const claimsRiskValue = this.calculateClaimsRisk(playerHistory)\n    profile = profile.withFactor(RiskFactor.create(claimsRiskValue, 'claims'))\n\n    // ライフスタイルリスクの計算（プレイスタイルから）\n    const lifestyleRiskValue = this.calculateLifestyleRisk(playerHistory)\n    profile = profile.withFactor(RiskFactor.create(lifestyleRiskValue, 'lifestyle'))\n\n    return profile\n  }\n\n  /**\n   * リスクプロファイルを考慮した保険料を計算\n   * \n   * @param card 保険カード\n   * @param stage ゲームステージ\n   * @param riskProfile リスクプロファイル（オプション）\n   * @returns リスク調整済み保険料\n   */\n  calculateRiskAdjustedPremium(\n    card: Card,\n    stage: GameStage,\n    riskProfile?: RiskProfile\n  ): InsurancePremium {\n    // 基本的な総合保険料を計算\n    const basePremium = this.calculateComprehensivePremium(card, stage)\n\n    // リスクプロファイルがない場合は基本保険料をそのまま返す\n    if (!riskProfile) {\n      return basePremium\n    }\n\n    // リスク調整倍率を計算\n    const riskMultiplier = this.calculateRiskAdjustment(riskProfile, card.insuranceType)\n\n    // リスク調整を適用\n    return basePremium.applyMultiplier(riskMultiplier)\n  }\n\n  /**\n   * 年齢によるリスク値を計算\n   * @private\n   */\n  private calculateAgeRisk(stage: GameStage): number {\n    const ageRiskMap: Record<GameStage, number> = {\n      'youth': 0.2,\n      'middle': 0.5,\n      'fulfillment': 0.6\n    }\n    return ageRiskMap[stage] || 0.5\n  }\n\n  /**\n   * 健康履歴からリスク値を計算\n   * @private\n   */\n  private calculateHealthRisk(history: PlayerHistory): number {\n    const totalDamageTaken = history.totalDamageTaken || 0\n    const turnsPlayed = history.turnsPlayed || 1\n    const averageDamagePerTurn = totalDamageTaken / turnsPlayed\n\n    // 平均ダメージが多いほどリスクが高い\n    if (averageDamagePerTurn >= 3) return 0.8\n    if (averageDamagePerTurn >= 2) return 0.6\n    if (averageDamagePerTurn >= 1) return 0.4\n    return 0.2\n  }\n\n  /**\n   * 保険請求履歴からリスク値を計算\n   * @private\n   */\n  private calculateClaimsRisk(history: PlayerHistory): number {\n    const claimCount = history.insuranceClaimCount || 0\n    const totalInsurances = history.totalInsurancePurchased || 1\n    const claimRate = claimCount / totalInsurances\n\n    // 請求率が高いほどリスクが高い\n    if (claimRate >= 0.5) return 0.9\n    if (claimRate >= 0.3) return 0.6\n    if (claimRate >= 0.1) return 0.3\n    return 0.1\n  }\n\n  /**\n   * プレイスタイルからライフスタイルリスクを計算\n   * @private\n   */\n  private calculateLifestyleRisk(history: PlayerHistory): number {\n    const riskyChoices = history.riskyChoiceCount || 0\n    const totalChoices = history.totalChoiceCount || 1\n    const riskRate = riskyChoices / totalChoices\n\n    // リスキーな選択が多いほどリスクが高い\n    if (riskRate >= 0.6) return 0.8\n    if (riskRate >= 0.4) return 0.5\n    if (riskRate >= 0.2) return 0.3\n    return 0.1\n  }\n}\n\n/**\n * プレイヤー履歴インターフェース\n */\nexport interface PlayerHistory {\n  turnsPlayed: number\n  totalDamageTaken: number\n  insuranceClaimCount: number\n  totalInsurancePurchased: number\n  riskyChoiceCount: number\n  totalChoiceCount: number\n}","import type { GameStage } from '../types/card.types'\nimport type { DreamCategory } from '../types/card.types'\n\n/**\n * ゲーム定数管理\n * \n * ゲーム全体で使用される定数を一元管理し、\n * マジックナンバーを排除してメンテナンス性を向上させる。\n */\n\n/**\n * 年齢ステージ関連の定数\n */\nexport const AGE_CONSTANTS = {\n  /**\n   * 各ステージの基本パラメータ\n   */\n  STAGE_PARAMETERS: {\n    youth: {\n      label: '青年期',\n      maxVitality: 60, // Reduced from 80\n      startTurn: 0,\n      endTurn: 6,\n      insuranceMultiplier: 1.0,\n      challengeDifficultyModifier: 1.0 // Reduced from 1.5 to help Advanced\n    },\n    middle: {\n      label: '中年期',\n      maxVitality: 60, // Reduced from 80\n      startTurn: 7,\n      endTurn: 13,\n      insuranceMultiplier: 1.2,\n      challengeDifficultyModifier: 1.5 // Reduced from 2.0\n    },\n    fulfillment: {\n      label: '充実期',\n      maxVitality: 50, // Reduced from 60\n      startTurn: 14,\n      endTurn: Infinity,\n      insuranceMultiplier: 1.5, // Increased from 1.3\n      challengeDifficultyModifier: 2.0 // Reduced from 2.5\n    }\n  } as const,\n\n  /**\n   * 年齢ボーナス計算式\n   */\n  AGE_BONUS: {\n    youth: 0,\n    middle: 0.5,\n    fulfillment: 1.0\n  } as const,\n\n  /**\n   * 活力上限調整パラメータ\n   */\n  VITALITY_LIMITS: {\n    youth: 100,\n    middle: 80,\n    fulfillment: 60\n  } as const\n} as const\n\n/**\n * 夢カード関連の定数\n */\nexport const DREAM_CONSTANTS = {\n  /**\n   * 夢カテゴリ別の年齢調整値\n   */\n  AGE_ADJUSTMENTS: {\n    physical: -2,    // 身体系は年齢とともに難しくなる\n    intellectual: 1, // 知的系は経験で易しくなる\n    mixed: -1       // 混合系は少し難しくなる\n  } as const satisfies Record<DreamCategory, number>,\n\n  /**\n   * 夢カードの基本設定\n   */\n  BASE_SETTINGS: {\n    minPower: 1,        // 最小パワー\n    maxPower: 15,       // 最大パワー\n    defaultPower: 5     // デフォルトパワー\n  } as const\n} as const\n\n/**\n * 保険関連の定数\n */\nexport const INSURANCE_CONSTANTS = {\n  /**\n   * 保険料計算の基本パラメータ\n   */\n  PREMIUM_CALCULATION: {\n    baseCostMultiplier: 0.4,      // 基本コスト倍率 (Increased to 0.4 to pinch finances)\n    ageMultiplierStart: 1.0,      // 年齢倍率開始値\n    ageMultiplierIncrement: 0.15,  // 年齢倍率増分\n    coverageRateBase: 50,         // カバレッジ基準値\n    multiInsurancePenalty: 0.1    // 複数保険ペナルティ（3枚ごと）\n  } as const,\n\n  /**\n   * 保険種類別の料率\n   */\n  TYPE_RATES: {\n    medical: 1.0,     // 医療保険: 基準料率\n    life: 1.2,        // 生命保険: 20%高\n    income: 1.0,      // 収入保障: 基準料率\n    asset: 0.5,       // 資産形成保険: 50%安\n    disability: 0.8,  // 障害保険: 20%安\n    accident: 0.6,    // 事故保険: 40%安\n    cancer: 1.5,      // がん保険: 50%高\n    dental: 0.4,      // 歯科保険: 60%安\n    travel: 0.3       // 旅行保険: 70%安\n  } as const,\n\n  /**\n   * 保険期間設定\n   */\n  DURATION_SETTINGS: {\n    termInsurance: {\n      defaultDuration: 5,  // 定期保険のデフォルト期間\n      costDiscount: 0.1     // 定期保険のコスト割引率 (Discounted to 0.1 - huge advantage for Term)\n    },\n    wholeLifeInsurance: {\n      costMultiplier: 1.0   // 終身保険のコスト倍率\n    }\n  } as const,\n\n  /**\n   * 保険使用実績による調整\n   */\n  USAGE_ADJUSTMENTS: {\n    continuityDiscount: {\n      noUsage: 0.1,      // 未使用: 10%割引\n      lowUsage: 0.05,    // 低使用(1-2回): 5%割引\n      normalUsage: 0     // 通常使用: 割引なし\n    },\n    riskMultiplier: {\n      highUsage: 1.3,    // 高使用(5回以上): 30%増し\n      moderateUsage: 1.1, // 中程度使用(3-4回): 10%増し\n      lowUsage: 1.0      // 低使用: 基準料金\n    }\n  } as const\n} as const\n\n/**\n * ゲームバランス関連の定数\n */\nexport const BALANCE_CONSTANTS = {\n  /**\n   * カード関連\n   */\n  CARD_LIMITS: {\n    maxHandSize: 10,           // 最大手札数\n    startingHandSize: 5,       // 初期手札数\n    defaultDrawCount: 1,       // デフォルトドロー数\n    maxDeckSize: 100          // 最大デッキサイズ\n  } as const,\n\n  /**\n   * チャレンジ関連\n   */\n  CHALLENGE_SETTINGS: {\n    minDifficulty: 1,          // 最小難易度\n    maxDifficulty: 20,         // 最大難易度\n    successBonusBase: 8,       // 成功時ボーナス基準値 (Increased to reward skilled play)\n    failurePenaltyRatio: 1.5,  // 失敗時ペナルティ比率 (Increased to punish reckless play)\n    enableDynamicDifficulty: true // 動的難易度調整の有効化\n  } as const,\n\n  /**\n   * 活力関連\n   */\n  VITALITY_SETTINGS: {\n    defaultStarting: 40,       // デフォルト初期活力 (Decreased to 40 for harder start)\n    minimumValue: 0,           // 最小活力値\n    maximumValue: 150,         // 最大活力値\n    healingCap: 0.85           // 回復上限（最大活力の85%）\n  } as const,\n\n  /**\n   * ゲーム進行関連\n   */\n  PROGRESSION_SETTINGS: {\n    maxTurns: 20,              // 最大ターン数 (50 -> 20)\n    stageTransitionTurns: {    // ステージ転換ターン\n      youthToMiddle: 7,        // 青年期: 0-6 (7ターン)\n      middleToFulfillment: 14  // 中年期: 7-13 (7ターン), 充実期: 14-20\n    },\n    victoryConditions: {\n      minTurns: 15,            // 勝利条件最小ターン\n      minVitality: 50          // 勝利条件最小活力\n    }\n  } as const\n} as const\n\n/**\n * パフォーマンス関連の定数\n */\nexport const PERFORMANCE_CONSTANTS = {\n  /**\n   * キャッシュ設定\n   */\n  CACHE_SETTINGS: {\n    stateSnapshotTTL: 50,      // 状態スナップショットTTL (ms)\n    calculationCacheTTL: 100,  // 計算キャッシュTTL (ms)\n    maxCacheEntries: 100       // 最大キャッシュエントリ数\n  } as const,\n\n  /**\n   * オブジェクトプール設定\n   */\n  OBJECT_POOL_LIMITS: {\n    maxPoolSize: 10,           // 最大プールサイズ\n    initialPoolSize: 3         // 初期プールサイズ\n  } as const,\n\n  /**\n   * 処理制限\n   */\n  PROCESSING_LIMITS: {\n    maxCardsPerSelection: 20,  // 選択可能最大カード数\n    maxInsuranceCards: 30,     // 最大保険カード数\n    maxHistoryEntries: 1000    // 最大履歴エントリ数\n  } as const\n} as const\n\n/**\n * UI関連の定数\n */\nexport const UI_CONSTANTS = {\n  /**\n   * アニメーション設定\n   */\n  ANIMATION_DURATIONS: {\n    cardFlip: 300,           // カードフリップ (ms)\n    cardDraw: 500,           // カードドロー (ms)\n    phaseTransition: 800,    // フェーズ転換 (ms)\n    messageDisplay: 2000     // メッセージ表示 (ms)\n  } as const,\n\n  /**\n   * 表示設定\n   */\n  DISPLAY_SETTINGS: {\n    maxVisibleCards: 12,     // 最大表示カード数\n    cardSpacing: 10,         // カード間隔 (px)\n    messageMaxLength: 200    // メッセージ最大長\n  } as const\n} as const\n\n/**\n * デバッグ・テスト関連の定数\n */\nexport const DEBUG_CONSTANTS = {\n  /**\n   * ログ設定\n   */\n  LOGGING: {\n    maxLogEntries: 500,      // 最大ログエントリ数\n    logRetentionDays: 7      // ログ保持日数\n  } as const,\n\n  /**\n   * テスト設定\n   */\n  TESTING: {\n    fastMode: false,         // 高速モード\n    skipAnimations: false,   // アニメーションスキップ\n    debugVitality: false     // 活力デバッグ\n  } as const\n} as const\n\n/**\n * 定数の型安全なアクセサ\n */\nimport type { BalanceConfig } from '../types/game.types'\n\n/**\n * 定数の型安全なアクセサ\n */\nexport class GameConstantsAccessor {\n  private static overrides: BalanceConfig | undefined\n\n  /**\n   * オーバーライド設定を適用\n   */\n  static setOverrides(config?: BalanceConfig) {\n    this.overrides = config\n  }\n\n  /**\n   * オーバーライドをクリア\n   */\n  static clearOverrides() {\n    this.overrides = undefined\n  }\n\n  /**\n   * ステージパラメータを安全に取得\n   */\n  static getStageParameters(stage: GameStage) {\n    const base = AGE_CONSTANTS.STAGE_PARAMETERS[stage] || AGE_CONSTANTS.STAGE_PARAMETERS.youth\n    if (this.overrides?.stageParameters?.[stage]) {\n      return { ...base, ...this.overrides.stageParameters[stage] }\n    }\n    return base\n  }\n\n  /**\n   * 夢カード年齢調整値を安全に取得\n   */\n  static getDreamAgeAdjustment(category: DreamCategory): number {\n    return DREAM_CONSTANTS.AGE_ADJUSTMENTS[category] ?? 0\n  }\n\n  /**\n   * 保険種類別料率を安全に取得\n   */\n  static getInsuranceTypeRate(type: keyof typeof INSURANCE_CONSTANTS.TYPE_RATES): number {\n    return INSURANCE_CONSTANTS.TYPE_RATES[type] ?? 1.0\n  }\n\n  /**\n   * バランス設定を取得\n   */\n  static getBalanceSettings() {\n    const base = BALANCE_CONSTANTS\n    if (this.overrides) {\n      return {\n        ...base,\n        CARD_LIMITS: { ...base.CARD_LIMITS, ...this.overrides.cardLimits },\n        CHALLENGE_SETTINGS: { ...base.CHALLENGE_SETTINGS, ...this.overrides.challengeSettings },\n        VITALITY_SETTINGS: { ...base.VITALITY_SETTINGS, ...this.overrides.vitalitySettings },\n        PROGRESSION_SETTINGS: { ...base.PROGRESSION_SETTINGS, ...this.overrides.progressionSettings }\n      }\n    }\n    return base\n  }\n\n  /**\n   * パフォーマンス設定を取得\n   */\n  static getPerformanceSettings() {\n    return PERFORMANCE_CONSTANTS\n  }\n}\n\n/**\n * 定数の検証ユーティリティ\n */\nexport class ConstantsValidator {\n  /**\n   * 活力値が有効範囲内かチェック\n   */\n  static isValidVitality(value: number): boolean {\n    return value >= BALANCE_CONSTANTS.VITALITY_SETTINGS.minimumValue &&\n      value <= BALANCE_CONSTANTS.VITALITY_SETTINGS.maximumValue\n  }\n\n  /**\n   * ターン数が有効範囲内かチェック\n   */\n  static isValidTurn(turn: number): boolean {\n    return turn >= 0 && turn <= BALANCE_CONSTANTS.PROGRESSION_SETTINGS.maxTurns\n  }\n\n  /**\n   * 手札サイズが有効範囲内かチェック\n   */\n  static isValidHandSize(size: number): boolean {\n    return size >= 0 && size <= BALANCE_CONSTANTS.CARD_LIMITS.maxHandSize\n  }\n\n  /**\n   * チャレンジ難易度が有効範囲内かチェック\n   */\n  static isValidDifficulty(difficulty: number): boolean {\n    return difficulty >= BALANCE_CONSTANTS.CHALLENGE_SETTINGS.minDifficulty &&\n      difficulty <= BALANCE_CONSTANTS.CHALLENGE_SETTINGS.maxDifficulty\n  }\n}","import type { GameStage } from '../types/card.types'\nimport { GameConstantsAccessor } from '../constants/GameConstants'\n\n/**\n * ゲームステージ管理サービス\n * \n * ゲームのステージ進行ロジックを管理する単一責任クラス\n */\nexport class GameStageManager {\n  /**\n   * ターン数に基づいてステージ進行をチェックし、必要に応じて更新\n   * @param currentStage 現在のステージ\n   * @param turn 現在のターン数\n   * @returns 新しいステージ（変更がない場合は元のステージ）\n   */\n  checkStageProgression(currentStage: GameStage, turn: number): {\n    newStage: GameStage\n    hasChanged: boolean\n    transitionMessage?: string\n    upcomingTransition?: string\n  } {\n    const oldStage = currentStage\n    let newStage = currentStage\n\n    const settings = GameConstantsAccessor.getBalanceSettings().PROGRESSION_SETTINGS.stageTransitionTurns\n\n    if (turn >= settings.youthToMiddle && currentStage === 'youth') {\n      newStage = 'middle'\n    } else if (turn >= settings.middleToFulfillment && currentStage === 'middle') {\n      newStage = 'fulfillment'\n    }\n\n    const hasChanged = oldStage !== newStage\n    const transitionMessage = hasChanged\n      ? `🎯 ステージが変化しました: ${oldStage} → ${newStage} (ターン${turn})`\n      : undefined\n\n    // 次のステージ移行予告\n    const upcomingTransition = this.getUpcomingTransitionMessage(currentStage, turn)\n\n    const result: {\n      newStage: GameStage\n      hasChanged: boolean\n      transitionMessage?: string\n      upcomingTransition?: string\n    } = {\n      newStage,\n      hasChanged\n    }\n\n    if (transitionMessage) {\n      result.transitionMessage = transitionMessage\n    }\n\n    if (upcomingTransition) {\n      result.upcomingTransition = upcomingTransition\n    }\n\n    return result\n  }\n\n  /**\n   * 次のステージ移行予告メッセージを生成\n   */\n  private getUpcomingTransitionMessage(currentStage: GameStage, turn: number): string | undefined {\n    const settings = GameConstantsAccessor.getBalanceSettings().PROGRESSION_SETTINGS.stageTransitionTurns\n\n    if (currentStage === 'youth') {\n      const turnsUntilMiddle = settings.youthToMiddle - turn\n      if (turnsUntilMiddle <= 2 && turnsUntilMiddle > 0) {\n        return `⏰ 中年期まであと${turnsUntilMiddle}ターン (体力上限が${this.getStageVitalityLimit('middle')}に減少)`\n      }\n    } else if (currentStage === 'middle') {\n      const turnsUntilFulfillment = settings.middleToFulfillment - turn\n      if (turnsUntilFulfillment <= 2 && turnsUntilFulfillment > 0) {\n        return `⏰ 充実期まであと${turnsUntilFulfillment}ターン (体力上限が${this.getStageVitalityLimit('fulfillment')}に減少)`\n      }\n    }\n    return undefined\n  }\n\n  /**\n   * ステージ別の体力上限を取得\n   */\n  private getStageVitalityLimit(stage: GameStage): number {\n    const params = GameConstantsAccessor.getStageParameters(stage)\n    // Fallback if something is wrong, though accessor usually handles defaults\n    return params ? params.maxVitality : 60\n  }\n\n  /**\n   * ステージ進行条件を取得（透明化）\n   */\n  static getStageTransitionInfo(): {\n    youthToMiddle: number\n    middleToFulfillment: number\n    description: string\n  } {\n    const settings = GameConstantsAccessor.getBalanceSettings().PROGRESSION_SETTINGS.stageTransitionTurns\n    return {\n      youthToMiddle: settings.youthToMiddle,\n      middleToFulfillment: settings.middleToFulfillment,\n      description: `青年期→中年期: ターン${settings.youthToMiddle}, 中年期→充実期: ターン${settings.middleToFulfillment}`\n    }\n  }\n\n  /**\n   * 現在のステージ情報を詳細に取得\n   */\n  static getStageDetails(stage: GameStage, turn: number): {\n    stageName: string\n    description: string\n    vitalityLimit: number\n    characteristics: string[]\n    nextTransition?: { targetStage: string, atTurn: number, turnsRemaining: number }\n  } {\n    const stageInfo = {\n      youth: {\n        stageName: '青年期',\n        description: '体力は充実しているが経験不足',\n        vitalityLimit: 35,\n        characteristics: ['高い体力上限', '経験による効率化なし', '基本的なチャレンジが多い']\n      },\n      middle: {\n        stageName: '中年期',\n        description: '体力は落ちるが経験豊富',\n        vitalityLimit: 30,\n        characteristics: ['中程度の体力上限', '経験による効率化開始', '複雑なチャレンジ増加']\n      },\n      fulfillment: {\n        stageName: '充実期',\n        description: '体力は限られるが知恵と余裕',\n        vitalityLimit: 27,\n        characteristics: ['低い体力上限', '高い経験による効率化', '知識系チャレンジ有利']\n      }\n    }\n\n    const info = stageInfo[stage]\n    const settings = GameConstantsAccessor.getBalanceSettings().PROGRESSION_SETTINGS.stageTransitionTurns\n\n    let nextTransition\n    if (stage === 'youth') {\n      const turnsRemaining = settings.youthToMiddle - turn\n      if (turnsRemaining > 0) {\n        nextTransition = {\n          targetStage: '中年期',\n          atTurn: settings.youthToMiddle,\n          turnsRemaining\n        }\n      }\n    } else if (stage === 'middle') {\n      const turnsRemaining = settings.middleToFulfillment - turn\n      if (turnsRemaining > 0) {\n        nextTransition = {\n          targetStage: '充実期',\n          atTurn: settings.middleToFulfillment,\n          turnsRemaining\n        }\n      }\n    }\n\n    const result: {\n      stageName: string\n      description: string\n      vitalityLimit: number\n      characteristics: string[]\n      nextTransition?: { targetStage: string, atTurn: number, turnsRemaining: number }\n    } = {\n      ...info\n    }\n\n    if (nextTransition) {\n      result.nextTransition = nextTransition\n    }\n\n    return result\n  }\n\n  /**\n   * 手動でステージを進める\n   * @param currentStage 現在のステージ\n   * @returns 次のステージと完了状態\n   */\n  advanceStage(currentStage: GameStage): {\n    newStage: GameStage | null\n    isCompleted: boolean\n  } {\n    switch (currentStage) {\n      case 'youth':\n        return { newStage: 'middle', isCompleted: false }\n      case 'middle':\n        return { newStage: 'fulfillment', isCompleted: false }\n      case 'fulfillment':\n        return { newStage: null, isCompleted: true }\n      default:\n        return { newStage: null, isCompleted: true }\n    }\n  }\n\n  /**\n   * 指定されたステージが最終ステージかどうか判定\n   */\n  isFinalStage(stage: GameStage): boolean {\n    return stage === 'fulfillment'\n  }\n}","import type { Card } from '../entities/Card'\nimport type { InsuranceExpirationNotice } from '../types/game.types'\n\n/**\n * 保険期限管理サービス\n * \n * 保険カードの期限切れ処理を専門に扱う単一責任クラス\n */\nexport class InsuranceExpirationManager {\n  private static readonly EXPIRING_SOON_THRESHOLD = 2\n\n  /**\n   * 定期保険の期限を更新し、期限切れをチェック\n   * @param insuranceCards 現在有効な保険カード配列（変更される）\n   * @param expiredInsurances 期限切れ保険カード配列（変更される）\n   * @param currentTurn 現在のターン数\n   * @returns 期限切れ通知（期限切れがない場合はundefined）\n   */\n  updateInsuranceExpirations(\n    insuranceCards: Card[], \n    expiredInsurances: Card[], \n    currentTurn: number\n  ): InsuranceExpirationNotice | undefined {\n    // 期限切れになった保険を一時的に保存\n    const nowExpired: Card[] = []\n    \n    // 全ての保険カードの期限を更新\n    insuranceCards.forEach(card => {\n      if (card.isTermInsurance()) {\n        card.decrementTurn()\n        \n        // 期限切れになったものを記録\n        if (card.isExpired()) {\n          nowExpired.push(card)\n        }\n      }\n    })\n    \n    // 期限切れの保険を active から expired に移動\n    if (nowExpired.length > 0) {\n      // 期限切れカードを保険カード配列から削除\n      nowExpired.forEach(expiredCard => {\n        const index = insuranceCards.findIndex(card => card.id === expiredCard.id)\n        if (index !== -1) {\n          insuranceCards.splice(index, 1)\n        }\n      })\n      \n      // 期限切れ配列に追加\n      expiredInsurances.push(...nowExpired)\n      \n      // 期限切れ通知を作成\n      return this.createExpirationNotice(nowExpired, currentTurn)\n    }\n    \n    return undefined\n  }\n\n  /**\n   * 期限が近い保険カードを取得（残り指定ターン以下）\n   */\n  getExpiringSoonInsurances(insuranceCards: Card[]): Card[] {\n    return insuranceCards.filter(card => \n      card.isTermInsurance() && \n      card.remainingTurns !== undefined && \n      card.remainingTurns <= InsuranceExpirationManager.EXPIRING_SOON_THRESHOLD && \n      card.remainingTurns > 0\n    )\n  }\n\n  /**\n   * 保険期限切れの警告メッセージを取得\n   */\n  getExpirationWarnings(insuranceCards: Card[]): string[] {\n    const expiringSoon = this.getExpiringSoonInsurances(insuranceCards)\n    return expiringSoon.map(card => \n      `⚠️ 「${card.name}」の期限まであと${card.remainingTurns}ターンです`\n    )\n  }\n\n  /**\n   * 期限切れ通知を作成\n   * @private\n   */\n  private createExpirationNotice(expiredCards: Card[], turnNumber: number): InsuranceExpirationNotice {\n    const expiredNames = expiredCards.map(card => card.name).join('、')\n    const message = expiredCards.length === 1 \n      ? `定期保険「${expiredNames}」の期限が切れました。`\n      : `定期保険${expiredCards.length}件（${expiredNames}）の期限が切れました。`\n    \n    return {\n      expiredCards,\n      message,\n      showRenewalOption: true, // 将来的に更新オプションを実装するため\n      turnNumber\n    }\n  }\n}","import type { Difficulty, GameStage, InsuranceType, ICard, InsuranceTriggerType } from './card.types'\nexport type { ICard }\nimport type { Card } from '../entities/Card'\nimport type { Deck } from '../entities/Deck'\n\n/**\n * ゲーム状態\n */\nexport type GameStatus =\n  | 'not_started'\n  | 'in_progress'\n  | 'stage_clear'\n  | 'game_over'\n  | 'victory'\n\n/**\n * ゲームフェーズ\n */\nexport type GamePhase =\n  | 'setup'                    // セットアップ\n  | 'character_selection'      // キャラクター選択 (v2)\n  | 'dream_selection'          // 夢選択 (v2)\n  | 'draw'                     // ドロー\n  | 'challenge_choice'         // チャレンジ選択 (v2)\n  | 'challenge'                // チャレンジ\n  | 'resolution'               // 結果処理\n  | 'card_selection'           // カード選択（チャレンジ成功時）\n  | 'insurance_type_selection' // 保険種類選択（チャレンジ成功時）\n  | 'upgrade'                  // アップグレード（ステージクリア時）\n  | 'end'                     // 終了\n\n/**\n * プレイヤー統計\n */\nexport interface PlayerStats {\n  totalChallenges: number\n  successfulChallenges: number\n  failedChallenges: number\n  cardsAcquired: number\n  highestVitality: number\n  turnsPlayed: number\n  // 分析・テスト用の追加統計\n  totalTurns?: number\n  score?: number\n  challengesCompleted?: number\n  challengesFailed?: number\n  finalVitality?: number\n  finalInsuranceBurden?: number\n}\n\n/**\n * ゲーム設定\n */\nexport interface GameConfig {\n  difficulty: Difficulty\n  startingVitality: number\n  startingHandSize: number\n  maxHandSize: number\n  dreamCardCount: number // 最終試練で選ぶ夢カードの数\n  // テスト・分析用の追加設定\n  maxTurns?: number\n  // バランス調整設定\n  balanceConfig?: BalanceConfig\n  characterId?: string // 選択されたキャラクターID\n}\n\n/**\n * キャラクター定義\n */\nexport interface Character {\n  id: string\n  name: string\n  description: string\n  initialVitalityModifier: number\n  initialSavings?: number\n  specialAbility: string\n}\n\n/**\n * 利用可能なキャラクターリスト\n */\nexport const AVAILABLE_CHARACTERS: Character[] = [\n  {\n    id: 'solid',\n    name: '堅実家',\n    description: '守り重視。初期活力が高く、保険の効果が高い。',\n    initialVitalityModifier: 20,  // 貯蓄ボーナスの代わりに活力ボーナスを増加\n    specialAbility: 'insurance_bonus'  // 貯蓄ボーナスから保険ボーナスに変更\n  },\n  {\n    id: 'adventurer',\n    name: '冒険家',\n    description: 'リスク志向。初期活力は低いが、チャンスに強い。',\n    initialVitalityModifier: -5,\n    specialAbility: 'risk_taker'\n  },\n  {\n    id: 'minimalist',\n    name: 'ミニマリスト',\n    description: '効率重視。バランスの取れた生活スタイル。',\n    initialVitalityModifier: 10,\n    specialAbility: 'efficiency'\n  }\n]\n\n/**\n * バランス調整設定\n * GameConstantsの値を上書きするための設定\n */\nexport interface BalanceConfig {\n  stageParameters?: {\n    youth?: Partial<AgeParameters & { startTurn: number, endTurn: number, insuranceMultiplier: number, challengeDifficultyModifier: number }>\n    middle?: Partial<AgeParameters & { startTurn: number, endTurn: number, insuranceMultiplier: number, challengeDifficultyModifier: number }>\n    fulfillment?: Partial<AgeParameters & { startTurn: number, endTurn: number, insuranceMultiplier: number, challengeDifficultyModifier: number }>\n  }\n  vitalitySettings?: {\n    defaultStarting?: number\n    minimumValue?: number\n    maximumValue?: number\n    healingCap?: number\n  }\n  cardLimits?: {\n    maxHandSize?: number\n    startingHandSize?: number\n    defaultDrawCount?: number\n    maxDeckSize?: number\n  }\n  challengeSettings?: {\n    minDifficulty?: number\n    maxDifficulty?: number\n    successBonusBase?: number\n    failurePenaltyRatio?: number\n    enableDynamicDifficulty?: boolean\n  }\n  progressionSettings?: {\n    maxTurns?: number\n    stageTransitionTurns?: {\n      youthToMiddle: number\n      middleToFulfillment: number\n    }\n    victoryConditions?: {\n      minTurns?: number\n      minVitality?: number\n    }\n  }\n}\n\n/**\n * 保険種類選択肢\n */\nexport interface InsuranceTypeChoice {\n  insuranceType: InsuranceType\n  name: string\n  description: string\n  baseCard: Omit<ICard, 'id' | 'durationType' | 'remainingTurns'>\n  termOption: {\n    cost: number\n    duration: number // ターン数\n    description: string\n  }\n  wholeLifeOption: {\n    cost: number\n    description: string\n  }\n}\n\n/**\n * チャレンジ結果タイプ\n * - success: チャレンジ成功（報酬獲得）\n * - damage_taken: パワー不足でダメージを受けた\n */\nexport type ChallengeResultType = 'success' | 'damage_taken' | 'error'\n\n/**\n * チャレンジ結果\n */\nexport interface ChallengeResult {\n  challenge: Card\n  success: boolean\n  resultType: ChallengeResultType  // 成功 or ダメージ受容\n  playerPower: number\n  challengePower: number\n  rewards?: Card[]\n  cardChoices?: Card[]  // カード選択肢（3枚）\n  insuranceTypeChoices?: InsuranceTypeChoice[]  // 保険種類選択肢（3種類）\n  vitalityChange: number\n  damageAmount?: number  // ダメージ量（damage_taken時のみ）\n  message: string\n  // Phase 3: パワー計算の詳細\n  powerBreakdown?: {\n    base: number\n    insurance: number\n    burden: number\n    total: number\n  }\n}\n\n/**\n * 保険期限切れ通知\n */\nexport interface InsuranceExpirationNotice {\n  expiredCards: Card[]\n  message: string\n  showRenewalOption: boolean\n  turnNumber: number\n}\n\n/**\n * ターン結果（期限切れ通知を含む）\n */\nexport interface TurnResult {\n  insuranceExpirations?: InsuranceExpirationNotice\n  newExpiredCount: number\n  remainingInsuranceCount: number\n}\n\n/**\n * 保険種類選択結果\n */\nexport interface InsuranceTypeSelectionResult {\n  success: boolean\n  selectedCard?: Card\n  message: string\n}\n\n/**\n * ゲーム状態\n */\n/**\n * 年齢別パラメータ\n */\nexport interface AgeParameters {\n  maxVitality: number\n  label: string\n  ageMultiplier: number  // 保険効果の年齢倍率\n}\n\n/**\n * 年齢別設定\n */\nexport const AGE_PARAMETERS: Record<string, AgeParameters> = {\n  youth: {\n    maxVitality: 25,\n    label: '青年期',\n    ageMultiplier: 0\n  },\n  middle: {\n    maxVitality: 20,\n    label: '中年期',\n    ageMultiplier: 0.5\n  },\n  middle_age: {\n    maxVitality: 20,\n    label: '中年期',\n    ageMultiplier: 0.5\n  },\n  fulfillment: {\n    maxVitality: 15,\n    label: '充実期',\n    ageMultiplier: 1.0\n  }\n}\n\n/**\n * 夢カードの年齢調整値\n */\nexport const DREAM_AGE_ADJUSTMENTS = {\n  physical: 3,      // 体力系：年齢で+3パワー必要\n  intellectual: -2, // 知識系：年齢で-2パワー\n  mixed: 0         // 複合系：変化なし\n}\n\n\n\n\n/**\n * 保留中の保険請求情報\n */\nexport interface PendingInsuranceClaim {\n  insurance: Card\n  triggerType: InsuranceTriggerType\n  context?: any\n}\n\nexport interface IGameState {\n  id: string\n  status: GameStatus\n  phase: GamePhase\n  stage: GameStage\n  turn: number\n  vitality: number\n  maxVitality: number\n\n  // デッキ関連\n  playerDeck: Deck\n  hand: Card[]\n  discardPile: Card[]\n  challengeDeck: Deck\n\n  // チャレンジ関連\n  currentChallenge: Card | undefined\n  selectedCards: Card[]\n  cardChoices: Card[] | undefined  // 現在の選択肢カード\n  insuranceTypeChoices: InsuranceTypeChoice[] | undefined  // 現在の保険種類選択肢\n  pendingInsuranceClaim: PendingInsuranceClaim | undefined // 保留中の保険請求\n\n  // Phase 2-4: 保険カード管理\n  activeInsurances: Card[]  // 現在有効な保険カード (renamed from insuranceCards)\n  expiredInsurances: Card[] | undefined  // 期限切れになった保険カード\n  insuranceMarket: Card[]     // 保険市場（販売中の保険）\n\n  // Phase 3: 保険料負担\n  insuranceBurden?: number  // 保険料による負担（負の値）\n\n  // v2: 新要素\n  agingDeck: Deck\n  score: number             // 現在のスコア\n  selectedDream: Card | undefined      // 選択した夢カード (DreamCard)\n\n  // 統計\n  stats: PlayerStats\n\n  // 設定\n  config: GameConfig\n\n  // タイムスタンプ\n  startedAt?: Date\n  completedAt?: Date\n}\n","import type { Card } from '../entities/Card'\nimport type { GameStage } from '../types/card.types'\nimport type { ChallengeResult } from '../types/game.types'\nimport type { ICardManager } from './CardManager'\nimport type { Game } from '../entities/Game'\nimport { RiskRewardChallenge } from '../entities/RiskRewardChallenge'\nimport { AGE_PARAMETERS, DREAM_AGE_ADJUSTMENTS } from '../types/game.types'\nimport { MAX_TOTAL_DAMAGE_REDUCTION, MINIMUM_DAMAGE_AFTER_INSURANCE } from '../constants/insurance.constants'\nimport { GameConstantsAccessor } from '../constants/GameConstants'\n\n/**\n * チャレンジ解決サービス\n * \n * チャレンジの解決ロジックを専門に扱う単一責任クラス\n */\nexport class ChallengeResolutionService {\n  /**\n   * チャレンジを解決し、結果を計算\n   * @param challenge チャレンジカード\n   * @param selectedCards 選択されたカード\n   * @param cardManager カード管理サービス\n   * @param stage 現在のゲームステージ\n   * @param insuranceBurden 保険料負担\n   * @param game ゲームエンティティ（保険情報取得用）\n   * @returns チャレンジ結果\n   */\n  resolveChallenge(\n    challenge: Card,\n    selectedCards: Card[],\n    cardManager: ICardManager,\n    stage: GameStage,\n    insuranceBurden: number,\n    game?: Game\n  ): ChallengeResult {\n    // リスクチャレンジの特殊ルール確認\n    const isRiskChallenge = challenge instanceof RiskRewardChallenge\n    const insuranceImmunity = isRiskChallenge && challenge.insuranceImmunity\n\n    // 保険効果（特化型ボーナス）\n    const insuranceBonus = (game && !insuranceImmunity) ? this.calculateInsuranceBonus(game, challenge) : 0\n\n    // パワー計算\n    const powerBreakdown = this.calculateTotalPower(selectedCards, insuranceBurden, insuranceBonus)\n    const playerPower = powerBreakdown.total\n\n    // 夢カードの年齢調整\n    const challengePower = this.getDreamRequiredPower(challenge, stage)\n\n    // 成功判定\n    const success = playerPower >= challengePower\n\n    let vitalityChange = 0\n    let message = ''\n    let damageAmount: number | undefined\n\n    if (success) {\n      // 成功時: 基本報酬 + 過労ダメージ計算\n      const bonusBase = GameConstantsAccessor.getBalanceSettings().CHALLENGE_SETTINGS.successBonusBase\n      const powerDiff = playerPower - challengePower\n\n      // V3変更: 「惜しい」判定廃止のため、過剰パワーは「過労」としてペナルティ\n      // 報酬は固定（+5）などにするか、差分ボーナスを残すか？\n      // ユーザー要望「達成できても超過していれば超過分/5の切り捨てを受ける」\n      // 報酬計算は従来の「基本+差分/2」だと過労と相殺してプラスになる可能性が高い。\n      // ここはシンプルに「基本報酬のみ」にして、過労を引く形が美しいか？\n      // いったん「基本報酬」のみにします。\n      const baseReward = bonusBase // 差分ボーナス撤廃\n\n      // 過労ダメージ計算\n      // V3.1 Balance: Increase overwork penalty to punish inefficient play (Beginner).\n      // Overflow / 2 (was 5).\n      const overworkDamage = Math.floor(powerDiff / 2)\n\n      // 過労ダメージも保険で軽減可能（医療保険など）\n      const damageReduction = (game && !insuranceImmunity) ? this.calculateDamageReduction(game) : 0\n      const finalOverworkDamage = Math.max(0, overworkDamage - damageReduction)\n\n      vitalityChange = baseReward - finalOverworkDamage\n\n      message = `🎉 チャレンジ成功！ (+${baseReward})`\n      if (finalOverworkDamage > 0) {\n        message += ` しかし頑張りすぎて疲れた... (-${finalOverworkDamage})`\n      } else if (overworkDamage > 0 && finalOverworkDamage === 0) {\n        message += ` (保険が過労を防いだ！)`\n      }\n    } else {\n      // 失敗時: V3ルール「不足分関係なく、右上の値を丸ごと受ける」\n      // 固定ダメージ = チャレンジパワー\n      const baseDamage = challengePower\n\n      // 保険軽減\n      const damageReduction = (game && !insuranceImmunity) ? this.calculateDamageReduction(game) : 0\n\n      // 最小ダメージ保証（どんなに軽減しても1は食らう、ただし完全無効化スキルがあれば別だが現状は1）\n      const finalDamage = Math.max(MINIMUM_DAMAGE_AFTER_INSURANCE, baseDamage - damageReduction)\n\n      // 夢（大ダメージ）に対する特殊防御（がん保険など）のロジックは\n      // calculateDamageReductionに含めるか、ここで別途判定するか？\n      // 現状のCardロジックでは「軽減量」を返すので、\n      // 20以上のときに軽減量を20にする、などの実装がCard側で必要。\n      // いったんそのまま計算。\n\n      vitalityChange = -finalDamage\n      damageAmount = finalDamage\n      message = `💥 失敗... ${finalDamage} のダメージを受けた`\n    }\n\n    // カード破棄\n    cardManager.discardSelectedCards()\n\n    // リスクチャレンジの場合の補正（もしあれば）\n    if (isRiskChallenge) {\n      // リスクチャレンジの計算ロジックを優先する場合ここに戻す必要あり\n      // 現状はV3ルール優先\n    }\n\n    // 結果作成\n    const result: ChallengeResult = {\n      challenge,\n      success,\n      resultType: success ? 'success' : 'damage_taken',\n      playerPower,\n      challengePower,\n      vitalityChange,\n      message,\n      powerBreakdown\n    }\n\n    // ダメージ量は damage_taken 時のみ設定\n    if (!success && damageAmount !== undefined) {\n      result.damageAmount = damageAmount\n    }\n\n    return result\n  }\n\n  /**\n   * 総合パワーを詳細に計算\n   * @param cards 使用するカード\n   * @param insuranceBurden 保険料負担\n   * @param insuranceBonus 保険ボーナス\n   * @returns パワーの詳細な内訳\n   */\n  private calculateTotalPower(cards: Card[], insuranceBurden: number, insuranceBonus: number = 0): {\n    base: number\n    insurance: number\n    burden: number\n    total: number\n  } {\n    // 基本パワー（保険以外のカード）\n    let basePower = 0\n    let insurancePower = 0\n\n    cards.forEach(card => {\n      if (card.type === 'insurance') {\n        // 保険カードのパワー（年齢ボーナス込み）\n        insurancePower += card.calculateEffectivePower()\n      } else {\n        // その他のカードの基本パワー\n        basePower += card.calculateEffectivePower()\n      }\n    })\n\n    // 保険ボーナスを保険パワーに加算\n    insurancePower += insuranceBonus\n\n    // 総合パワー\n    const total = basePower + insurancePower - insuranceBurden\n\n    return {\n      base: basePower,\n      insurance: insurancePower,\n      burden: -insuranceBurden, // 負の値として表示\n      total: Math.max(0, total) // 総合パワーは0以下にならない\n    }\n  }\n\n  /**\n   * 夢カードの必要パワーを年齢調整込みで計算\n   */\n  private getDreamRequiredPower(challenge: Card, stage: GameStage): number {\n    // 夢カードでない場合は基本パワーをそのまま返す\n    // NOTE: 通常のチャレンジでもdreamCategory（身体的/知識的）が設定されていれば年齢調整を適用する\n    if (!challenge.dreamCategory) {\n      return challenge.power\n    }\n\n    // 青年期は調整なし\n    if (stage === 'youth') {\n      return challenge.power\n    }\n\n    // 中年期・充実期の年齢調整を適用（GAME_DESIGN.md準拠）\n    // Physical: +3, Intellectual: -2, Mixed: 0\n    // @ts-ignore\n    const adjustment = DREAM_AGE_ADJUSTMENTS[challenge.dreamCategory] || 0\n    const adjustedPower = challenge.power + adjustment\n\n    // 最小値は1\n    return Math.max(1, adjustedPower)\n  }\n\n  /**\n   * 保険によるチャレンジボーナスを計算\n   * @private\n   */\n  private calculateInsuranceBonus(game: Game, challenge: Card): number {\n    let totalBonus = 0\n    const insuranceCards = game.getActiveInsurances()\n    const currentStage = game.stage\n    const ageParams = AGE_PARAMETERS[currentStage] || AGE_PARAMETERS['youth']\n    const ageMultiplier = ageParams?.ageMultiplier ?? 0\n\n    insuranceCards.forEach(insurance => {\n      // 終身保険の年齢価値上昇を適用\n      let bonus = 0\n\n      if (insurance.isSpecializedInsurance()) {\n        const challengeType = challenge.name\n        bonus = insurance.calculateChallengeBonus(challengeType)\n      }\n\n      // 終身保険の場合、年齢倍率を適用\n      if (insurance.isWholeLifeInsurance() && ageMultiplier > 0) {\n        bonus += ageMultiplier  // 中年期+0.5、充実期+1.0\n      }\n\n      totalBonus += bonus\n    })\n\n    return totalBonus\n  }\n\n  /**\n   * 防御型保険によるダメージ軽減を計算\n   * Issue #24: 複数保険の合計軽減量にも上限を設定\n   * @private\n   */\n  private calculateDamageReduction(game: Game): number {\n    let totalReduction = 0\n    const insuranceCards = game.getActiveInsurances()\n\n    insuranceCards.forEach(insurance => {\n      // calculateDamageReduction内で防御効果のチェックを行うため、\n      // 全ての保険カードで計算を実行\n      totalReduction += insurance.calculateDamageReduction()\n    })\n\n    // 合計軽減量の上限を適用\n    return Math.min(totalReduction, MAX_TOTAL_DAMAGE_REDUCTION)\n  }\n}","/**\n * ゲームターン管理サービス\n * \n * Game.tsから分離されたターン管理の責任を持つ\n * \n * @class GameTurnManager\n * @description\n * ゲームのターン進行に関するすべてのロジックを管理します。\n * ステージ進行、保険期限管理、ターン開始時のドローなどを担当します。\n * \n * @example\n * ```typescript\n * const turnManager = new GameTurnManager(stageManager, expirationManager);\n * const result = turnManager.nextTurn(game);\n * console.log(`Turn ${game.turn} - Expired insurances: ${result.newExpiredCount}`);\n * ```\n */\n\nimport type { Game } from '../entities/Game'\nimport type { TurnResult } from '../types/game.types'\nimport type { GameStageManager } from './GameStageManager'\nimport type { InsuranceExpirationManager } from './InsuranceExpirationManager'\n\nexport class GameTurnManager {\n  constructor(\n    private readonly stageManager: GameStageManager,\n    private readonly expirationManager: InsuranceExpirationManager\n  ) { }\n\n  /**\n   * 次のターンへ進める\n   * \n   * @method nextTurn\n   * @param {Game} game - ゲームインスタンス\n   * @returns {TurnResult} ターン結果（期限切れ保険情報を含む）\n   * @throws {Error} ゲームが進行中でない場合\n   * \n   * @description\n   * 1. ゲーム状態を検証\n   * 2. ターン数をインクリメント\n   * 3. ステージ進行をチェック\n   * 4. 保険期限を更新\n   * 5. カードをドロー\n   */\n  nextTurn(game: Game): TurnResult {\n    this.validateGameState(game)\n\n    // 手札をすべて捨て札に移動 (デッキ構築ゲームの基本ルール)\n    game.cardManager.discardHand()\n\n    game.turn++\n    game.stats.turnsPlayed++\n    game.phase = 'draw'\n\n    // ステージ進行の判定\n    this.checkStageProgression(game)\n\n    // 勝利条件のチェック\n    this.checkVictoryCondition(game)\n    if (game.status === 'victory') {\n      return {\n        newExpiredCount: 0,\n        remainingInsuranceCount: game.getActiveInsurances().length\n      }\n    }\n\n    // 保険期限の更新\n    const expirationResult = this.updateInsuranceExpirations(game)\n\n    // 保険料の支払い logic (GameTurnManager or Game entity responsibility)\n    const insuranceCost = game.insuranceBurden\n    if (insuranceCost > 0) {\n      // 活力が足りる場合のみ支払う\n      if (game.vitality > insuranceCost) {\n        try {\n          game.applyDamage(insuranceCost)\n          console.log(`💸 保険料支払い: -${insuranceCost} 活力`)\n        } catch (e) {\n          console.error('保険料支払いに失敗しました', e)\n        }\n      } else {\n        // 払えない場合は保険失効（即死はさせない）\n        console.warn(`⚠️ 保険料(${insuranceCost})を支払う活力が不足しています。全ての保険が失効します。`)\n\n        // 全ての有効な保険を失効させる\n        game.expireAllInsurances()\n\n        // ユーザーにお知らせ（Gameエンティティに通知機能があれば呼ぶが、ここではログのみ）\n      }\n    }\n\n    // Check if game ended due to insurance cost\n    if (game.status === 'game_over') {\n      return {\n        newExpiredCount: expirationResult?.expiredCards.length || 0,\n        remainingInsuranceCount: game.getActiveInsurances().length\n      }\n    }\n\n    // ターン開始時のドローは行わない\n    // v2: 課題選択後にドローする仕様（ドキドキ感のため）\n    // GameController / gameStore でチャレンジ選択後に drawCards(7) を呼ぶ\n\n    // 回復型保険の効果を適用\n    this.applyRecoveryInsuranceEffects(game)\n\n    return {\n      ...(expirationResult ? { insuranceExpirations: expirationResult } : {}),\n      newExpiredCount: expirationResult?.expiredCards.length || 0,\n      remainingInsuranceCount: game.getActiveInsurances().length\n    }\n  }\n\n  /**\n   * 勝利条件をチェック\n   * 勝利条件: 夢チャレンジをクリアした場合のみ（Game.tsのresolveChallengeで判定）\n   * 敗北条件: 最大ターン数に達しても夢を達成できなかった場合\n   * @private\n   */\n  private checkVictoryCondition(game: Game): void {\n    // 最大ターン数（夢を達成できなければゲームオーバー）\n    // 夢達成には時間がかかるため、少し長めに設定\n    const maxTurns = 100\n\n    if (game.turn >= maxTurns && game.status !== 'victory') {\n      game.status = 'game_over'\n      game.completedAt = new Date()\n      console.log(`💔 ゲームオーバー: ${maxTurns}ターン経過しても夢を達成できませんでした`)\n    }\n\n    // Note: 夢達成はGame.tsのresolveChallenge内で判定\n  }\n\n  /**\n   * ゲーム状態の検証\n   * @private\n   */\n  private validateGameState(game: Game): void {\n    if (game.status !== 'in_progress') {\n      throw new Error('Game is not in progress')\n    }\n  }\n\n  /**\n   * ステージ進行をチェック\n   * @private\n   */\n  private checkStageProgression(game: Game): void {\n    const progressionResult = this.stageManager.checkStageProgression(\n      game.stage,\n      game.turn\n    )\n\n    if (progressionResult.hasChanged) {\n      game.setStage(progressionResult.newStage)\n\n      if (progressionResult.transitionMessage) {\n        console.log(progressionResult.transitionMessage)\n      }\n    }\n  }\n\n  /**\n   * 保険期限を更新\n   * @private\n   */\n  private updateInsuranceExpirations(game: Game) {\n    const expirationResult = this.expirationManager.updateInsuranceExpirations(\n      game.activeInsurances,\n      game.expiredInsurances,\n      game.turn\n    )\n\n    // 期限切れがあった場合は保険料負担を再計算\n    if (expirationResult) {\n      // Gameクラスのメソッドを呼び出して更新\n      // これにより、Gameクラスの内部状態の一貫性を保つ\n      (game as any).updateInsuranceBurden()\n    }\n\n    return expirationResult\n  }\n\n  /**\n   * 回復型保険の効果を適用\n   * @private\n   */\n  private applyRecoveryInsuranceEffects(game: Game): void {\n    const activeInsurances = game.getActiveInsurances()\n    let totalHeal = 0\n\n    activeInsurances.forEach(insurance => {\n      if (insurance.isRecoveryInsurance()) {\n        totalHeal += insurance.calculateTurnHeal()\n      }\n    })\n\n    if (totalHeal > 0) {\n      game.heal(totalHeal)\n      console.log(`💚 回復型保険効果: +${totalHeal} 活力`)\n    }\n  }\n}","/**\n * ゲームチャレンジ処理サービス\n * \n * チャレンジの解決に関する複雑なロジックを管理\n * \n * @class GameChallengeService\n * @description\n * チャレンジの開始から解決までの一連のプロセスを管理します。\n * パワー計算、成功判定、活力変更、統計更新などを担当します。\n * \n * @example\n * ```typescript\n * const challengeService = new GameChallengeService(resolutionService);\n * \n * // チャレンジを開始\n * challengeService.startChallenge(game, challengeCard);\n * \n * // チャレンジを解決\n * const result = challengeService.resolveChallenge(game);\n * if (result.success) {\n *   console.log('チャレンジ成功！');\n * }\n * ```\n */\n\nimport type { Card } from '../entities/Card'\nimport type { Game } from '../entities/Game'\nimport type { ChallengeResult, InsuranceTypeChoice } from '../types/game.types'\nimport { CardFactory } from './CardFactory'\nimport type { ChallengeResolutionService } from './ChallengeResolutionService'\n\n/**\n * パワー計算の内訳\n * \n * @interface PowerBreakdown\n * @property {number} base - 基本カードのパワー合計\n * @property {number} insurance - 保険カードのパワー合計\n * @property {number} burden - 保険料負担（負の値）\n * @property {number} total - 総合パワー（最小値は0）\n */\nexport interface PowerBreakdown {\n  base: number\n  insurance: number\n  burden: number\n  total: number\n}\n\nexport class GameChallengeService {\n  constructor(\n    private readonly resolutionService: ChallengeResolutionService\n  ) { }\n\n  /**\n   * チャレンジを開始\n   */\n  startChallenge(game: Game, challengeCard: Card): void {\n    this.validatePhase(game, 'draw')\n\n    game.currentChallenge = challengeCard\n    game.cardManager.clearSelection()\n    game.phase = 'challenge'\n\n    // 経験学習システム: 同じチャレンジの失敗回数を取得\n    const failureCount = game.getLearningHistory(challengeCard.name)\n    if (failureCount >= 2) {\n      // 2回目以降の失敗で必要パワー-1（経験による効率化）\n      // Card is immutable, so we create a copy with updated power\n      const newPower = Math.max(1, challengeCard.power - 1)\n      const updatedCard = challengeCard.copy({ power: newPower })\n      game.currentChallenge = updatedCard\n    }\n  }\n\n  /**\n   * チャレンジを解決\n   */\n  resolveChallenge(game: Game): ChallengeResult {\n    try {\n      this.validateChallenge(game)\n\n      // 新しいChallengeResolutionServiceを使用\n      const result = this.resolutionService.resolveChallenge(\n        game.currentChallenge!,\n        game.selectedCards,\n        game.cardManager,\n        game.stage,\n        game.insuranceBurden,\n        game\n      )\n\n      // 統計更新\n      this.updateStatistics(game, result.success)\n\n      // 活力更新\n      this.updateVitality(game, result.vitalityChange)\n\n      // 経験学習システム: 失敗時に学習履歴を更新\n      if (!result.success && game.currentChallenge) {\n        const challengeName = game.currentChallenge.name\n        const currentFailures = game.getLearningHistory(challengeName)\n        game.updateLearningHistory(challengeName, currentFailures + 1)\n\n        // 夢カードに敗北した場合のペナルティ（難易度上昇）\n        if (game.currentChallenge.isDreamCard()) {\n          console.log(`[Game] Defeated by dream: ${challengeName}. Increasing difficulty.`)\n          game.challengeDifficultyModifier += 2\n          console.log(`[Game] Difficulty modifier increased to ${game.challengeDifficultyModifier}`)\n        }\n      }\n\n      // 成功時: 保険選択肢を提示\n      if (result.success) {\n        // 夢カード達成チェック\n        if (game.currentChallenge?.type === 'dream' || (game.currentChallenge as any).isDream) {\n          console.log('[GameChallengeService] Dream fulfilled! Victory!');\n          game.finishGame(true);\n          // 勝利時は保険選択をスキップして即リターン\n          this.updateGameStateAfterChallenge(game, result);\n          return result;\n        }\n\n        const choices = CardFactory.createInsuranceTypeChoices(game.stage)\n        game.insuranceTypeChoices = choices\n        console.log('[GameChallengeService] Generated insurance choices:', game.insuranceTypeChoices?.length)\n\n        if (!game.insuranceTypeChoices || game.insuranceTypeChoices.length === 0) {\n          console.warn('[GameChallengeService] WARNING: No insurance choices generated!')\n        }\n\n        // Phase transition is handled by calling context or Game logic\n        result.insuranceTypeChoices = choices\n\n        // User Request: Omit Reward Cards explicitly.\n        // Reward generation logic has been removed to prevent deck bloat (\"パワカ\" issue)\n      }\n\n      this.updateGameStateAfterChallenge(game, result)\n\n      return result\n    } catch (error) {\n      console.error('[GameChallengeService] Fatal error resolving challenge:', error)\n      // エラー時のフォールバック結果を返す\n      return {\n        challenge: game.currentChallenge || CardFactory.createCard({\n          base: { name: 'Error', type: 'life', description: 'System Error' },\n          variant: 'default'\n        }),\n        success: false,\n        playerPower: 0,\n        challengePower: 0,\n        vitalityChange: 0,\n        message: `システムエラーが発生しました: ${error instanceof Error ? error.message : String(error)}`,\n        resultType: 'error' // エラー扱い\n      }\n    }\n  }\n\n  /**\n   * 総合パワーを計算\n   * \n   * @method calculateTotalPower\n   * @param {Game} game - ゲームインスタンス\n   * @param {Card[]} cards - 計算対象のカード配列\n   * @returns {PowerBreakdown} パワーの詳細な内訳\n   * \n   * @description\n   * 選択されたカードのパワーを計算し、保険料負担を考慮した\n   * 総合パワーを算出します。結果は常に0以上になります。\n   */\n  calculateTotalPower(game: Game, cards: Card[]): PowerBreakdown {\n    let basePower = 0\n    let insurancePower = 0\n\n    for (const card of cards) {\n      if (card.type === 'insurance') {\n        insurancePower += card.calculateEffectivePower()\n      } else {\n        basePower += card.calculateEffectivePower()\n      }\n    }\n\n    const burden = game.insuranceBurden\n    const total = Math.max(0, basePower + insurancePower + burden)\n\n    return { base: basePower, insurance: insurancePower, burden, total }\n  }\n\n  /**\n   * バリデーション: フェーズチェック\n   * @private\n   */\n  private validatePhase(game: Game, expectedPhase: string): void {\n    // v2: allow challenge_choice phase\n    if (game.phase === 'challenge_choice' && expectedPhase === 'draw') {\n      return\n    }\n\n    if (game.phase !== expectedPhase) {\n      if (expectedPhase === 'draw') {\n        throw new Error(`Can only start challenge during draw or challenge_choice phase (Current: ${game.phase})`)\n      }\n      throw new Error(`Can only perform this action during ${expectedPhase} phase (Current: ${game.phase})`)\n    }\n  }\n\n  /**\n   * バリデーション: チャレンジ存在チェック\n   * @private\n   */\n  private validateChallenge(game: Game): void {\n    if (!game.currentChallenge || game.phase !== 'challenge') {\n      throw new Error('No active challenge to resolve')\n    }\n  }\n\n  /**\n   * 統計を更新\n   * @private\n   */\n  private updateStatistics(game: Game, success: boolean): void {\n    game.stats.totalChallenges++\n    if (success) {\n      game.stats.successfulChallenges++\n      // challengesCompletedも更新（テストでの期待値対応）\n      if (!game.stats.challengesCompleted) {\n        game.stats.challengesCompleted = 0\n      }\n      game.stats.challengesCompleted++\n    } else {\n      game.stats.failedChallenges++\n      // challengesFailedも更新（統計の整合性確保）\n      if (!game.stats.challengesFailed) {\n        game.stats.challengesFailed = 0\n      }\n      game.stats.challengesFailed++\n    }\n  }\n\n  /**\n   * 活力を更新\n   * @private\n   */\n  private updateVitality(game: Game, change: number): void {\n    if (change >= 0) {\n      game.heal(change)\n    } else {\n      const damage = -change\n\n      // 医療保険トリガーチェック (ダメージ10以上)\n      if (damage >= 10) {\n        const insurance = game.activeInsurances.find(c => c.insuranceTriggerType === 'on_heavy_damage')\n        if (insurance) {\n          game.triggerInsuranceClaim(insurance, 'on_heavy_damage')\n          if (game.pendingInsuranceClaim) {\n            game.pendingInsuranceClaim.context = { damage }\n            return // ダメージ適用を保留\n          }\n        }\n      }\n\n      game.applyDamage(damage)\n    }\n  }\n\n  /**\n   * チャレンジ後のゲーム状態更新\n   * @private\n   */\n  private updateGameStateAfterChallenge(\n    game: Game,\n    result: ChallengeResult\n  ): void {\n    // 使用したカードを捨て札に\n    game.cardManager.discardSelectedCards()\n\n    // フェーズ更新\n    game.phase = result.success\n      ? 'insurance_type_selection'\n      : 'resolution'\n\n    // チャレンジをクリア\n    game.currentChallenge = undefined\n    game.cardManager.clearSelection()\n  }\n}","/**\n * 保険管理サービス\n * \n * 保険関連の処理を集約\n */\n\nimport type { Card } from '../entities/Card'\nimport type { Game } from '../entities/Game'\nimport type { InsuranceTypeSelectionResult } from '../types/game.types'\nimport { CardFactory } from './CardFactory'\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\nimport type { InsurancePremiumCalculationService } from './InsurancePremiumCalculationService'\n\nexport class GameInsuranceService {\n  constructor(\n    private readonly premiumService: InsurancePremiumCalculationService\n  ) { }\n\n  /**\n   * 保険を追加\n   */\n  addInsurance(game: Game, card: Card): void {\n    if (!card.isInsurance()) {\n      throw new Error('Only insurance cards can be added')\n    }\n\n    game.activeInsurances.push(card)\n    this.updateInsuranceBurden(game)\n  }\n\n  /**\n   * 保険を解約・削除\n   */\n  removeInsurance(game: Game, card: Card): void {\n    // GameのactiveInsurancesから削除\n    const index = game.activeInsurances.findIndex(c => c.id === card.id)\n    if (index !== -1) {\n      game.activeInsurances.splice(index, 1)\n    }\n\n    // デッキ/手札/捨て札から削除\n    game.cardManager.removeCardFromGame(card)\n\n    // 保険料再計算\n    this.updateInsuranceBurden(game)\n  }\n\n  /**\n   * 保険種類を選択\n   */\n  selectInsuranceType(\n    game: Game,\n    insuranceType: string,\n    durationType: 'term' | 'whole_life'\n  ): InsuranceTypeSelectionResult {\n    this.validateInsuranceSelection(game)\n\n    const choice = this.findInsuranceChoice(game, insuranceType)\n    if (!choice) {\n      return {\n        success: false,\n        message: 'Invalid insurance type selection'\n      }\n    }\n\n    const selectedCard = this.createInsuranceCard(choice, durationType)\n\n    this.addInsuranceCard(game, selectedCard)\n    this.updatePlayerHistory(game, insuranceType)\n    this.updateRiskProfile(game)\n    this.completeInsuranceSelection(game)\n\n    return this.createSelectionResult(selectedCard, choice, durationType)\n  }\n\n  /**\n   * 保険料負担を計算\n   */\n  calculateInsuranceBurden(game: Game): number {\n    if (game.activeInsurances.length === 0) {\n      return 0\n    }\n\n\n\n    try {\n      const totalBurden = this.premiumService.calculateTotalInsuranceBurden(\n        game.activeInsurances,\n        game.stage,\n        game.getRiskProfile()\n      )\n\n      // 負の値として返す（活力から差し引かれるため）\n      return -totalBurden.getValue()\n    } catch (error) {\n      // テスト環境では期待される挙動なのでエラーログを抑制\n      if (process.env['NODE_ENV'] !== 'test') {\n        console.warn('保険料計算でエラーが発生しました:', error)\n      }\n      return this.fallbackBurdenCalculation(game)\n    }\n  }\n\n  /**\n   * 保険料負担を更新\n   */\n  updateInsuranceBurden(game: Game): void {\n    const burden = this.calculateInsuranceBurden(game)\n    // Gameクラスの内部プロパティを更新\n    // 保険料負担は負の値として計算されるため、符号を反転させて保存\n    const burdenValue = Math.abs(burden)\n      ; (game as any)._insuranceBurden = InsurancePremium.create(burdenValue)\n\n    // ダーティフラグを更新\n    if ((game as any)._dirtyFlags) {\n      (game as any)._dirtyFlags.insurance = true\n        ; (game as any)._dirtyFlags.burden = true\n    }\n  }\n\n  /**\n   * 推奨保険予算を取得\n   */\n  getRecommendedInsuranceBudget(\n    vitality: number,\n    stage: string,\n    riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'\n  ): InsurancePremium {\n    return this.premiumService.calculateOptimalInsuranceBudget(\n      vitality,\n      stage as any,\n      riskProfile\n    )\n  }\n\n  /**\n   * 期限が近い保険を取得\n   */\n  getExpiringSoonInsurances(insuranceCards: Card[]): Card[] {\n    return insuranceCards.filter(card => {\n      if (!card.isTermInsurance() || !card.remainingTurns) {\n        return false\n      }\n      return card.remainingTurns <= 2\n    })\n  }\n\n  /**\n   * バリデーション\n   * @private\n   */\n  private validateInsuranceSelection(game: Game): void {\n    if (game.phase !== 'insurance_type_selection') {\n      throw new Error('Not in insurance type selection phase')\n    }\n\n    if (!game.insuranceTypeChoices) {\n      throw new Error('No insurance type choices available')\n    }\n  }\n\n  /**\n   * 保険選択肢を検索\n   * @private\n   */\n  private findInsuranceChoice(game: Game, insuranceType: string) {\n    return game.insuranceTypeChoices?.find(\n      choice => choice.insuranceType === insuranceType\n    )\n  }\n\n  /**\n   * 保険カードを作成\n   * @private\n   */\n  private createInsuranceCard(choice: any, durationType: 'term' | 'whole_life'): Card {\n    if (durationType === 'term') {\n      return CardFactory.createTermInsuranceCard(choice)\n    }\n    return CardFactory.createWholeLifeInsuranceCard(choice)\n\n  }\n\n  /**\n   * 保険カードを追加\n   * @private\n   */\n  private addInsuranceCard(game: Game, card: Card): void {\n    game.cardManager.addToPlayerDeck(card)\n    game.stats.cardsAcquired++\n    game.activeInsurances.push(card)\n    this.updateInsuranceBurden(game)\n  }\n\n  /**\n   * 保険選択を完了\n   * @private\n   */\n  private completeInsuranceSelection(game: Game): void {\n    game.insuranceTypeChoices = undefined\n    game.phase = 'resolution'\n  }\n\n  /**\n   * 選択結果を作成\n   * @private\n   */\n  private createSelectionResult(\n    card: Card,\n    choice: any,\n    durationType: 'term' | 'whole_life'\n  ): InsuranceTypeSelectionResult {\n    const durationText = durationType === 'term'\n      ? `定期保険（${choice.termOption.duration}ターン）`\n      : '終身保険'\n\n    return {\n      success: true,\n      selectedCard: card,\n      message: `${choice.name}（${durationText}）を選択しました。コスト: ${card.cost}`\n    }\n  }\n\n  /**\n   * フォールバック計算\n   * @private\n   */\n  private fallbackBurdenCalculation(game: Game): number {\n    const activeInsuranceCount = game.activeInsurances.length\n    const burden = Math.floor(activeInsuranceCount / 3)\n    return burden === 0 ? 0 : -burden\n  }\n\n  /**\n   * プレイヤー履歴を更新\n   * @private\n   */\n  private updatePlayerHistory(game: Game, insuranceType: string): void {\n    const history = game.getPlayerHistory()\n    history.totalInsurancePurchased++\n\n    // リスクの高い保険種類を選んだ場合\n    if (insuranceType === 'life' || insuranceType === 'cancer') {\n      history.riskyChoiceCount++\n    }\n    history.totalChoiceCount++\n\n      // Gameの内部プロパティを更新\n      ; (game as any)._playerHistory = history\n  }\n\n  /**\n   * リスクプロファイルを更新\n   * @private\n   */\n  private updateRiskProfile(game: Game): void {\n    const newProfile = this.premiumService.generateRiskProfile(\n      game.getPlayerHistory(),\n      game.stage\n    )\n      ; (game as any)._riskProfile = newProfile\n  }\n}","/**\n * AI戦略サービス\n * \n * 異なるAI戦略（Conservative, Aggressive, Balanced, Adaptive）を実装し、\n * チャレンジ選択とカード選択の意思決定を行います。\n */\n\nimport type { Card } from '../entities/Card'\nimport type { Game } from '../entities/Game'\nimport type { GameStage } from '../types/game.types'\n\n/**\n * AI戦略タイプ\n */\nexport type AIStrategyType = 'conservative' | 'aggressive' | 'balanced' | 'adaptive'\n\n/**\n * チャレンジ選択結果\n */\nexport interface ChallengeChoice {\n  /** 選択されたチャレンジカード */\n  challenge: Card\n  /** 選択理由 */\n  reason: string\n  /** 成功確率予測 */\n  successProbability: number\n}\n\n/**\n * カード選択結果\n */\nexport interface CardChoice {\n  /** 選択されたカード配列 */\n  cards: Card[]\n  /** 選択理由 */\n  reason: string\n  /** 期待パワー値 */\n  expectedPower: number\n}\n\n/**\n * AI戦略の基底インターフェース\n */\nexport interface AIStrategy {\n  /**\n   * 戦略名を取得\n   */\n  getName(): string\n\n  /**\n   * 戦略タイプを取得\n   */\n  getType(): AIStrategyType\n\n  /**\n   * 利用可能なチャレンジから最適なものを選択\n   */\n  selectChallenge(\n    availableChallenges: Card[],\n    game: Game\n  ): ChallengeChoice\n\n  /**\n   * チャレンジに対して最適なカードを選択\n   */\n  selectCards(\n    challenge: Card,\n    availableCards: Card[],\n    game: Game\n  ): CardChoice\n\n  /**\n   * 現在のゲーム状況に対する戦略の適用度を評価（0-1）\n   */\n  evaluateFitness(game: Game): number\n}\n\n/**\n * 保守的戦略 - リスクを避け安全な選択を優先\n */\nexport class ConservativeStrategy implements AIStrategy {\n  getName(): string {\n    return '保守的戦略'\n  }\n\n  getType(): AIStrategyType {\n    return 'conservative'\n  }\n\n  selectChallenge(availableChallenges: Card[], game: Game): ChallengeChoice {\n    // 最も易しいチャレンジを選択\n    const sortedChallenges = [...availableChallenges].sort((a, b) => a.power - b.power)\n    const easiestChallenge = sortedChallenges[0]\n    \n    const currentPower = this.estimateCurrentPower(game)\n    const successProbability = Math.min(1, currentPower / easiestChallenge.power)\n\n    return {\n      challenge: easiestChallenge,\n      reason: '最も安全で成功確率の高いチャレンジを選択しました',\n      successProbability\n    }\n  }\n\n  selectCards(challenge: Card, availableCards: Card[], game: Game): CardChoice {\n    const targetPower = challenge.power\n    const selectedCards: Card[] = []\n    let currentPower = 0\n\n    // 保険カードを優先的に使用（リスク軽減）\n    const insuranceCards = availableCards\n      .filter(card => card.type === 'insurance')\n      .sort((a, b) => b.calculateEffectivePower() - a.calculateEffectivePower())\n\n    const otherCards = availableCards\n      .filter(card => card.type !== 'insurance')\n      .sort((a, b) => b.calculateEffectivePower() - a.calculateEffectivePower())\n\n    // まず保険カードを選択\n    for (const card of insuranceCards) {\n      if (currentPower >= targetPower * 1.2) break // 余裕を持って停止\n      selectedCards.push(card)\n      currentPower += card.calculateEffectivePower()\n    }\n\n    // 必要に応じて他のカードを追加\n    for (const card of otherCards) {\n      if (currentPower >= targetPower * 1.2) break\n      selectedCards.push(card)\n      currentPower += card.calculateEffectivePower()\n    }\n\n    return {\n      cards: selectedCards,\n      reason: '保険カードを重視し、十分な余裕を持った安全な選択を行いました',\n      expectedPower: currentPower\n    }\n  }\n\n  evaluateFitness(game: Game): number {\n    // 活力が低いほど保守的戦略が適している\n    const vitalityRatio = game.vitality / game.maxVitality\n    return 1 - vitalityRatio\n  }\n\n  private estimateCurrentPower(game: Game): number {\n    return game.cardManager.playerDeck.getCards()\n      .reduce((total, card) => total + card.calculateEffectivePower(), 0)\n  }\n}\n\n/**\n * 攻撃的戦略 - 高リスク高リターンを狙う\n */\nexport class AggressiveStrategy implements AIStrategy {\n  getName(): string {\n    return '攻撃的戦略'\n  }\n\n  getType(): AIStrategyType {\n    return 'aggressive'\n  }\n\n  selectChallenge(availableChallenges: Card[], game: Game): ChallengeChoice {\n    // 最も難しいチャレンジを選択（ただし勝率50%以上のもの）\n    const currentPower = this.estimateCurrentPower(game)\n    \n    const viableChallenges = availableChallenges\n      .filter(challenge => currentPower >= challenge.power * 0.5) // 最低50%の勝率\n      .sort((a, b) => b.power - a.power) // 難しい順\n\n    const selectedChallenge = viableChallenges[0] || availableChallenges[0]\n    const successProbability = Math.min(1, currentPower / selectedChallenge.power)\n\n    return {\n      challenge: selectedChallenge,\n      reason: '高い報酬を狙って、可能な限り困難なチャレンジを選択しました',\n      successProbability\n    }\n  }\n\n  selectCards(challenge: Card, availableCards: Card[], game: Game): CardChoice {\n    const targetPower = challenge.power\n    const selectedCards: Card[] = []\n    let currentPower = 0\n\n    // 最もパワーの高いカードから選択（効率重視）\n    const sortedCards = [...availableCards]\n      .sort((a, b) => b.calculateEffectivePower() - a.calculateEffectivePower())\n\n    for (const card of sortedCards) {\n      if (currentPower >= targetPower) break // 必要最小限で停止\n      selectedCards.push(card)\n      currentPower += card.calculateEffectivePower()\n    }\n\n    return {\n      cards: selectedCards,\n      reason: '最高パワーのカードを優先し、必要最小限のコストで勝利を狙いました',\n      expectedPower: currentPower\n    }\n  }\n\n  evaluateFitness(game: Game): number {\n    // 活力が高く、手札が強いほど攻撃的戦略が適している\n    const vitalityRatio = game.vitality / game.maxVitality\n    const handStrength = this.estimateHandStrength(game)\n    return (vitalityRatio + handStrength) / 2\n  }\n\n  private estimateCurrentPower(game: Game): number {\n    return game.cardManager.playerDeck.getCards()\n      .reduce((total, card) => total + card.calculateEffectivePower(), 0)\n  }\n\n  private estimateHandStrength(game: Game): number {\n    const handCards = game.cardManager.playerDeck.getCards()\n    if (handCards.length === 0) return 0\n    \n    const averagePower = handCards\n      .reduce((total, card) => total + card.calculateEffectivePower(), 0) / handCards.length\n    \n    // 平均パワー3を基準とした正規化（0-1）\n    return Math.min(1, averagePower / 3)\n  }\n}\n\n/**\n * バランス戦略 - リスクとリターンのバランスを重視\n */\nexport class BalancedStrategy implements AIStrategy {\n  getName(): string {\n    return 'バランス戦略'\n  }\n\n  getType(): AIStrategyType {\n    return 'balanced'\n  }\n\n  selectChallenge(availableChallenges: Card[], game: Game): ChallengeChoice {\n    const currentPower = this.estimateCurrentPower(game)\n    \n    // 成功確率70-90%の範囲でチャレンジを選択\n    const scoredChallenges = availableChallenges.map(challenge => {\n      const successProbability = Math.min(1, currentPower / challenge.power)\n      const riskRewardScore = this.calculateRiskRewardScore(challenge, successProbability)\n      \n      return { challenge, successProbability, score: riskRewardScore }\n    })\n\n    const bestChoice = scoredChallenges\n      .sort((a, b) => b.score - a.score)[0]\n\n    return {\n      challenge: bestChoice.challenge,\n      reason: 'リスクとリターンのバランスを考慮して最適なチャレンジを選択しました',\n      successProbability: bestChoice.successProbability\n    }\n  }\n\n  selectCards(challenge: Card, availableCards: Card[], game: Game): CardChoice {\n    const targetPower = challenge.power\n    const selectedCards: Card[] = []\n    let currentPower = 0\n\n    // カード効率（パワー/コスト比）で優先順位を決定\n    const scoredCards = availableCards.map(card => {\n      const efficiency = this.calculateCardEfficiency(card, game)\n      return { card, efficiency }\n    }).sort((a, b) => b.efficiency - a.efficiency)\n\n    for (const { card } of scoredCards) {\n      if (currentPower >= targetPower * 1.1) break // 10%の余裕\n      selectedCards.push(card)\n      currentPower += card.calculateEffectivePower()\n    }\n\n    return {\n      cards: selectedCards,\n      reason: 'カード効率とリスク管理を両立した最適な組み合わせを選択しました',\n      expectedPower: currentPower\n    }\n  }\n\n  evaluateFitness(game: Game): number {\n    // 常に中程度の適用度（他の戦略がフィットしない場合のフォールバック）\n    return 0.6\n  }\n\n  private estimateCurrentPower(game: Game): number {\n    return game.cardManager.playerDeck.getCards()\n      .reduce((total, card) => total + card.calculateEffectivePower(), 0)\n  }\n\n  private calculateRiskRewardScore(challenge: Card, successProbability: number): number {\n    // リスクリワード比を計算（成功確率 * 報酬 - 失敗確率 * ペナルティ）\n    const reward = challenge.power * 0.5 // 成功時の報酬想定\n    const penalty = challenge.power * 0.3 // 失敗時のペナルティ想定\n    \n    return successProbability * reward - (1 - successProbability) * penalty\n  }\n\n  private calculateCardEfficiency(card: Card, game: Game): number {\n    const power = card.calculateEffectivePower()\n    const cost = this.estimateCardCost(card)\n    return power / Math.max(1, cost)\n  }\n\n  private estimateCardCost(card: Card): number {\n    // カードのコスト推定（保険カードは負担があるため高コスト）\n    if (card.type === 'insurance') {\n      return card.calculateEffectivePower() + 1 // 保険料負担を考慮\n    }\n    return 1 // 基本カードは標準コスト\n  }\n}\n\n/**\n * 適応戦略 - ゲーム状況に応じて他の戦略を動的に選択\n */\nexport class AdaptiveStrategy implements AIStrategy {\n  private strategies: AIStrategy[]\n\n  constructor() {\n    this.strategies = [\n      new ConservativeStrategy(),\n      new AggressiveStrategy(),\n      new BalancedStrategy()\n    ]\n  }\n\n  getName(): string {\n    return '適応戦略'\n  }\n\n  getType(): AIStrategyType {\n    return 'adaptive'\n  }\n\n  selectChallenge(availableChallenges: Card[], game: Game): ChallengeChoice {\n    const bestStrategy = this.selectBestStrategy(game)\n    const choice = bestStrategy.selectChallenge(availableChallenges, game)\n    \n    return {\n      ...choice,\n      reason: `現在の状況を分析し、${bestStrategy.getName()}を採用: ${choice.reason}`\n    }\n  }\n\n  selectCards(challenge: Card, availableCards: Card[], game: Game): CardChoice {\n    const bestStrategy = this.selectBestStrategy(game)\n    const choice = bestStrategy.selectCards(challenge, availableCards, game)\n    \n    return {\n      ...choice,\n      reason: `${bestStrategy.getName()}による判断: ${choice.reason}`\n    }\n  }\n\n  evaluateFitness(game: Game): number {\n    // 他の戦略の中で最も適用度の高いものを採用\n    return Math.max(...this.strategies.map(strategy => strategy.evaluateFitness(game)))\n  }\n\n  private selectBestStrategy(game: Game): AIStrategy {\n    // 各戦略の適用度を評価し、最も適したものを選択\n    const strategyScores = this.strategies.map(strategy => ({\n      strategy,\n      fitness: strategy.evaluateFitness(game)\n    }))\n\n    return strategyScores\n      .sort((a, b) => b.fitness - a.fitness)[0]\n      .strategy\n  }\n}\n\n/**\n * AI戦略ファクトリー\n */\nexport class AIStrategyFactory {\n  private static readonly strategies = new Map<AIStrategyType, () => AIStrategy>([\n    ['conservative', () => new ConservativeStrategy()],\n    ['aggressive', () => new AggressiveStrategy()],\n    ['balanced', () => new BalancedStrategy()],\n    ['adaptive', () => new AdaptiveStrategy()]\n  ])\n\n  /**\n   * 指定されたタイプの戦略を作成\n   */\n  static createStrategy(type: AIStrategyType): AIStrategy {\n    const factory = this.strategies.get(type)\n    if (!factory) {\n      throw new Error(`Unknown strategy type: ${type}`)\n    }\n    return factory()\n  }\n\n  /**\n   * 利用可能な戦略タイプを取得\n   */\n  static getAvailableTypes(): AIStrategyType[] {\n    return Array.from(this.strategies.keys())\n  }\n\n  /**\n   * 戦略の説明を取得\n   */\n  static getStrategyDescription(type: AIStrategyType): string {\n    switch (type) {\n      case 'conservative':\n        return 'リスクを避け、安全な選択を優先する戦略。活力が低い時に適している。'\n      case 'aggressive':\n        return '高リスク高リターンを狙う戦略。活力と手札が充実している時に効果的。'\n      case 'balanced':\n        return 'リスクとリターンのバランスを重視する万能戦略。安定した判断を行う。'\n      case 'adaptive':\n        return '状況に応じて最適な戦略を自動選択する高度な戦略。経験豊富なプレイヤー向け。'\n      default:\n        return '不明な戦略タイプです。'\n    }\n  }\n}\n\n/**\n * AI戦略管理サービス\n */\nexport class AIStrategyService {\n  private currentStrategy: AIStrategy\n  private statisticsEnabled: boolean = true\n  private decisionHistory: Array<{\n    turn: number\n    strategy: string\n    challengeChoice: ChallengeChoice\n    cardChoice: CardChoice\n    result: 'success' | 'failure'\n  }> = []\n\n  constructor(strategyType: AIStrategyType = 'balanced') {\n    this.currentStrategy = AIStrategyFactory.createStrategy(strategyType)\n  }\n\n  /**\n   * 現在の戦略を取得\n   */\n  getCurrentStrategy(): AIStrategy {\n    return this.currentStrategy\n  }\n\n  /**\n   * 戦略を変更\n   */\n  setStrategy(strategyType: AIStrategyType): void {\n    this.currentStrategy = AIStrategyFactory.createStrategy(strategyType)\n  }\n\n  /**\n   * チャレンジを自動選択\n   */\n  autoSelectChallenge(availableChallenges: Card[], game: Game): ChallengeChoice {\n    const choice = this.currentStrategy.selectChallenge(availableChallenges, game)\n    \n    if (this.statisticsEnabled) {\n      console.log(`AI戦略 (${this.currentStrategy.getName()}): ${choice.reason}`)\n      console.log(`選択されたチャレンジ: ${choice.challenge.name} (成功確率: ${(choice.successProbability * 100).toFixed(1)}%)`)\n    }\n\n    return choice\n  }\n\n  /**\n   * カードを自動選択\n   */\n  autoSelectCards(challenge: Card, availableCards: Card[], game: Game): CardChoice {\n    const choice = this.currentStrategy.selectCards(challenge, availableCards, game)\n    \n    if (this.statisticsEnabled) {\n      console.log(`AI戦略 (${this.currentStrategy.getName()}): ${choice.reason}`)\n      console.log(`選択されたカード: ${choice.cards.map(c => c.name).join(', ')} (期待パワー: ${choice.expectedPower})`)\n    }\n\n    return choice\n  }\n\n  /**\n   * 意思決定履歴を記録\n   */\n  recordDecision(\n    turn: number,\n    challengeChoice: ChallengeChoice,\n    cardChoice: CardChoice,\n    success: boolean\n  ): void {\n    if (!this.statisticsEnabled) return\n\n    this.decisionHistory.push({\n      turn,\n      strategy: this.currentStrategy.getName(),\n      challengeChoice,\n      cardChoice,\n      result: success ? 'success' : 'failure'\n    })\n\n    // 履歴を最新100件に制限\n    if (this.decisionHistory.length > 100) {\n      this.decisionHistory = this.decisionHistory.slice(-100)\n    }\n  }\n\n  /**\n   * 統計情報を取得\n   */\n  getStatistics() {\n    const total = this.decisionHistory.length\n    if (total === 0) {\n      return {\n        totalDecisions: 0,\n        successRate: 0,\n        strategyUsage: new Map<string, number>()\n      }\n    }\n\n    const successes = this.decisionHistory.filter(d => d.result === 'success').length\n    const strategyUsage = new Map<string, number>()\n\n    this.decisionHistory.forEach(decision => {\n      const count = strategyUsage.get(decision.strategy) || 0\n      strategyUsage.set(decision.strategy, count + 1)\n    })\n\n    return {\n      totalDecisions: total,\n      successRate: successes / total,\n      strategyUsage\n    }\n  }\n\n  /**\n   * 統計収集の有効/無効を切り替え\n   */\n  setStatisticsEnabled(enabled: boolean): void {\n    this.statisticsEnabled = enabled\n  }\n\n  /**\n   * 意思決定履歴をクリア\n   */\n  clearHistory(): void {\n    this.decisionHistory = []\n  }\n}","import type { GamePhase, GameStage, GameStatus } from '../types/game.types'\nimport type { Card } from '../entities/Card'\n\n/**\n * ゲーム状態の変更イベント\n */\nexport interface GameStateChangeEvent {\n  type: 'phase_change' | 'status_change' | 'stage_change' | 'turn_change'\n  previousValue: any\n  newValue: any\n  timestamp: number\n}\n\n/**\n * ゲーム状態変更の履歴管理\n */\nexport interface GameStateHistory {\n  events: GameStateChangeEvent[]\n  maxEvents: number\n}\n\n/**\n * ゲーム状態管理の専門サービス\n * \n * Single Responsibility: ゲーム状態の管理とイベント発行に特化\n * Open/Closed: 新しい状態タイプは拡張で対応\n */\nexport class GameStateManager {\n  private readonly listeners: Map<string, Array<(event: GameStateChangeEvent) => void>> = new Map()\n  private readonly history: GameStateHistory = {\n    events: [],\n    maxEvents: 50 // パフォーマンス考慮で制限\n  }\n\n  /**\n   * 状態変更イベントリスナーを登録\n   * \n   * @param eventType イベントタイプ\n   * @param listener リスナー関数\n   * @returns リスナー解除関数\n   */\n  addEventListener(\n    eventType: GameStateChangeEvent['type'],\n    listener: (event: GameStateChangeEvent) => void\n  ): () => void {\n    const existingListeners = this.listeners.get(eventType) || []\n    existingListeners.push(listener)\n    this.listeners.set(eventType, existingListeners)\n\n    // リスナー解除関数を返す\n    return () => {\n      const current = this.listeners.get(eventType) || []\n      const index = current.indexOf(listener)\n      if (index > -1) {\n        current.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * 状態変更を通知し、履歴に記録\n   * \n   * @param type 変更タイプ\n   * @param previousValue 以前の値\n   * @param newValue 新しい値\n   */\n  notifyStateChange(\n    type: GameStateChangeEvent['type'],\n    previousValue: any,\n    newValue: any\n  ): void {\n    const event: GameStateChangeEvent = {\n      type,\n      previousValue,\n      newValue,\n      timestamp: Date.now()\n    }\n\n    // 履歴に追加\n    this.addToHistory(event)\n\n    // リスナーに通知\n    const listeners = this.listeners.get(type) || []\n    listeners.forEach(listener => {\n      try {\n        listener(event)\n      } catch (error) {\n        // テスト環境では期待される挙動なのでエラーログを抑制\n        if (process.env.NODE_ENV !== 'test') {\n          console.error(`GameStateManager: イベントリスナーでエラーが発生しました`, error)\n        }\n      }\n    })\n  }\n\n  /**\n   * フェーズ変更を通知\n   */\n  notifyPhaseChange(previousPhase: GamePhase, newPhase: GamePhase): void {\n    this.notifyStateChange('phase_change', previousPhase, newPhase)\n  }\n\n  /**\n   * ステータス変更を通知\n   */\n  notifyStatusChange(previousStatus: GameStatus, newStatus: GameStatus): void {\n    this.notifyStateChange('status_change', previousStatus, newStatus)\n  }\n\n  /**\n   * ステージ変更を通知\n   */\n  notifyStageChange(previousStage: GameStage, newStage: GameStage): void {\n    this.notifyStateChange('stage_change', previousStage, newStage)\n  }\n\n  /**\n   * ターン変更を通知\n   */\n  notifyTurnChange(previousTurn: number, newTurn: number): void {\n    this.notifyStateChange('turn_change', previousTurn, newTurn)\n  }\n\n  /**\n   * 状態変更履歴を取得\n   */\n  getHistory(): GameStateHistory {\n    return { ...this.history }\n  }\n\n  /**\n   * 特定タイプのイベント履歴のみを取得\n   */\n  getHistoryByType(type: GameStateChangeEvent['type']): GameStateChangeEvent[] {\n    return this.history.events.filter(event => event.type === type)\n  }\n\n  /**\n   * 履歴をクリア\n   */\n  clearHistory(): void {\n    this.history.events = []\n  }\n\n  /**\n   * 履歴に追加（上限管理付き）\n   */\n  private addToHistory(event: GameStateChangeEvent): void {\n    this.history.events.push(event)\n    \n    // 上限を超えた場合は古いイベントを削除\n    if (this.history.events.length > this.history.maxEvents) {\n      this.history.events.shift()\n    }\n  }\n\n  /**\n   * 全リスナーを解除\n   */\n  removeAllListeners(): void {\n    this.listeners.clear()\n  }\n\n  /**\n   * 特定タイプのリスナーを解除\n   */\n  removeListenersForType(eventType: GameStateChangeEvent['type']): void {\n    this.listeners.delete(eventType)\n  }\n}","import type { Card } from '../entities/Card'\nimport type { ChallengeResult, InsuranceTypeSelectionResult } from '../types/game.types'\nimport type { Game } from '../entities/Game'\n\n/**\n * ゲームアクションの結果\n */\nexport interface ActionResult<T = any> {\n  success: boolean\n  data?: T\n  error?: string\n  effects?: GameEffect[]\n}\n\n/**\n * ゲーム効果\n */\nexport interface GameEffect {\n  type: 'vitality_change' | 'card_draw' | 'insurance_add' | 'stage_advance'\n  description: string\n  value?: number\n  cards?: Card[]\n}\n\n/**\n * アクション処理の抽象基底クラス\n * Template Method Pattern を使用\n */\nexport abstract class BaseActionProcessor<TInput, TOutput> {\n  /**\n   * アクション実行のテンプレートメソッド\n   */\n  async execute(game: Game, input: TInput): Promise<ActionResult<TOutput>> {\n    try {\n      // 前処理バリデーション\n      const validationResult = await this.validate(game, input)\n      if (!validationResult.success) {\n        return validationResult as ActionResult<TOutput>\n      }\n\n      // メイン処理\n      const result = await this.process(game, input)\n\n      // 後処理\n      await this.postProcess(game, result)\n\n      return result\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      }\n    }\n  }\n\n  /**\n   * バリデーション処理（サブクラスでオーバーライド）\n   */\n  protected async validate(game: Game, input: TInput): Promise<ActionResult<void>> {\n    return { success: true }\n  }\n\n  /**\n   * メイン処理（サブクラスで必須実装）\n   */\n  protected abstract process(game: Game, input: TInput): Promise<ActionResult<TOutput>>\n\n  /**\n   * 後処理（サブクラスでオーバーライド）\n   */\n  protected async postProcess(game: Game, result: ActionResult<TOutput>): Promise<void> {\n    // デフォルトは何もしない\n  }\n}\n\n/**\n * カードドロー処理\n */\nexport class DrawCardsProcessor extends BaseActionProcessor<number, Card[]> {\n  protected override async validate(game: Game, count: number): Promise<ActionResult<void>> {\n    if (count <= 0) {\n      return { success: false, error: 'ドロー枚数は1以上である必要があります' }\n    }\n\n    if (count > 10) {\n      return { success: false, error: 'ドロー枚数は10枚以下である必要があります' }\n    }\n\n    return { success: true }\n  }\n\n  protected override async process(game: Game, count: number): Promise<ActionResult<Card[]>> {\n    // CardManagerから直接カードをドロー\n    const result = game.cardManager.drawCards(count)\n\n    const effects: GameEffect[] = [{\n      type: 'card_draw',\n      description: `${result.drawnCards.length}枚のカードをドローしました`,\n      cards: result.drawnCards\n    }]\n\n    // トラブルカードの処理\n    if (result.troubleCards && result.troubleCards.length > 0) {\n      for (const trouble of result.troubleCards) {\n        // ペナルティ適用 (Trouble card penalty is deduction of vitality)\n        // Assuming 'penalty' property exists on Card (or ICard) and is number\n        // If card.penalty is undefined, default to 0\n        const penalty = (trouble as any).penalty || 0 // Cast to any if Card doesn't explicitly expose penalty property yet\n        if (penalty > 0) {\n          try {\n            game.applyDamage(penalty)\n            effects.push({\n              type: 'vitality_change',\n              description: `トラブル「${trouble.name}」発動！ ${penalty}のダメージ`,\n              value: -penalty,\n              cards: [trouble]\n            })\n          } catch (e) {\n            console.error('Failed to apply trouble penalty', e)\n          }\n        } else {\n          effects.push({\n            type: 'vitality_change', // or 'message'\n            description: `トラブル「${trouble.name}」発動！`,\n            cards: [trouble]\n          })\n        }\n      }\n    }\n\n    return {\n      success: true,\n      data: result.drawnCards,\n      effects\n    }\n  }\n}\n\n/**\n * チャレンジ開始処理\n */\nexport class StartChallengeProcessor extends BaseActionProcessor<Card, void> {\n  protected override async validate(game: Game, challengeCard: Card): Promise<ActionResult<void>> {\n    if (game.phase !== 'draw') {\n      return { success: false, error: 'ドローフェーズでのみチャレンジを開始できます' }\n    }\n\n    if (challengeCard.type !== 'challenge') {\n      return { success: false, error: 'チャレンジカード以外は選択できません' }\n    }\n\n    return { success: true }\n  }\n\n  protected override async process(game: Game, challengeCard: Card): Promise<ActionResult<void>> {\n    game.startChallenge(challengeCard)\n\n    return {\n      success: true,\n      effects: [{\n        type: 'stage_advance',\n        description: `チャレンジ「${challengeCard.name}」を開始しました`\n      }]\n    }\n  }\n}\n\n/**\n * チャレンジフェーズ開始処理 (v2: 選択肢提示)\n */\nexport class StartChallengePhaseProcessor extends BaseActionProcessor<void, void> {\n  protected override async validate(game: Game, input: void): Promise<ActionResult<void>> {\n    if (game.phase !== 'draw') {\n      return { success: false, error: 'ドローフェーズでのみチャレンジ選択を開始できます' }\n    }\n    return { success: true }\n  }\n\n  protected override async process(game: Game, input: void): Promise<ActionResult<void>> {\n    game.startChallengePhase()\n\n    return {\n      success: true,\n      effects: [{\n        type: 'stage_advance', // Or new type 'phase_change'\n        description: 'チャレンジ選択を開始しました'\n      }]\n    }\n  }\n}\n\n/**\n * チャレンジ解決処理\n */\nexport class ResolveChallengeProcessor extends BaseActionProcessor<void, ChallengeResult> {\n  protected override async validate(game: Game, input: void): Promise<ActionResult<void>> {\n    if (!game.currentChallenge) {\n      return { success: false, error: 'アクティブなチャレンジがありません' }\n    }\n\n    if (game.selectedCards.length === 0) {\n      return { success: false, error: 'カードが選択されていません' }\n    }\n\n    return { success: true }\n  }\n\n  protected override async process(game: Game, input: void): Promise<ActionResult<ChallengeResult>> {\n    const result = game.resolveChallenge()\n\n    const effects: GameEffect[] = []\n\n    if (result.success) {\n      effects.push({\n        type: 'vitality_change',\n        description: 'チャレンジに成功しました',\n        value: result.vitalityChange\n      })\n    } else {\n      effects.push({\n        type: 'vitality_change',\n        description: 'チャレンジに失敗しました',\n        value: result.vitalityChange\n      })\n    }\n\n    return {\n      success: true,\n      data: result,\n      effects\n    }\n  }\n}\n\n/**\n * 保険選択処理\n */\nexport class SelectInsuranceProcessor extends BaseActionProcessor<\n  { insuranceType: string; durationType: 'term' | 'whole_life' },\n  InsuranceTypeSelectionResult\n> {\n  protected override async validate(\n    game: Game,\n    input: { insuranceType: string; durationType: 'term' | 'whole_life' }\n  ): Promise<ActionResult<void>> {\n    if (!input.insuranceType) {\n      return { success: false, error: '保険種類が指定されていません' }\n    }\n\n    if (!['term', 'whole_life'].includes(input.durationType)) {\n      return { success: false, error: '無効な保険期間タイプです' }\n    }\n\n    return { success: true }\n  }\n\n  protected override async process(\n    game: Game,\n    input: { insuranceType: string; durationType: 'term' | 'whole_life' }\n  ): Promise<ActionResult<InsuranceTypeSelectionResult>> {\n    const result = game.selectInsuranceType(input.insuranceType, input.durationType)\n\n    return {\n      success: true,\n      data: result,\n      effects: [{\n        type: 'insurance_add',\n        description: `${input.durationType === 'term' ? '定期' : '終身'}${input.insuranceType}保険を追加しました`\n      }]\n    }\n  }\n}\n\n/**\n * 保険購入処理 (v2)\n */\nexport class BuyInsuranceProcessor extends BaseActionProcessor<Card, void> {\n  protected override async validate(game: Game, card: Card): Promise<ActionResult<void>> {\n    // Phase check might be strict, so relaxing for now OR checking correct phase\n    const validPhases: string[] = ['action', 'insurance_phase', 'insurance']\n    if (!validPhases.includes(game.phase)) {\n      // Just a warning or strict? For now, let's allow \"action\" phase too as per rulebook flow\n    }\n    return { success: true }\n  }\n\n  protected override async process(game: Game, card: Card): Promise<ActionResult<void>> {\n    game.cardManager.buyInsurance(card)\n\n    if (card.cost > 0) {\n      // Use applyDamage (which handles negative \"damage\" as heal, or we need a spend method?)\n      // Game doesn't have spendVitality, but has updateVitality private.\n      // applyDamage accepts positive number as damage.\n      try {\n        game.applyDamage(card.cost)\n      } catch (e) {\n        return { success: false, error: 'Cost payment failed' }\n      }\n    }\n\n    return {\n      success: true,\n      effects: [{\n        type: 'insurance_add',\n        description: `保険「${card.name}」を購入しました`,\n        cards: [card]\n      }]\n    }\n  }\n}\n\n/**\n * カード除外処理 (v2 Deck Compression)\n */\nexport class RemoveCardProcessor extends BaseActionProcessor<Card, void> {\n  protected override async validate(game: Game, card: Card): Promise<ActionResult<void>> {\n    // Only allow if player has taken damage or specific effect?\n    // Rule: \"Save lost vitality 1 point = 1 card removal\"\n    // This validation might be complex, for now trust the UI/Caller\n    return { success: true }\n  }\n\n  protected override async process(game: Game, card: Card): Promise<ActionResult<void>> {\n    game.cardManager.removeCardFromGame(card)\n    return {\n      success: true,\n      effects: [{\n        type: 'card_draw', // Reusing type or add new 'card_remove'\n        description: `カード「${card.name}」を除外しました`,\n        cards: [card]\n      }]\n    }\n  }\n}\n\n/**\n * 夢カード選択処理 (v2)\n */\nexport class SelectDreamProcessor extends BaseActionProcessor<Card, void> {\n  protected override async validate(game: Game, card: Card): Promise<ActionResult<void>> {\n    if (game.phase !== 'dream_selection') {\n      return { success: false, error: '夢選択フェーズではありません' }\n    }\n    return { success: true }\n  }\n\n  protected override async process(game: Game, card: Card): Promise<ActionResult<void>> {\n    try {\n      game.selectDream(card)\n      return {\n        success: true,\n        effects: [{\n          type: 'stage_advance',\n          description: `夢「${card.name}」を選択しました`\n        }]\n      }\n    } catch (e) {\n      return { success: false, error: e instanceof Error ? e.message : String(e) }\n    }\n  }\n}\n\n/**\n * アクション処理管理クラス\n */\nexport class GameActionProcessor {\n  private readonly processors: Map<string, BaseActionProcessor<any, any>> = new Map()\n\n  constructor() {\n    // 標準プロセッサを登録\n    this.registerProcessor('draw_cards', new DrawCardsProcessor())\n    this.registerProcessor('start_challenge', new StartChallengeProcessor())\n    this.registerProcessor('resolve_challenge', new ResolveChallengeProcessor())\n    this.registerProcessor('select_insurance', new SelectInsuranceProcessor())\n    this.registerProcessor('start_challenge_phase', new StartChallengePhaseProcessor())\n    // v2 processors\n    this.registerProcessor('buy_insurance', new BuyInsuranceProcessor())\n    this.registerProcessor('remove_card', new RemoveCardProcessor())\n    this.registerProcessor('select_dream', new SelectDreamProcessor())\n  }\n\n  /**\n   * プロセッサを登録\n   */\n  registerProcessor<TInput, TOutput>(\n    actionType: string,\n    processor: BaseActionProcessor<TInput, TOutput>\n  ): void {\n    this.processors.set(actionType, processor)\n  }\n\n  /**\n   * アクションを実行\n   */\n  async executeAction<TInput, TOutput>(\n    actionType: string,\n    game: Game,\n    input: TInput\n  ): Promise<ActionResult<TOutput>> {\n    console.log('[GameActionProcessor] executeAction called', actionType)\n    const processor = this.processors.get(actionType)\n\n    if (!processor) {\n      console.error('[GameActionProcessor] Unknown action type:', actionType)\n      return {\n        success: false,\n        error: `未知のアクションタイプ: ${actionType}`\n      }\n    }\n\n    const result = await processor.execute(game, input)\n    console.log('[GameActionProcessor] execution result:', result)\n    return result\n  }\n\n  /**\n   * 登録されているアクションタイプ一覧を取得\n   */\n  getAvailableActions(): string[] {\n    return Array.from(this.processors.keys())\n  }\n\n  /**\n   * プロセッサを削除\n   */\n  unregisterProcessor(actionType: string): boolean {\n    return this.processors.delete(actionType)\n  }\n}","/**\n * 活力を表す値オブジェクト\n * \n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\n * ビジネスルール：\n * - 活力は0以上100以下でなければならない\n */\nexport class Vitality {\n  private static readonly DEFAULT_MAX_VITALITY = 100\n\n  private constructor(\n    private readonly value: number,\n    private readonly maxVitality: number = Vitality.DEFAULT_MAX_VITALITY\n  ) {\n    this.validate()\n  }\n\n  /**\n   * Vitality インスタンスを生成する\n   * @param value 活力値\n   * @param maxVitality 最大活力値（デフォルト: 100）\n   * @throws {Error} 不正な値の場合\n   */\n  static create(value: number, maxVitality: number = Vitality.DEFAULT_MAX_VITALITY): Vitality {\n    return new Vitality(value, maxVitality)\n  }\n\n  /**\n   * 値の妥当性を検証する\n   * @private\n   */\n  private validate(): void {\n    // 型チェック\n    if (!isFinite(this.value)) {\n      throw new Error('Vitality value must be a finite number')\n    }\n    if (!isFinite(this.maxVitality)) {\n      throw new Error('Maximum vitality must be a finite number')\n    }\n    \n    if (this.maxVitality <= 0) {\n      throw new Error('Maximum vitality must be positive')\n    }\n    if (this.value < 0) {\n      throw new Error('Vitality value cannot be negative')\n    }\n    if (this.value > this.maxVitality) {\n      throw new Error(`Vitality value cannot exceed maximum (${this.maxVitality})`)\n    }\n  }\n\n  /**\n   * 現在の活力値を取得\n   */\n  getValue(): number {\n    return this.value\n  }\n\n  /**\n   * 最大活力値を取得\n   */\n  getMax(): number {\n    return this.maxVitality\n  }\n\n  /**\n   * 活力を減少させる\n   * @param amount 減少量\n   * @returns 新しいVitalityインスタンス\n   * @throws {Error} 減少量が負の場合または無効な値の場合\n   */\n  decrease(amount: number): Vitality {\n    if (typeof amount !== 'number' || !isFinite(amount)) {\n      throw new Error('Decrease amount must be a finite number')\n    }\n    if (amount < 0) {\n      throw new Error('Decrease amount must be non-negative')\n    }\n    return new Vitality(Math.max(0, this.value - amount), this.maxVitality)\n  }\n\n  /**\n   * 活力を増加させる\n   * @param amount 増加量\n   * @returns 新しいVitalityインスタンス\n   * @throws {Error} 増加量が負の場合または無効な値の場合\n   */\n  increase(amount: number): Vitality {\n    if (typeof amount !== 'number' || !isFinite(amount)) {\n      throw new Error('Increase amount must be a finite number')\n    }\n    if (amount < 0) {\n      throw new Error('Increase amount must be non-negative')\n    }\n    return new Vitality(Math.min(this.maxVitality, this.value + amount), this.maxVitality)\n  }\n\n  /**\n   * パーセンテージを取得（0-100）\n   */\n  getPercentage(): number {\n    return Math.floor((this.value / this.maxVitality) * 100)\n  }\n\n  /**\n   * 活力が枯渇しているか判定\n   */\n  isDepleted(): boolean {\n    return this.value === 0\n  }\n\n  /**\n   * 活力が満タンか判定\n   */\n  isFull(): boolean {\n    return this.value === this.maxVitality\n  }\n\n  /**\n   * 最大活力値を変更したVitalityインスタンスを作成\n   * 現在の活力値が新しい最大値を超える場合は最大値に調整\n   * @param newMaxVitality 新しい最大活力値\n   * @returns 新しいVitalityインスタンス\n   */\n  withMaxVitality(newMaxVitality: number): Vitality {\n    if (typeof newMaxVitality !== 'number' || !isFinite(newMaxVitality)) {\n      throw new Error('Maximum vitality must be a finite number')\n    }\n    const adjustedValue = Math.min(this.value, newMaxVitality)\n    return new Vitality(adjustedValue, newMaxVitality)\n  }\n\n  /**\n   * 他のVitalityインスタンスと等価か判定\n   */\n  equals(other: Vitality): boolean {\n    return this.value === other.value && this.maxVitality === other.maxVitality\n  }\n\n  /**\n   * 文字列表現を取得\n   */\n  toString(): string {\n    return `${this.value}/${this.maxVitality} (${this.getPercentage()}%)`\n  }\n}","import type { Card } from './Card'\nimport { Deck } from './Deck'\nimport { CardFactory } from '../services/CardFactory'\nimport { CardManager, type ICardManager } from '../services/CardManager'\nimport { InsurancePremiumCalculationService } from '../services/InsurancePremiumCalculationService'\nimport { GameStageManager } from '../services/GameStageManager'\nimport { InsuranceExpirationManager } from '../services/InsuranceExpirationManager'\nimport { ChallengeResolutionService } from '../services/ChallengeResolutionService'\nimport { GameTurnManager } from '../services/GameTurnManager'\nimport { GameChallengeService } from '../services/GameChallengeService'\nimport { GameInsuranceService } from '../services/GameInsuranceService'\nimport { AIStrategyService, type AIStrategyType } from '../services/AIStrategyService'\nimport { GameStateManager } from '../services/GameStateManager'\nimport { GameActionProcessor } from '../services/GameActionProcessor'\nimport { IdGenerator } from '../../common/IdGenerator'\nimport type {\n  ChallengeResult,\n  GameConfig,\n  GamePhase,\n  GameStatus,\n  IGameState,\n  InsuranceTypeChoice,\n  InsuranceTypeSelectionResult,\n  PlayerStats,\n  TurnResult,\n  PendingInsuranceClaim\n} from '../types/game.types'\nimport {\n  AVAILABLE_CHARACTERS,\n  DREAM_AGE_ADJUSTMENTS\n} from '../types/game.types'\nimport type { GameStage, InsuranceTriggerType } from '../types/card.types'\nimport { Vitality } from '../valueObjects/Vitality'\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\nimport { RiskProfile } from '../valueObjects/RiskProfile'\nimport type { PlayerHistory } from '../services/InsurancePremiumCalculationService'\nimport { GameConstantsAccessor } from '../constants/GameConstants'\n\n/**\n * ゲームエンティティ - ゲーム全体の状態と進行を管理する中核クラス\n * \n * このクラスは値オブジェクトを使用してゲーム状態を管理します：\n * - vitality: Vitality値オブジェクトで管理（プレイヤーの活力）\n * - insuranceBurden: InsurancePremium値オブジェクトで管理（保険料負担）\n * \n * @implements {IGameState} ゲーム状態のインターフェース\n * \n * @example\n * // ゲームの初期化\n * const config = { startingVitality: 20, maxHandSize: 7 };\n * const game = new Game(config);\n * game.start();\n * \n * // ターンの進行\n * game.drawCards(5);\n * const challenge = game.challengeDeck.drawCard();\n * game.startChallenge(challenge);\n */\nexport class Game implements IGameState {\n  id: string\n  status: GameStatus\n  phase: GamePhase\n  stage: GameStage\n  turn: number\n  private _vitality: Vitality\n\n  // カード管理を移譲\n  public cardManager: ICardManager\n\n  // ドメインサービス\n  private readonly premiumCalculationService: InsurancePremiumCalculationService\n  private readonly stageManager: GameStageManager\n  private readonly expirationManager: InsuranceExpirationManager\n  private readonly challengeResolutionService: ChallengeResolutionService\n  private readonly turnManager: GameTurnManager\n  private readonly challengeService: GameChallengeService\n  private readonly insuranceService: GameInsuranceService\n  private readonly aiStrategyService: AIStrategyService\n\n  // 新しいアーキテクチャ\n  private readonly stateManager: GameStateManager\n  private readonly actionProcessor: GameActionProcessor\n\n  currentChallenge: Card | undefined = undefined\n\n  stats: PlayerStats\n  config: GameConfig\n\n  // Phase 5: リスクプロファイルとプレイヤー履歴\n  private readonly _riskProfile: RiskProfile\n  private readonly _playerHistory: PlayerHistory\n\n  // Phase 2-4:  // 保険関連\n  activeInsurances: Card[] = []\n  expiredInsurances: Card[] = []\n  private readonly _insuranceBurden: InsurancePremium\n\n  // v2: 新要素\n  agingDeck: Deck\n  score: number = 0\n  insuranceMarket: Card[] = []\n  selectedDream: Card | undefined = undefined\n\n  // 選択肢\n  insuranceTypeChoices: InsuranceTypeChoice[] | undefined = undefined\n  pendingInsuranceClaim: PendingInsuranceClaim | undefined = undefined\n\n  // 経験学習システム（GAME_DESIGN.mdより）\n  private readonly _learningHistory: Map<string, number> = new Map() // チャレンジ名 -> 失敗回数\n\n  /**\n   * 学習履歴を取得\n   */\n  getLearningHistory(challengeName: string): number {\n    return this._learningHistory.get(challengeName) || 0\n  }\n\n  /**\n   * 学習履歴を更新\n   */\n  updateLearningHistory(challengeName: string, failures: number): void {\n    this._learningHistory.set(challengeName, failures)\n  }\n\n  // AI戦略設定\n  private _aiEnabled: boolean = false\n  private _currentAIStrategy: AIStrategyType = 'balanced'\n\n  // パフォーマンス最適化: オブジェクトプール\n  private static readonly OBJECT_POOLS = {\n    cards: [] as Card[],\n    gameStates: [] as Partial<IGameState>[],\n    challengeResults: [] as Partial<ChallengeResult>[]\n  }\n\n  // ダーティフラグシステムの導入\n  private readonly _dirtyFlags = {\n    vitality: false,\n    insurance: false,\n    burden: false,\n    stats: false,\n    gameState: false\n  }\n\n  // 難易度調整用モディファイア（夢を諦めた場合などに上昇）\n  challengeDifficultyModifier: number = 0\n\n  // キャッシュシステム\n  private readonly _cachedValues = {\n    insuranceBurden: 0,\n    availableVitality: 0,\n    totalInsuranceCount: 0,\n    lastUpdateTime: 0\n  }\n\n  startedAt?: Date\n  completedAt?: Date\n\n  /**\n   * Gameインスタンスを作成\n   * @param {GameConfig} [config] - ゲーム設定（オプション）\n   * @param {string} [config.difficulty='normal'] - 難易度\n   * @param {number} [config.startingVitality=100] - 初期活力\n   * @param {number} [config.startingHandSize=5] - 初期手札枚数\n   * @param {number} [config.maxHandSize=10] - 最大手札枚数\n   * @param {number} [config.dreamCardCount=3] - 夢カード枚数\n   */\n  constructor(config?: GameConfig) {\n    this.id = this.generateId()\n    this.status = 'not_started'\n    this.phase = 'setup'\n    this.stage = 'youth'\n    this.turn = 0\n\n    // Config must be set before initializing CardManager or Vitality\n    const defaults: GameConfig = {\n      difficulty: 'normal',\n      startingVitality: 100,\n      startingHandSize: 5,\n      maxHandSize: 10,\n      dreamCardCount: 3\n    }\n    const resolvedConfig: GameConfig = { ...defaults, ...config }\n\n    // console.log('[Game] Constructor Config:', JSON.stringify(resolvedConfig)) // DEBUG\n\n    this.config = resolvedConfig\n\n    // Apply balance overrides if provided\n    if (this.config.balanceConfig) {\n      // console.log('[Game] Applying Balance Overrides:', JSON.stringify(this.config.balanceConfig)) // DEBUG\n      GameConstantsAccessor.setOverrides(this.config.balanceConfig)\n    }\n\n    // 値オブジェクトで初期化（年齢別最大活力を適用）\n    // NOTE: Override適用後にパラメータを取得する\n    // Phase 4: キャラクター適用\n    const characterId = resolvedConfig.characterId || 'solid' // Default to Solid\n    const character = AVAILABLE_CHARACTERS.find(c => c.id === characterId) || AVAILABLE_CHARACTERS[0]\n\n    if (!character) {\n      // Should not happen as we fallback to [0], but for TS safety\n      throw new Error('No available characters found')\n    }\n\n    // console.log(`[Game] Selected Character: ${character.name}`)\n\n    const basePower = (resolvedConfig.startingVitality !== undefined) ? resolvedConfig.startingVitality : 100\n    const startingVitality = basePower + character.initialVitalityModifier\n\n    // Hardcore fix: If difficulty is hardcore and base is default (100), force it to 20? No, that's hidden logic.\n    // Better to fix the caller.\n\n    const ageParams = GameConstantsAccessor.getStageParameters(this.stage)\n    if (!ageParams) throw new Error(`Invalid stage parameters for ${this.stage}`)\n\n    // キャラクター補正を含めた最大活力\n    const baseMaxVitality = ageParams.maxVitality + character.initialVitalityModifier\n    const maxVitality = baseMaxVitality\n\n    const cheatThreshold = 200\n    const actualStartingVitality = (startingVitality > maxVitality && startingVitality > cheatThreshold)\n      ? startingVitality\n      : Math.min(startingVitality, maxVitality)\n\n    const actualMaxVitality = Math.max(actualStartingVitality, maxVitality)\n\n    this._vitality = Vitality.create(actualStartingVitality, actualMaxVitality)\n\n\n\n    // CardManagerを初期化\n    this.cardManager = new CardManager()\n\n    // ドメインサービスを初期化\n    this.premiumCalculationService = new InsurancePremiumCalculationService()\n    this.stageManager = new GameStageManager()\n    this.expirationManager = new InsuranceExpirationManager()\n    this.challengeResolutionService = new ChallengeResolutionService()\n    this.turnManager = new GameTurnManager(this.stageManager, this.expirationManager)\n    this.challengeService = new GameChallengeService(this.challengeResolutionService)\n    this.insuranceService = new GameInsuranceService(this.premiumCalculationService)\n    this.aiStrategyService = new AIStrategyService(this._currentAIStrategy)\n\n    // 新しいアーキテクチャを初期化\n    this.stateManager = new GameStateManager()\n    this.actionProcessor = new GameActionProcessor()\n\n    // Apply balance overrides if provided\n    if (this.config.balanceConfig) {\n      GameConstantsAccessor.setOverrides(this.config.balanceConfig)\n    } else {\n      GameConstantsAccessor.clearOverrides()\n    }\n    // ...\n\n\n\n    // 状態変更イベントの監視を設定\n    this.setupStateListeners()\n    const playerDeck = new Deck('Player Deck')\n    const challengeDeck = new Deck('Challenge Deck')\n\n    // 初期デッキを作成\n    const initialCards = CardFactory.createStarterLifeCards()\n    initialCards.forEach(card => { playerDeck.addCard(card); })\n\n    // Verify and Sanitize Player Deck (Fix for Dream Leak)\n    const dreamLeak = playerDeck.getCards().filter(c => c.type === 'dream' || (c.type === 'challenge' && (c as any).isDream) || (c.type === 'life' && c.power >= 30))\n    if (dreamLeak.length > 0) {\n      console.warn('[Game] WARNING: Dream cards detected in initial player deck! Removing...', dreamLeak.map(c => c.name))\n      dreamLeak.forEach(c => playerDeck.removeCard(c.id))\n    }\n\n    // チャレンジデッキを作成\n    const challengeCards = CardFactory.createChallengeCards(this.stage)\n    challengeCards.forEach(card => { challengeDeck.addCard(card); })\n\n    // Initialize CardManager with config already set\n    this.cardManager.initialize(playerDeck, challengeDeck, this.config)\n\n    this.stats = {\n      totalChallenges: 0,\n      successfulChallenges: 0,\n      failedChallenges: 0,\n      cardsAcquired: 0,\n      highestVitality: actualStartingVitality,\n      turnsPlayed: 0\n    }\n\n    // Phase 5: リスクプロファイルと履歴の初期化\n    this._riskProfile = RiskProfile.default()\n    this._playerHistory = {\n      turnsPlayed: 0,\n      totalDamageTaken: 0,\n      insuranceClaimCount: 0,\n      totalInsurancePurchased: 0,\n      riskyChoiceCount: 0,\n      totalChoiceCount: 0\n    }\n\n    // Phase 2-4: 保険カード管理の初期化\n    this.activeInsurances = []\n    this.expiredInsurances = []\n    this.insuranceMarket = []\n\n    // v2: 初期化\n    this.agingDeck = new Deck('Aging Deck')\n    const agingCards = CardFactory.createAgingCards(20)\n    this.cardManager.getState().agingDeck.addCards(agingCards)\n    this.cardManager.getState().agingDeck.shuffle()\n\n    this.score = 0\n\n    // Phase 3: 保険料負担の初期化\n    this._insuranceBurden = InsurancePremium.create(0)\n  }\n\n  /**\n   * 後方互換性のためのgetter - 現在の活力値を取得\n   * @returns {number} 現在の活力値\n   */\n  get vitality(): number {\n    return this._vitality.getValue()\n  }\n\n  /**\n   * 最大活力値を取得\n   * @returns {number} 最大活力値\n   */\n  get maxVitality(): number {\n    return this._vitality.getMax()\n  }\n\n  /**\n   * 現在の保険料負担を取得\n   * @returns {number} 保険料負担額\n   */\n  get insuranceBurden(): number {\n    return this._insuranceBurden.getValue()\n  }\n\n  /**\n   * 完了したチャレンジ数を取得\n   * @returns {number} 完了したチャレンジ数\n   */\n  get challengesCompleted(): number {\n    return this.stats.challengesCompleted || 0\n  }\n\n  /**\n   * 値オブジェクトとしての活力取得\n   * @returns {Vitality} 活力値オブジェクト\n   */\n  getVitality(): Vitality {\n    return this._vitality\n  }\n\n  /**\n   * 値オブジェクトとしての保険料負担取得\n   * @returns {InsurancePremium} 保険料負担値オブジェクト\n   */\n  getInsuranceBurden(): InsurancePremium {\n    return this._insuranceBurden\n  }\n\n  /**\n   * ダメージを適用して活力を減少させる\n   * @param {number} damage - 適用するダメージ量\n   * @throws {Error} ダメージが負の値の場合\n   */\n  applyDamage(damage: number): void {\n    // 型チェック\n    if (damage === null || damage === undefined) {\n      throw new Error('Change amount must not be null or undefined')\n    }\n    if (typeof damage !== 'number') {\n      throw new Error('Change amount must be a number')\n    }\n    if (!isFinite(damage)) {\n      throw new Error('Change amount must be a finite number')\n    }\n\n    // ダメージを直接活力に適用\n    this.updateVitality(-damage)\n  }\n\n\n\n  /**\n   * 体力を回復させる\n   * @param {number} amount - 回復量\n   * @throws {Error} 回復量が負の値の場合\n   */\n  heal(amount: number): void {\n    if (this.status === 'game_over') {\n      console.warn('[Game] Cannot heal: Game is over')\n      return\n    }\n    // 型チェック\n    if (amount === null || amount === undefined) {\n      throw new Error('Change amount must not be null or undefined')\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Change amount must be a number')\n    }\n    if (!isFinite(amount)) {\n      throw new Error('Change amount must be a finite number')\n    }\n    this.updateVitality(amount)\n  }\n\n  /**\n   * 現在のリスクプロファイルを取得\n   * @returns {RiskProfile} リスクプロファイル\n   */\n  getRiskProfile(): RiskProfile {\n    return this._riskProfile\n  }\n\n  /**\n   * プレイヤー履歴を取得\n   * @returns {PlayerHistory} プレイヤー履歴\n   */\n  getPlayerHistory(): PlayerHistory {\n    return { ...this._playerHistory }\n  }\n\n  /**\n   * 利用可能体力を取得（保険料負担を考慮）\n   * キャッシュによる最適化版\n   * @returns {number} 保険料負担を差し引いた実質的な利用可能体力\n   */\n  getAvailableVitality(): number {\n    const currentTime = Date.now()\n\n    // キャッシュが有効な場合（50ms以内）は計算をスキップ\n    if (!this._dirtyFlags.vitality && !this._dirtyFlags.burden &&\n      currentTime - this._cachedValues.lastUpdateTime < 50) {\n      return this._cachedValues.availableVitality\n    }\n\n    const result = this.vitality - this.insuranceBurden\n\n    // キャッシュを更新\n    this._cachedValues.availableVitality = result\n    this._cachedValues.lastUpdateTime = currentTime\n    this._dirtyFlags.vitality = false\n    this._dirtyFlags.burden = false\n\n    return result\n  }\n\n  /**\n   * 自由度スコアを計算 (0.0 to 1.0)\n   * 保険料負担が低いほど高くなる\n   */\n  getFreedomScore(): number {\n    const burden = this.insuranceBurden\n    // 負担が0なら1.0 (完全自由)\n    // 負担が最大活力の20%以上なら0.0 (不自由)\n    const maxBurden = this.maxVitality * 0.2\n    if (burden === 0) return 1.0\n\n    const freedom = 1.0 - (burden / maxBurden)\n    return Math.max(0, Math.min(1.0, freedom))\n  }\n\n  /**\n   * ゲームオーバーかどうか判定\n   * 以下の条件でゲームオーバーとなる:\n   * 1. ステータスが 'game_over'\n   * 2. 活力が0以下\n   * 3. 手札に老化カードが3枚以上（新ルール）\n   * @returns {boolean} ゲームオーバーの場合true\n   */\n  isGameOver(): boolean {\n    return this.status === 'game_over' ||\n      this._vitality.isDepleted() ||\n      this.hasAgingCardGameOver()\n  }\n\n  /**\n   * 老化カードによるゲームオーバー条件をチェック\n   * 手札に老化カードが3枚以上あるとゲームオーバー\n   * @returns {boolean} 老化カードゲームオーバーの場合true\n   */\n  hasAgingCardGameOver(): boolean {\n    return this.hand.filter(c => c.type === 'aging').length >= 3\n  }\n\n\n\n  /**\n   * 老化カードゲームオーバー条件をチェックし、保険があれば発動\n   * @returns {boolean} 条件に該当した場合true (ゲームオーバー または 保険発動)\n   */\n  checkAgingCardGameOverCondition(): boolean {\n    if (this.hasAgingCardGameOver()) {\n      console.log('[Game] Aging Card Game Over Condition Met!')\n\n      // 障害保険チェック\n      const insurance = this.activeInsurances.find(c =>\n        c.insuranceTriggerType === 'on_aging_gameover'\n      )\n\n      if (insurance) {\n        console.log('[Game] Disability Insurance found! Triggering claim.')\n        this.triggerInsuranceClaim(insurance, 'on_aging_gameover')\n        // 保険発動待ち状態になるため、ここではゲームオーバーにしない\n        // ただし、もし保険を拒否すればゲームオーバーになる必要がある\n        // declineInsuranceClaim内で再度チェックするか、\n        // 保険拒否時は即座にゲームオーバーにするロジックが必要\n        return true\n      }\n\n      console.log('[Game] No insurance found. Game Over.')\n      this.changeStatus('game_over')\n      return true\n    }\n    return false\n  }\n\n  /**\n   * 手札の老化カード数を取得\n   * @returns {number} 老化カードの枚数\n   */\n  getAgingCardCount(): number {\n    return this.hand.filter(card => card.type === 'aging').length\n  }\n\n  /**\n   * 保険を追加（簡易版テスト用）\n   * @param {Card} card - 追加する保険カード\n   * @throws {Error} 保険カード以外が渡された場合\n   */\n  addInsurance(card: Card): void {\n    this.insuranceService.addInsurance(this, card)\n  }\n\n  /**\n   * 全ての保険を強制失効させる\n   * 活力不足などで保険料が支払えない場合に使用\n   */\n  expireAllInsurances(): void {\n    if (this.activeInsurances.length === 0) return\n\n    // 配列を展開して追加（pushが使えることを前提）\n    this.activeInsurances.forEach(card => this.expiredInsurances.push(card))\n    this.activeInsurances = []\n\n    // 負担額を更新\n    this.updateInsuranceBurden()\n\n    console.log('[Game] All insurances expired due to insufficient vitality')\n  }\n\n  /**\n   * ゲームIDを生成\n   * @returns {string} ユニークなゲームID\n   * @private\n   */\n  private generateId(): string {\n    return IdGenerator.generateGameId()\n  }\n\n  /**\n   * ゲームを開始する\n   * @throws {Error} 既にゲームが開始されている場合\n   */\n  start(): void {\n    if (this.status !== 'not_started') {\n      throw new Error('Game has already started')\n    }\n\n    this.changeStatus('in_progress')\n    this.startedAt = new Date()\n\n    // v2: Start with Character Selection\n    // this.startDreamSelectionPhase() -> moved to after character selection\n    this.changePhase('character_selection')\n    console.info('[Game Phase] Character Selection Started')\n  }\n\n  /**\n   * キャラクターを選択\n   */\n  selectCharacter(characterId: string): void {\n    if (this.phase !== 'character_selection') throw new Error('Not in character selection phase')\n\n    const character = AVAILABLE_CHARACTERS.find(c => c.id === characterId)\n    if (!character) throw new Error('Invalid character selection')\n\n    this.config.characterId = characterId\n\n    // Re-apply modifiers logic\n    const ageParams = GameConstantsAccessor.getStageParameters(this.stage)\n    const baseStarting = this.config.startingVitality\n    const startVal = baseStarting + character.initialVitalityModifier\n    const maxVal = ageParams.maxVitality + character.initialVitalityModifier\n\n    const actualMax = Math.max(startVal, maxVal)\n    this._vitality = Vitality.create(Math.min(startVal, actualMax), actualMax)\n\n    console.log(`[Game] Character switched to ${character.name}. Vitality: ${this.vitality}/${this.maxVitality}`)\n\n    // Proceed to Dream Selection\n    this.startDreamSelectionPhase()\n  }\n\n  /**\n   * 夢選択フェーズを開始\n   */\n  startDreamSelectionPhase(): void {\n    const dreams = CardFactory.createDreamCards()\n    // random 3\n    const shuffled = dreams.sort(() => Math.random() - 0.5).slice(0, 3)\n\n    this.cardManager.setCardChoices(shuffled)\n    this.changePhase('dream_selection')\n    console.info('[Game Phase] Dream Selection Started')\n  }\n\n  /**\n   * 夢カードを選択\n   */\n  async selectDream(card: Card): Promise<void> {\n    if (this.phase !== 'dream_selection') throw new Error('Not in dream selection phase')\n\n    const choices = this.cardManager.getState().cardChoices\n    if (!choices?.some(c => c.id === card.id)) throw new Error('Invalid dream selection')\n\n    this.selectedDream = card\n    console.info(`[Game Event] Selected Dream: ${card.name}`)\n\n    this.cardManager.clearCardChoices()\n\n    // Start actual game loop\n    this.changePhase('draw')\n    this.changeTurn(1)\n\n    // Initial Draw - NOT performed here\n    // v2: 課題選択後にドローする仕様（ドキドキ感のため）\n  }\n\n  /**\n   * カードをドローする（リファクタリング版）\n   * @param {number} count - ドローする枚数\n   * @returns {Promise<Card[]>} ドローしたカードの配列\n   */\n  async drawCards(count: number): Promise<Card[]> {\n    console.debug('[Game] drawCards called', count)\n    const result = await this.actionProcessor.executeAction<number, Card[]>('draw_cards', this, count)\n    console.debug('[Game] actionProcessor result:', result)\n\n    if (!result.success) {\n      console.error('[Game] drawCards failed:', result.error)\n      throw new Error(result.error || 'カードドローに失敗しました')\n    }\n\n    // 老化カードチェック\n    this.checkAgingCardGameOverCondition()\n\n    return result.data || []\n  }\n\n\n  /**\n   * チャレンジフェーズを開始する (v2)\n   * 2枚引いて選択肢を提示する\n   */\n  startChallengePhase(): void {\n    // Phase check\n    if (this.phase !== 'draw') {\n      // Allow re-roll or other special cases? For now strict.\n      throw new Error(`Can only start challenge phase from draw phase. Current phase: ${this.phase}`)\n    }\n\n    const choices: Card[] = []\n\n    // 2枚引く - refill if needed\n    let card1 = this.cardManager.drawChallengeCard()\n    if (!card1) {\n      this.refillChallengeDeck()\n      card1 = this.cardManager.drawChallengeCard()\n    }\n    if (card1) choices.push(card1)\n\n    let card2 = this.cardManager.drawChallengeCard()\n    if (!card2) {\n      // Should rely on Deck implementation but refilling if 1st was null likely refilled enough\n      // If deck was size 1, maybe need refill again?\n      if (this.challengeDeck.getCards().length === 0) { // Check deck size\n        this.refillChallengeDeck()\n      }\n      card2 = this.cardManager.drawChallengeCard()\n    }\n    if (card2) choices.push(card2)\n\n    if (choices.length === 0) {\n      throw new Error('No challenge cards available')\n    }\n\n    // 難易度補正を適用\n    const modifiedChoices = choices.map(card => {\n      // 夢カード自体には適用しない？ -> 夢カードも難しくなっていくのが「人生のハードル」っぽい。\n      // 全てのチャレンジに適用。\n      if (this.challengeDifficultyModifier > 0 && card.isChallengeCard()) {\n        console.log(`[Game] Applying difficulty modifier +${this.challengeDifficultyModifier} to ${card.name}`)\n        return card.copy({\n          power: card.power + this.challengeDifficultyModifier\n        })\n      }\n      return card\n    })\n\n    this.cardManager.setCardChoices(modifiedChoices)\n    this.changePhase('challenge_choice')\n    console.debug(`[Game] Challenge choices set: ${modifiedChoices.map(c => c.name).join(', ')}`)\n  }\n\n  /**\n   * チャレンジを開始する\n   * @param {Card} challengeCard - 挑戦するチャレンジカード\n   * @throws {Error} 適切なフェーズ以外で実行された場合\n   */\n  startChallenge(challengeCard: Card): void {\n    // v2: If in challenge_choice phase, validate selection\n    if (this.phase === 'challenge_choice') {\n      const choices = this.cardManager.getState().cardChoices\n      if (!choices || !choices.some(c => c.id === challengeCard.id)) {\n        throw new Error('Selected card is not in current choices')\n      }\n\n      // 選択されなかったカードの処理\n      choices.forEach(c => {\n        if (c.id !== challengeCard.id) {\n          // 夢カードを選ばなかった場合のペナルティ（挫折）\n          if (c.isDreamCard()) {\n            console.log(`[Game] Dream ignored: ${c.name}. Increasing difficulty.`)\n            // 夢をあきらめたことによるペナルティ：今後の課題難易度が上昇\n            // ユーザー要望: 活力を失うのは安直。次ターン以降出てくる課題のレベルがアップする。\n            this.challengeDifficultyModifier += 2\n            console.log(`[Game] Difficulty modifier increased to ${this.challengeDifficultyModifier}`)\n          }\n\n          this.cardManager.addToDiscardPile(c)\n        }\n      })\n      this.cardManager.clearCardChoices()\n    }\n\n    this.challengeService.startChallenge(this, challengeCard)\n  }\n\n  /**\n   * チャレンジカードを直接引く（状態更新あり）\n   */\n  drawChallengeCard(): Card | null {\n    return this.cardManager.drawChallengeCard()\n  }\n\n  /**\n   * カードを選択/選択解除する\n   * @param {Card} card - 選択/解除するカード\n   * @returns {boolean} 選択状態（true:選択、false:解除）\n   */\n  toggleCardSelection(card: Card): boolean {\n    return this.cardManager.toggleCardSelection(card)\n  }\n\n  /**\n   * チャレンジを解決し、結果を返す\n   * @returns {ChallengeResult} チャレンジの結果\n   * @throws {Error} アクティブなチャレンジがない場合\n   */\n  resolveChallenge(): ChallengeResult {\n    const result = this.challengeService.resolveChallenge(this)\n\n    // 夢達成チェック: 夢チャレンジに成功したら勝利\n    if (result.success && this.currentChallenge?.isDreamCard()) {\n      console.log('[Game] 🎉 Dream achieved! Victory!')\n      this.changeStatus('victory')\n    }\n\n    return result\n  }\n\n  /**\n   * チャレンジ結果を記録し、統計とゲーム状態を更新（ApplicationService用）\n   * @param {number} totalPower プレイヤーの総パワー\n   * @param {boolean} success チャレンジの成功/失敗\n   */\n  recordChallengeResult(success: boolean): void {\n    // 統計更新\n    this.stats.totalChallenges++\n    if (success) {\n      this.stats.successfulChallenges++\n      if (!this.stats.challengesCompleted) {\n        this.stats.challengesCompleted = 0\n      }\n      this.stats.challengesCompleted++\n    } else {\n      this.stats.failedChallenges++\n      if (!this.stats.challengesFailed) {\n        this.stats.challengesFailed = 0\n      }\n      this.stats.challengesFailed++\n    }\n  }\n\n  /**\n   * カードを選択してデッキに追加（従来のカード選択フェーズ用）\n   */\n  selectCard(cardId: string): boolean {\n    if (this.phase !== 'card_selection') {\n      throw new Error('Not in card selection phase')\n    }\n\n    const selectedCard = this.cardManager.getCardChoiceById(cardId)\n    if (!selectedCard) {\n      throw new Error('Invalid card selection')\n    }\n\n    // カードをデッキに追加\n    this.cardManager.addToPlayerDeck(selectedCard)\n    this.stats.cardsAcquired++\n\n    // Phase 2-4: 保険カードの場合は管理リストに追加\n    if (selectedCard.type === 'insurance') {\n      this.activeInsurances.push(selectedCard)\n      // Phase 3: 保険料負担を更新\n      this.updateInsuranceBurden()\n    }\n\n    // 選択肢をクリア\n    this.cardManager.clearCardChoices()\n\n    // 解決フェーズに移行（ターン終了可能状態）\n    this.changePhase('resolution')\n\n    return true\n  }\n\n  /**\n   * 保険種類を選択してカードを作成・追加\n   */\n  selectInsuranceType(insuranceType: string, durationType: 'term' | 'whole_life'): InsuranceTypeSelectionResult {\n    return this.insuranceService.selectInsuranceType(this, insuranceType, durationType)\n  }\n\n  /**\n   * 保険選択をスキップ（保険に入らない選択）\n   * 保険料負担なしで進行できるが、リスクに対する保障がない\n   */\n  skipInsuranceSelection(): void {\n    console.log('[Game] Skipping insurance selection - proceeding without insurance')\n\n    // 保険種類選択肢をクリア\n    this.insuranceTypeChoices = undefined\n\n    // 解決フェーズに移行\n    this.changePhase('resolution')\n  }\n\n  /**\n   * 保険発動をトリガー\n   */\n  triggerInsuranceClaim(insurance: Card, triggerType: InsuranceTriggerType): void {\n    console.log(`[Game] Insurance Triggered: ${insurance.name} (${triggerType})`)\n    this.pendingInsuranceClaim = {\n      insurance,\n      triggerType\n    }\n  }\n\n  /**\n   * 保険請求を実行（効果適用と契約終了）\n   */\n  async resolveInsuranceClaim(): Promise<void> {\n    if (!this.pendingInsuranceClaim) return\n\n    const { insurance, triggerType } = this.pendingInsuranceClaim\n    console.log(`[Game] Resolving Insurance Claim: ${insurance.name}`)\n\n    // 1. 契約終了（削除）\n    this.removeInsurance(insurance)\n\n    // 2. 期限切れ（使用済み）リストに追加\n    this.expiredInsurances = this.expiredInsurances || []\n    this.expiredInsurances.push(insurance)\n\n    // 3. 効果適用\n    await this.applyInsuranceEffect(triggerType)\n\n    // 4. クレーム状態をクリア\n    this.pendingInsuranceClaim = undefined\n\n    // StateManager通知はフェーズ変更などで行うため、ここでは特別な保存は不要\n    // this.stateManager.saveState(this)\n  }\n\n  /**\n   * 保険効果を適用\n   */\n  private async applyInsuranceEffect(triggerType: InsuranceTriggerType): Promise<void> {\n    switch (triggerType) {\n      case 'on_aging_gameover':\n        // 障害保険: 手札を全て捨てて引き直す\n        console.log('[Game] Applying Disability Insurance Effect: Reset Hand')\n        this.cardManager.discardHand()\n        // 初期枚数（5枚）引く\n        await this.drawCards(this.config.startingHandSize)\n        break\n\n      case 'on_death':\n        // 生命保険: 活力回復\n        console.log('[Game] Applying Life Insurance Effect: Revive')\n        this.heal(10) // Fixed amount 10\n        break\n\n      case 'on_heavy_damage':\n        console.log('[Game] Applying Medical Insurance Effect: Damage Reduction')\n        // 医療保険: ダメージを1に軽減\n        this.applyDamage(1)\n        // コンテキストクリアは不要（終了後にpendingごと消える）\n        break\n\n      case 'on_demand':\n        console.log('[Game] Applying Income Protection Effect: Skip Challenge')\n        // 就業不能保険: チャレンジをスキップ\n        // 現在のチャレンジ状態をクリア\n        this.currentChallenge = undefined\n        this.cardManager.clearSelection()\n\n        // フェーズを解決（の後の状態）へ\n        // 結果なしで解決フェーズへ移行すれば、報酬選択なしで次へ進めるはず\n        this.changePhase('resolution')\n        break\n    }\n  }\n\n\n\n  /**\n   * 保険請求を拒否\n   */\n  declineInsuranceClaim(): void {\n    console.log(`[Game] Insurance Claim Declined`)\n\n    const triggerType = this.pendingInsuranceClaim?.triggerType\n    const context = this.pendingInsuranceClaim?.context\n\n    // 1. 保留処理の再開 (on_heavy_damage)\n    if (triggerType === 'on_heavy_damage' && context?.damage) {\n      console.log('[Game] Applying original damage after decline')\n      this.applyDamage(context.damage)\n    }\n\n    // クレーム状態をクリア\n    this.pendingInsuranceClaim = undefined\n\n    // 2. ゲームオーバー確定チェック (on_death, on_aging_gameover)\n    // 注意: applyDamageで再度on_deathチェックが入る可能性があるが、pendingがundefinedならgame_overになるはず\n    // しかしここでのチェックは、保険発動前に「止めていた」ゲームオーバー処理を再開するため\n    if (triggerType === 'on_death') {\n      if (this._vitality.isDepleted()) {\n        console.log('[Game] Life Insurance declined. Game Over confirmed.')\n        this.changeStatus('game_over')\n      }\n    }\n    else if (triggerType === 'on_aging_gameover') {\n      if (this.hasAgingCardGameOver()) {\n        console.log('[Game] Disability Insurance declined. Game Over confirmed.')\n        this.changeStatus('game_over')\n      }\n    }\n  }\n\n  /**\n   * 保険を削除\n   */\n  private removeInsurance(card: Card): void {\n    this.insuranceService.removeInsurance(this, card)\n  }\n\n  /**\n   * 活力を更新（契約による設計版）\n   * \n   * 事前条件: changeは数値である\n   * 事後条件: \n   *   - 活力は0以上maxVitality以下である\n   *   - change < 0の場合、活力は減少または0になる\n   *   - change > 0の場合、活力は増加またはmaxVitalityになる\n   *   - 統計情報が適切に更新される\n   * 不変条件: ゲーム状態の整合性が保たれる\n   */\n  private updateVitality(change: number): void {\n    // 事前条件チェック\n    if (typeof change !== 'number' || !isFinite(change)) {\n      throw new Error('Change amount must be a finite number')\n    }\n\n    // 変更がない場合は処理をスキップ\n    if (change === 0) return\n\n    // 医療保険チェック (on_heavy_damage) - ダメージ適用前に判定\n    if (change < 0 && Math.abs(change) >= 10) {\n      // activeInsurancesの確認\n      const insurance = this.activeInsurances.find(c => c.insuranceTriggerType === 'on_heavy_damage')\n      if (insurance) {\n        this.triggerInsuranceClaim(insurance, 'on_heavy_damage')\n\n        // 保留状態で処理中断（ダメージ適用しない）\n        if (this.pendingInsuranceClaim) {\n          this.pendingInsuranceClaim.context = { damage: Math.abs(change) }\n          return\n        }\n      }\n    }\n\n    // const previousVitality = this.vitality // Unused variable removed\n\n    if (change >= 0) {\n      this._vitality = this._vitality.increase(change)\n    } else {\n      this._vitality = this._vitality.decrease(-change)\n    }\n\n    // 事後条件チェック\n    const currentVitality = this.vitality\n    if (currentVitality < 0 || currentVitality > this.maxVitality) {\n      console.warn(`Vitality invariant violation: ${currentVitality} not in [0, ${this.maxVitality}]`)\n      // Auto-correct to prevent crash\n      if (currentVitality > this.maxVitality) {\n        this._vitality = this._vitality.withMaxVitality(this.maxVitality)\n      } else if (currentVitality < 0) {\n        // Should be handled by Vitality class but just in case\n        this._vitality = Vitality.create(0, this.maxVitality)\n      }\n    }\n\n    // ダーティフラグを設定\n    this._dirtyFlags.vitality = true\n    this._dirtyFlags.stats = true\n\n    // 統計更新（防御的プログラミング）\n    if (currentVitality > this.stats.highestVitality) {\n      this.stats.highestVitality = currentVitality\n    }\n\n    // ダメージ履歴を記録\n    if (change < 0) {\n      this._playerHistory.totalDamageTaken += Math.abs(change)\n    }\n\n    // ゲームオーバー判定\n    if (this._vitality.isDepleted()) {\n      console.error('[DEBUG] Vitality Depleted!')\n      console.error(`[DEBUG] Active Insurances: ${this.activeInsurances.length}`)\n      this.activeInsurances.forEach((c, i) => console.error(`[DEBUG] Ins[${i}]: id=${c.id}, trigger=${c.insuranceTriggerType}`))\n\n      // 生命保険チェック (on_death)\n      const insurance = this.activeInsurances.find(c => c.insuranceTriggerType === 'on_death')\n      if (insurance) {\n        console.error(`[DEBUG] FOUND Life Insurance: ${insurance.id}`)\n        this.triggerInsuranceClaim(insurance, 'on_death')\n        // まだゲームオーバーにしない\n        return\n      } else {\n        console.error('[DEBUG] NOT FOUND Life Insurance')\n      }\n\n      this.changeStatus('game_over')\n    }\n\n    // 不変条件チェック\n    // Note: ターン切れによるゲームオーバーもあり得るため、活力が残っていてもOKとする\n    // if (this.status === 'game_over' && !this._vitality.isDepleted()) {\n    //   throw new Error('Game over state inconsistency: vitality not depleted')\n    // }\n  }\n\n  // ...\n\n\n\n\n\n\n  /**\n   * ステージに応じて活力上限を更新\n   * 年齢が上がるにつれて最大活力が減少し、現実的な体力変化を反映\n   */\n  private updateMaxVitalityForAge(): void {\n    const ageParams = GameConstantsAccessor.getStageParameters(this.stage)\n\n    // Legacy support or fallback if accessor returns generic type without maxVitality (it shouldn't)\n    if (!ageParams) {\n      console.warn(`Unknown stage parameters for: ${this.stage}`)\n      return\n    }\n\n    const newMaxVitality = ageParams.maxVitality\n\n    // 現在の活力値が新しい上限を超える場合は調整\n    const currentValue = this._vitality.getValue()\n    if (currentValue > newMaxVitality) {\n      console.info(`[Stage] ${ageParams.label}: Max Vitality adjusted to ${newMaxVitality}`)\n      this._vitality = this._vitality.withMaxVitality(newMaxVitality)\n    } else {\n      // 上限のみ更新（現在値はそのまま）\n      this._vitality = Vitality.create(currentValue, newMaxVitality)\n    }\n\n    // ダーティフラグを設定\n    this._dirtyFlags.vitality = true\n  }\n\n  /**\n   * 次のターンへ\n   */\n  nextTurn(): TurnResult {\n    this.updateScore()\n    return this.turnManager.nextTurn(this)\n  }\n\n\n  /**\n   * ステージを進める（手動用）\n   */\n  advanceStage(): void {\n    const advanceResult = this.stageManager.advanceStage(this.stage)\n\n    if (advanceResult.isCompleted) {\n      // 最終ステージクリア\n      this.changeStatus('victory')\n    } else if (advanceResult.newStage) {\n      this.changeStage(advanceResult.newStage)\n    }\n  }\n\n  /**\n   * チャレンジデッキを現在のステージ用のカードで補充する\n   */\n  refillChallengeDeck(): void {\n    const newCards = CardFactory.createChallengeCards(this.stage)\n    this.cardManager.refillChallengeDeck(newCards)\n    console.debug(`[Game] Challenge deck refilled for stage ${this.stage}: ${newCards.length} cards`)\n  }\n\n  /**\n   * 手札を取得\n   */\n  get hand(): Card[] {\n    return this.cardManager.getState().hand\n  }\n\n  /**\n   * 手動で使用可能な保険（就業不能保険など）を取得\n   */\n  get availableOnDemandInsurances(): Card[] {\n    return this.activeInsurances.filter(c => c.insuranceTriggerType === 'on_demand')\n  }\n\n  /**\n   * 捨て札を取得\n   */\n  get discardPile(): Card[] {\n    return this.cardManager.getState().discardPile\n  }\n\n  /**\n   * プレイヤーデッキを取得\n   */\n  get playerDeck(): Deck {\n    return this.cardManager.getState().playerDeck\n  }\n\n  /**\n   * チャレンジデッキを取得\n   */\n  get challengeDeck(): Deck {\n    return this.cardManager.getState().challengeDeck\n  }\n\n  /**\n   * 選択中のカードを取得\n   */\n  get selectedCards(): Card[] {\n    return this.cardManager.getState().selectedCards\n  }\n\n  /**\n   * カード選択肢を取得\n   */\n  get cardChoices(): Card[] | undefined {\n    return this.cardManager.getState().cardChoices\n  }\n\n  /**\n   * 保険種類選択肢を取得\n   */\n  get currentInsuranceTypeChoices(): InsuranceTypeChoice[] | undefined {\n    return this.insuranceTypeChoices\n  }\n\n  /**\n   * ゲームが進行中かどうか\n   */\n  isInProgress(): boolean {\n    return this.status === 'in_progress'\n  }\n\n  /**\n   * ゲームが終了しているかどうか\n   */\n  isCompleted(): boolean {\n    return this.status === 'game_over' || this.status === 'victory'\n  }\n\n  /**\n   * Phase 4: 夢カードの必要パワーを年齢調整込みで計算\n   */\n  getDreamRequiredPower(challenge: Card): number {\n    // 夢カードでない場合は基本パワーをそのまま返す\n    // NOTE: 通常のチャレンジでもdreamCategory（身体的/知識的）が設定されていれば年齢調整を適用する\n    if (!challenge.dreamCategory) {\n      return challenge.power\n    }\n\n    // 青年期は調整なし\n    if (this.stage === 'youth') {\n      return challenge.power\n    }\n\n    // 中年期・充実期の年齢調整を適用\n    const adjustment = DREAM_AGE_ADJUSTMENTS[challenge.dreamCategory]\n    const adjustedPower = challenge.power + adjustment\n\n    // 最小値は1\n    return Math.max(1, adjustedPower)\n  }\n\n  /**\n   * Phase 2-4: 期限切れの保険カードを取得（通知用）\n   */\n  getExpiredInsurances(): Card[] {\n    return [...this.expiredInsurances]\n  }\n\n  /**\n   * Phase 2-4: 期限切れ通知をクリア\n   */\n  clearExpiredInsurances(): void {\n    this.expiredInsurances = []\n  }\n\n  /**\n   * 期限が近い保険カードを取得（残り2ターン以下）\n   */\n  getExpiringsSoonInsurances(): Card[] {\n    return this.expirationManager.getExpiringSoonInsurances(this.activeInsurances)\n  }\n\n  /**\n   * 保険期限切れの警告メッセージを取得\n   */\n  getExpirationWarnings(): string[] {\n    return this.expirationManager.getExpirationWarnings(this.activeInsurances)\n  }\n\n  /**\n   * ステージを設定（内部使用）\n   */\n  setStage(stage: GameStage): void {\n    this.changeStage(stage)\n  }\n\n  /**\n   * Phase 2-4: 現在有効な保険カードを取得\n   */\n  getActiveInsurances(): Card[] {\n    return [...this.activeInsurances]\n  }\n\n  /**\n   * スコア計算\n   */\n  private updateScore(): void {\n    // Basic score calculation\n    // Vitality * 1\n    // Active Insurance: Coverage * 0.1? Or just a flat bonus per active card?\n    // Let's go with Rulebook v2 approximation: Vitality + (Total Coverage / 10)\n    let insuranceScore = 0\n    this.activeInsurances.forEach(card => {\n      if (card.coverage) {\n        insuranceScore += Math.floor(card.coverage / 10)\n      }\n    })\n\n    this.score = this.vitality + insuranceScore\n  }\n\n  /**\n   * プレイヤーに最適な保険予算を提案\n   * \n   * @param riskProfile リスクプロファイル\n   * @returns 推奨保険予算\n   */\n  getRecommendedInsuranceBudget(riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'): InsurancePremium {\n    return this.premiumCalculationService.calculateOptimalInsuranceBudget(\n      this.vitality,\n      this.stage,\n      riskProfile\n    )\n  }\n\n  /**\n   * 特定の保険カードの総合保険料を取得\n   * \n   * @param card 保険カード\n   * @returns 年齢・種別・リスク調整済み保険料\n   */\n  calculateCardPremium(card: Card): InsurancePremium {\n    if (card.type !== 'insurance') {\n      throw new Error('Card must be an insurance card')\n    }\n\n    return this.premiumCalculationService.calculateComprehensivePremium(card, this.stage, this._riskProfile)\n  }\n\n  /**\n   * Phase 3: 保険料負担を計算（最適化版）\n   * \n   * キャッシュとダーティフラグによる高速化\n   */\n  calculateInsuranceBurden(): number {\n    const currentTime = Date.now()\n\n    // キャッシュが有効で保険状態が変わっていない場合は再計算をスキップ\n    if (!this._dirtyFlags.insurance &&\n      currentTime - this._cachedValues.lastUpdateTime < 100 &&\n      this._cachedValues.totalInsuranceCount === this.activeInsurances.length) {\n      return this._cachedValues.insuranceBurden\n    }\n\n    const burden = this.insuranceService.calculateInsuranceBurden(this)\n\n    // キャッシュ更新\n    this._cachedValues.insuranceBurden = burden\n    this._cachedValues.totalInsuranceCount = this.activeInsurances.length\n    this._cachedValues.lastUpdateTime = currentTime\n    this._dirtyFlags.insurance = false\n\n    return burden\n  }\n\n  /**\n   * Phase 3: 保険料負担を更新（最適化版）\n   */\n  private updateInsuranceBurden(): void {\n    this.insuranceService.updateInsuranceBurden(this)\n  }\n\n\n\n  /**\n   * Phase 3: 総合パワーを詳細に計算\n   * @param cards 使用するカード\n   * @returns パワーの詳細な内訳\n   */\n  calculateTotalPower(cards: Card[]): {\n    base: number\n    insurance: number\n    burden: number\n    total: number\n  } {\n    return this.challengeService.calculateTotalPower(this, cards)\n  }\n\n\n\n\n\n\n\n  /**\n   * テスト用: カードを手札に直接追加\n   */\n  addCardToHand(card: Card): void {\n    this.cardManager.addToHand(card)\n  }\n\n  /**\n   * テスト用: カードを捨て札に直接追加\n   */\n  addCardToDiscardPile(card: Card): void {\n    this.cardManager.addToDiscardPile(card)\n  }\n\n  /**\n   * テスト用: プレイヤーデッキにカードを追加\n   */\n  addCardToPlayerDeck(card: Card): void {\n    this.cardManager.addToPlayerDeck(card)\n  }\n\n  /**\n   * テスト用: 手札をクリア\n   */\n  clearHand(): void {\n    const state = this.cardManager.getState()\n    state.hand = []\n    this.cardManager.setState(state)\n  }\n\n  /**\n   * テスト用: 手札を設定\n   */\n  setHand(cards: Card[]): void {\n    const state = this.cardManager.getState()\n    state.hand = [...cards]\n    this.cardManager.setState(state)\n  }\n\n  /**\n   * テスト用: カード選択肢を設定\n   */\n  setCardChoices(choices: Card[]): void {\n    this.cardManager.setCardChoices(choices)\n  }\n\n  /**\n   * テスト用: フェーズを設定\n   */\n  setPhase(phase: GamePhase): void {\n    this.changePhase(phase)\n  }\n\n\n  /**\n   * ゲーム状態のスナップショットを取得（最適化版）\n   */\n  getSnapshot(): IGameState {\n    const cardState = this.cardManager.getState()\n\n    // オブジェクトプールから再利用可能なオブジェクトを取得\n    let snapshot = Game.OBJECT_POOLS.gameStates.pop()\n\n    if (!snapshot) {\n      snapshot = {}\n    }\n\n    // プロパティを設定（配列は適切にコピー）\n    Object.assign(snapshot, {\n      id: this.id,\n      status: this.status,\n      phase: this.phase,\n      stage: this.stage,\n      turn: this.turn,\n      vitality: this.vitality,\n      maxVitality: this.maxVitality,\n      playerDeck: this.playerDeck, // Getter uses getState()\n      hand: [...this.hand], // Getter uses getState()\n      discardPile: [...this.discardPile], // Getter uses getState()\n      challengeDeck: this.challengeDeck, // Getter uses getState()\n      currentChallenge: this.currentChallenge,\n      selectedCards: [...cardState.selectedCards], // 配列をコピー\n      cardChoices: cardState.cardChoices ? [...cardState.cardChoices] : undefined, // 配列をコピー\n      insuranceTypeChoices: this.insuranceTypeChoices,\n      activeInsurances: [...this.activeInsurances],\n      expiredInsurances: [...this.expiredInsurances],\n      insuranceBurden: this.insuranceBurden,\n      stats: { ...this.stats },\n      config: { ...this.config },\n      startedAt: this.startedAt,\n      completedAt: this.completedAt\n    })\n\n    return snapshot as IGameState\n  }\n\n  /**\n   * 状態変更イベントリスナーを設定\n   * Observer Pattern の実装\n   */\n  private setupStateListeners(): void {\n    // フェーズ変更の監視\n    this.stateManager.addEventListener('phase_change', (event) => {\n      console.info(`[Phase] ${event.previousValue} -> ${event.newValue}`)\n      this.handlePhaseChange(event.previousValue, event.newValue)\n    })\n\n    // ステージ変更の監視\n    this.stateManager.addEventListener('stage_change', (event) => {\n      console.info(`[Stage] ${event.previousValue} -> ${event.newValue}`)\n      this.updateMaxVitalityForAge()\n    })\n\n    // ターン変更の監視\n    this.stateManager.addEventListener('turn_change', (event) => {\n      console.info(`[Turn] ${event.previousValue} -> ${event.newValue}`)\n      this.stats.turnsPlayed = event.newValue\n    })\n\n    // ステータス変更の監視\n    this.stateManager.addEventListener('status_change', (event) => {\n      console.info(`[Status] ${event.previousValue} -> ${event.newValue}`)\n\n      if (event.newValue === 'game_over' || event.newValue === 'victory') {\n        this.completedAt = new Date()\n      }\n    })\n  }\n\n  /**\n   * フェーズ変更のハンドリング\n   */\n  private handlePhaseChange(previousPhase: GamePhase, newPhase: GamePhase): void {\n    // previousPhase is reserved for future logic\n    void previousPhase\n    switch (newPhase) {\n      case 'draw':\n        // ドローフェーズ開始時の処理\n        break\n      case 'challenge':\n        // チャレンジフェーズ開始時の処理\n        break\n      case 'card_selection':\n        // カード選択フェーズ開始時の処理\n        break\n      case 'resolution':\n        // 解決フェーズ開始時の処理\n        break\n    }\n  }\n\n  /**\n   * フェーズを安全に変更\n   */\n  private changePhase(newPhase: GamePhase): void {\n    const previousPhase = this.phase\n    this.phase = newPhase\n    this.stateManager.notifyPhaseChange(previousPhase, newPhase)\n  }\n\n  /**\n   * ステータスを安全に変更\n   */\n  /**\n   * 外部からゲームを終了させる（勝利または敗北）\n   */\n  finishGame(isWin: boolean): void {\n    this.changeStatus(isWin ? 'victory' : 'game_over')\n  }\n\n  private changeStatus(newStatus: GameStatus): void {\n    const previousStatus = this.status\n    this.status = newStatus\n    this.stateManager.notifyStatusChange(previousStatus, newStatus)\n  }\n\n  /**\n   * ステージを安全に変更\n   */\n  private changeStage(newStage: GameStage): void {\n    const previousStage = this.stage\n    this.stage = newStage\n    this.stateManager.notifyStageChange(previousStage, newStage)\n  }\n\n  /**\n   * ターンを安全に変更\n   */\n  private changeTurn(newTurn: number): void {\n    const previousTurn = this.turn\n    this.turn = newTurn\n    this.stateManager.notifyTurnChange(previousTurn, newTurn)\n  }\n\n  /**\n   * 状態管理システムにアクセス（テスト・拡張用）\n   */\n  getStateManager(): GameStateManager {\n    return this.stateManager\n  }\n\n  /**\n   * アクション処理システムにアクセス（テスト・拡張用）\n   */\n  getActionProcessor(): GameActionProcessor {\n    return this.actionProcessor\n  }\n\n  /**\n   * オブジェクトプールへのスナップショット返却\n   */\n  static releaseSnapshot(snapshot: IGameState): void {\n    // プールサイズを制限（メモリリーク防止）\n    if (Game.OBJECT_POOLS.gameStates.length < 10) {\n      // オブジェクトをクリア\n      Object.keys(snapshot).forEach(key => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        delete (snapshot as Record<string, any>)[key]\n      })\n      Game.OBJECT_POOLS.gameStates.push(snapshot as Partial<IGameState>)\n    }\n  }\n\n  /**\n   * パフォーマンス統計の取得\n   */\n  getPerformanceStats(): {\n    poolStats: {\n      gameStates: number\n      cards: number\n      challengeResults: number\n    }\n    cacheHitRate: number\n    dirtyFlags: Record<string, boolean>\n  } {\n    return {\n      poolStats: {\n        gameStates: Game.OBJECT_POOLS.gameStates.length,\n        cards: Game.OBJECT_POOLS.cards.length,\n        challengeResults: Game.OBJECT_POOLS.challengeResults.length\n      },\n      cacheHitRate: this._cachedValues.lastUpdateTime > 0 ? 0.85 : 0, // 概算\n      dirtyFlags: { ...this._dirtyFlags }\n    }\n  }\n\n  // === AI戦略システム ===\n\n  /**\n   * AI機能の有効/無効を設定\n   */\n  setAIEnabled(enabled: boolean): void {\n    this._aiEnabled = enabled\n    if (enabled) {\n      console.info(`[AI] System Enabled (Strategy: ${this._currentAIStrategy})`)\n    } else {\n      console.info('[AI] System Disabled')\n    }\n  }\n\n  /**\n   * AI機能の有効状態を取得\n   */\n  isAIEnabled(): boolean {\n    return this._aiEnabled\n  }\n\n  /**\n   * AI戦略を変更\n   */\n  setAIStrategy(strategyType: AIStrategyType): void {\n    this._currentAIStrategy = strategyType\n    this.aiStrategyService.setStrategy(strategyType)\n    console.info(`[AI] Strategy Changed: ${strategyType}`)\n  }\n\n  /**\n   * 現在のAI戦略を取得\n   */\n  getCurrentAIStrategy(): AIStrategyType {\n    return this._currentAIStrategy\n  }\n\n  /**\n   * AI戦略の統計情報を取得\n   */\n  getAIStatistics() {\n    return this.aiStrategyService.getStatistics()\n  }\n\n  /**\n   * AIによるチャレンジ自動選択\n   */\n  aiSelectChallenge(): Card | null {\n    if (!this._aiEnabled) {\n      throw new Error('AI is not enabled')\n    }\n\n    const availableChallenges = this.cardManager.getState().challengeDeck.getCards()\n    if (availableChallenges.length === 0) {\n      return null\n    }\n\n    const choice = this.aiStrategyService.autoSelectChallenge(availableChallenges, this)\n    console.debug(`[AI] Auto-selected challenge: ${choice.challenge.name} (Success Rate: ${(choice.successProbability * 100).toFixed(1)}%)`)\n    console.debug(`[AI] Reason: ${choice.reason}`)\n\n    return choice.challenge\n  }\n\n  /**\n   * AIによるカード自動選択\n   */\n  aiSelectCards(challenge: Card): Card[] {\n    if (!this._aiEnabled) {\n      throw new Error('AI is not enabled')\n    }\n\n    const availableCards = this.cardManager.getState().playerDeck.getCards()\n    const choice = this.aiStrategyService.autoSelectCards(challenge, availableCards, this)\n\n    console.debug(`[AI] Auto-selected cards: ${choice.cards.map(c => c.name).join(', ')}`)\n    console.debug(`[AI] Reason: ${choice.reason}`)\n    console.debug(`[AI] Expected Power: ${choice.expectedPower}`)\n\n    return choice.cards\n  }\n\n  /**\n   * AIによる完全自動プレイ（チャレンジ選択→カード選択→解決）\n   */\n  aiAutoPlay(): ChallengeResult | null {\n    if (!this._aiEnabled) {\n      throw new Error('AI is not enabled')\n    }\n\n    if (this.phase !== 'draw') {\n      throw new Error('Auto play can only be used during draw phase')\n    }\n\n    // 1. チャレンジを選択\n    const selectedChallenge = this.aiSelectChallenge()\n    if (!selectedChallenge) {\n      console.warn('[AI] No challenges available')\n      return null\n    }\n\n    // 2. チャレンジを開始\n    this.challengeService.startChallenge(this, selectedChallenge)\n\n    // 3. カードを選択\n    const selectedCards = this.aiSelectCards(selectedChallenge)\n\n    // 4. カードを選択状態にする\n    selectedCards.forEach(card => {\n      this.cardManager.toggleCardSelection(card)\n    })\n\n    // 5. チャレンジを解決\n    const result = this.challengeService.resolveChallenge(this)\n\n    // 6. 統計を記録\n    const challengeChoice = this.aiStrategyService.autoSelectChallenge([selectedChallenge], this)\n    const cardChoice = this.aiStrategyService.autoSelectCards(selectedChallenge, selectedCards, this)\n    this.aiStrategyService.recordDecision(this.turn, challengeChoice, cardChoice, result.success)\n\n    return result\n  }\n\n  /**\n   * AI設定のリセット\n   */\n  resetAISettings(): void {\n    this._aiEnabled = false\n    this._currentAIStrategy = 'balanced'\n    this.aiStrategyService.setStrategy('balanced')\n    this.aiStrategyService.clearHistory()\n    console.info('[AI] Settings Reset')\n  }\n}\n"],"names":["Deck","constructor","name","cards","__publicField","this","getName","size","length","isEmpty","addCard","card","push","addCards","drawCard","pop","drawCards","count","drawn","i","removeCard","cardId","index","findIndex","id","splice","shuffle","j","Math","floor","random","getCards","countCardsByType","type","filter","clear","clone","map","getStats","stats","total","byType","life","insurance","pitfall","averagePower","averageCost","totalPower","totalCost","forEach","power","cost","_CardPower","value","validate","create","MIN_POWER","Error","MAX_POWER","getValue","add","other","sum","max","min","powers","reduce","multiply","multiplier","result","isGreaterThan","isGreaterThanOrEqual","equals","toString","ZERO","MAX","CardPower","_InsurancePremium","MIN_PREMIUM","MAX_PREMIUM","premiums","premium","applyDiscount","discountRate","discountedValue","applyMultiplier","multipliedValue","isFree","isExpensive","EXPENSIVE_THRESHOLD","isHigherThan","isAffordableWith","availableVitality","FREE","InsurancePremium","IdGenerator","generate","prefix","Date","now","getRandomString","generateCardId","generateGameId","generateCommandId","generateNotificationId","generateFeedbackId","generateSequential","counter","generateUUID","uuid","replace","c","r","substr","resetCounter","getCurrentCounter","Card","params","description","_power","_cost","effects","imageUrl","category","insuranceType","coverage","penalty","ageBonus","durationType","remainingTurns","insuranceEffectType","insuranceTriggerType","dreamCategory","skillProperties","comboProperties","eventProperties","isUnlockable","unlockCondition","rewardType","getPower","getCost","hasEffect","effectType","some","effect","getEffect","find","isInsurance","isTermInsurance","isWholeLifeInsurance","getInsuranceEffectType","isDefensiveInsurance","isRecoveryInsurance","isSpecializedInsurance","calculateDamageReduction","totalReduction","reductionEffect","calculateTurnHeal","baseHeal","healEffect","calculateChallengeBonus","challengeType","bonusEffect","condition","includes","isDreamCard","copy","updates","decrementRemainingTurns","isExpired","hasPowerAtLeast","requiredPower","required","calculateEffectivePower","bonus","effectivePower","isLifeCard","isInsuranceCard","isPitfallCard","isSkillCard","isComboCard","isEventCard","isLegendaryCard","isChallengeCard","toDisplayString","display","join","decrementTurn","createLifeCard","powerSign","createChallengeCard","createInsuranceCard","createSkillCard","rarity","cooldown","common","rare","epic","legendary","remainingCooldown","masteryLevel","createComboCard","requiredCards","comboBonus","createEventCard","duration","globalEffect","createLegendaryCard","RiskRewardChallenge","riskLevel","super","successBonus","failurePenalty","insuranceImmunity","getRiskMultiplier","low","medium","high","extreme","calculateActualReward","baseReward","calculateActualPenalty","basePenalty","getRiskDescription","getChallengeDetails","toUpperCase","Boolean","createRiskChallenge","stage","template","youth","middle","fulfillment","CardFactory","calculateAgeBonus","createCardsFromDefinitions","definitions","createFn","def","createStarterLifeCards","createBasicInsuranceCards","createExtendedInsuranceCards","extendedCards","baseCards","additionalCards","createDiverseInsuranceCards","createTriggerInsuranceCards","createInsuranceTypeChoices","insuranceDefinitions","planA","cut","desc","planB","triggerType","limit","selectedDef","baseCard","termOption","wholeLifeOption","createTermInsuranceCard","choice","createWholeLifeInsuranceCard","createChallengeCards","challengeDefinitionsByStage","damage","isDream","shuffled","sort","selectedCount","selected","slice","challenges","createRiskRewardChallenges","dreamCards","createDreamCards","dreamCount","randomDream","riskDistribution","distribution","levelRandom","riskChallenge","createPitfallCards","createPitfallCard","basePower","baseCost","determineRewardType","createCard","base","createAgingCards","createFinalChallengeCard","createSkillCards","skillDefinitionsByStage","createComboCards","createEventCards","eventDefinitionsByStage","createLegendaryCards","createRewardCards","_CardManager","Set","initialize","playerDeck","challengeDeck","config","hand","discardPile","selectedCards","selectedIdsSet","cardChoices","agingDeck","insuranceMarket","activeInsurances","getState","_cachedState","_stateVersion","console","log","state","setState","invalidateCache","CARD_POOLS","drawResults","drawnCards","discardedCards","troubleCards","reshuffleDeck","warn","enforceHandLimit","toggleCardSelection","has","delete","clearSelection","discardSelectedCards","removedCard","addToHand","addToDiscardPile","addToPlayerDeck","maxHandSize","discarded","shift","setCardChoices","choices","clearCardChoices","getCardChoiceById","addAgingCardToDiscard","buyInsurance","removeCardFromGame","agingCard","getInsuranceMarket","getActiveInsurances","drawChallengeCard","refillChallengeDeck","getChallengeDeckSize","discardHand","CardManager","RiskFactor","factorType","getType","getRiskLevel","getPremiumMultiplier","impact","age","health","claims","lifestyle","adjust","adjustment","newValue","combine","weight","combinedValue","toFixed","RiskProfile","factors","empty","Map","set","withFactor","factor","newFactors","getFactor","get","getOverallRiskScore","totalScore","getTotalPremiumMultiplier","getSummary","overallScore","_InsurancePremiumCalculationService","calculateAgeAdjustedPremium","basePremium","AGE_MULTIPLIERS","calculateComprehensivePremium","riskProfile","ageAdjustedPremium","typeAdjustedPremium","applyInsuranceTypeAdjustment","coverageAdjustedPremium","applyCoverageAdjustment","riskMultiplier","calculateRiskAdjustment","calculateTotalInsuranceBurden","insuranceCards","individualPremiums","baseTotalPremium","penaltyMultiplier","calculateMultiInsurancePenalty","calculateRenewalPremium","currentStage","usageHistory","continuityDiscount","calculateContinuityDiscount","discountedPremium","calculateRiskMultiplier","calculateOptimalInsuranceBudget","availableBudget","_stage","ratio","conservative","balanced","aggressive","recommendedBudget","typeRate","INSURANCE_TYPE_RATES","coverageMultiplier","insuranceCount","penaltySteps","baseMultiplier","relevantFactorType","disability","accident","cancer","specificFactor","generateRiskProfile","playerHistory","profile","default","ageRiskValue","calculateAgeRisk","healthRiskValue","calculateHealthRisk","claimsRiskValue","calculateClaimsRisk","lifestyleRiskValue","calculateLifestyleRisk","calculateRiskAdjustedPremium","history","averageDamagePerTurn","totalDamageTaken","turnsPlayed","claimRate","insuranceClaimCount","totalInsurancePurchased","riskRate","riskyChoiceCount","totalChoiceCount","medical","income","asset","dental","travel","InsurancePremiumCalculationService","AGE_CONSTANTS","STAGE_PARAMETERS","label","maxVitality","startTurn","endTurn","insuranceMultiplier","challengeDifficultyModifier","Infinity","DREAM_CONSTANTS","AGE_ADJUSTMENTS","physical","intellectual","mixed","INSURANCE_CONSTANTS","TYPE_RATES","BALANCE_CONSTANTS","CARD_LIMITS","startingHandSize","defaultDrawCount","maxDeckSize","CHALLENGE_SETTINGS","minDifficulty","maxDifficulty","successBonusBase","failurePenaltyRatio","enableDynamicDifficulty","VITALITY_SETTINGS","defaultStarting","minimumValue","maximumValue","healingCap","PROGRESSION_SETTINGS","maxTurns","stageTransitionTurns","youthToMiddle","middleToFulfillment","victoryConditions","minTurns","minVitality","PERFORMANCE_CONSTANTS","CACHE_SETTINGS","stateSnapshotTTL","calculationCacheTTL","maxCacheEntries","OBJECT_POOL_LIMITS","maxPoolSize","initialPoolSize","PROCESSING_LIMITS","maxCardsPerSelection","maxInsuranceCards","maxHistoryEntries","GameConstantsAccessor","setOverrides","overrides","clearOverrides","getStageParameters","stageParameters","getDreamAgeAdjustment","getInsuranceTypeRate","getBalanceSettings","cardLimits","challengeSettings","vitalitySettings","progressionSettings","getPerformanceSettings","GameStageManager","checkStageProgression","turn","oldStage","newStage","settings","hasChanged","transitionMessage","upcomingTransition","getUpcomingTransitionMessage","turnsUntilMiddle","getStageVitalityLimit","turnsUntilFulfillment","getStageTransitionInfo","getStageDetails","info","stageName","vitalityLimit","characteristics","nextTransition","turnsRemaining","targetStage","atTurn","advanceStage","isCompleted","isFinalStage","_InsuranceExpirationManager","updateInsuranceExpirations","expiredInsurances","currentTurn","nowExpired","expiredCard","createExpirationNotice","getExpiringSoonInsurances","EXPIRING_SOON_THRESHOLD","getExpirationWarnings","expiredCards","turnNumber","expiredNames","message","showRenewalOption","InsuranceExpirationManager","AVAILABLE_CHARACTERS","initialVitalityModifier","specialAbility","AGE_PARAMETERS","ageMultiplier","middle_age","DREAM_AGE_ADJUSTMENTS","ChallengeResolutionService","resolveChallenge","challenge","cardManager","insuranceBurden","game","insuranceBonus","calculateInsuranceBonus","powerBreakdown","calculateTotalPower","playerPower","challengePower","getDreamRequiredPower","success","damageAmount","vitalityChange","powerDiff","overworkDamage","damageReduction","finalOverworkDamage","baseDamage","finalDamage","resultType","insurancePower","burden","adjustedPower","totalBonus","ageParams","GameTurnManager","stageManager","expirationManager","nextTurn","validateGameState","phase","checkVictoryCondition","status","newExpiredCount","remainingInsuranceCount","expirationResult","insuranceCost","vitality","applyDamage","e","error","expireAllInsurances","applyRecoveryInsuranceEffects","insuranceExpirations","completedAt","progressionResult","setStage","updateInsuranceBurden","totalHeal","heal","GameChallengeService","resolutionService","startChallenge","challengeCard","validatePhase","currentChallenge","getLearningHistory","newPower","updatedCard","validateChallenge","updateStatistics","updateVitality","challengeName","currentFailures","updateLearningHistory","finishGame","updateGameStateAfterChallenge","insuranceTypeChoices","variant","String","expectedPhase","totalChallenges","successfulChallenges","challengesCompleted","failedChallenges","challengesFailed","change","triggerInsuranceClaim","pendingInsuranceClaim","context","GameInsuranceService","premiumService","addInsurance","removeInsurance","selectInsuranceType","validateInsuranceSelection","findInsuranceChoice","selectedCard","addInsuranceCard","updatePlayerHistory","updateRiskProfile","completeInsuranceSelection","createSelectionResult","calculateInsuranceBurden","getRiskProfile","fallbackBurdenCalculation","burdenValue","abs","_insuranceBurden","_dirtyFlags","getRecommendedInsuranceBudget","cardsAcquired","durationText","activeInsuranceCount","getPlayerHistory","_playerHistory","newProfile","_riskProfile","ConservativeStrategy","selectChallenge","availableChallenges","easiestChallenge","a","b","currentPower","estimateCurrentPower","reason","successProbability","selectCards","availableCards","targetPower","otherCards","expectedPower","evaluateFitness","AggressiveStrategy","selectedChallenge","sortedCards","estimateHandStrength","handCards","BalancedStrategy","bestChoice","score","calculateRiskRewardScore","scoredCards","efficiency","calculateCardEfficiency","estimateCardCost","AdaptiveStrategy","strategies","bestStrategy","selectBestStrategy","strategy","fitness","AIStrategyFactory","createStrategy","factory","getAvailableTypes","Array","from","keys","getStrategyDescription","AIStrategyService","strategyType","currentStrategy","getCurrentStrategy","setStrategy","autoSelectChallenge","statisticsEnabled","autoSelectCards","recordDecision","challengeChoice","cardChoice","decisionHistory","getStatistics","totalDecisions","successRate","strategyUsage","successes","d","decision","setStatisticsEnabled","enabled","clearHistory","GameStateManager","events","maxEvents","addEventListener","eventType","listener","existingListeners","listeners","current","indexOf","notifyStateChange","previousValue","event","timestamp","addToHistory","notifyPhaseChange","previousPhase","newPhase","notifyStatusChange","previousStatus","newStatus","notifyStageChange","previousStage","notifyTurnChange","previousTurn","newTurn","getHistory","getHistoryByType","removeAllListeners","removeListenersForType","BaseActionProcessor","execute","input","validationResult","process","postProcess","DrawCardsProcessor","trouble","data","StartChallengeProcessor","StartChallengePhaseProcessor","startChallengePhase","ResolveChallengeProcessor","SelectInsuranceProcessor","BuyInsuranceProcessor","RemoveCardProcessor","SelectDreamProcessor","selectDream","GameActionProcessor","registerProcessor","actionType","processor","processors","executeAction","getAvailableActions","unregisterProcessor","_Vitality","DEFAULT_MAX_VITALITY","isFinite","getMax","decrease","amount","increase","getPercentage","isDepleted","isFull","withMaxVitality","newMaxVitality","adjustedValue","Vitality","_Game","gameState","totalInsuranceCount","lastUpdateTime","generateId","resolvedConfig","difficulty","startingVitality","dreamCardCount","balanceConfig","characterId","character","actualStartingVitality","actualMaxVitality","_vitality","premiumCalculationService","challengeResolutionService","turnManager","challengeService","insuranceService","aiStrategyService","_currentAIStrategy","stateManager","actionProcessor","setupStateListeners","dreamLeak","highestVitality","agingCards","_learningHistory","failures","getVitality","getInsuranceBurden","getAvailableVitality","currentTime","_cachedValues","getFreedomScore","maxBurden","freedom","isGameOver","hasAgingCardGameOver","checkAgingCardGameOverCondition","changeStatus","getAgingCardCount","start","startedAt","changePhase","selectCharacter","startVal","maxVal","actualMax","startDreamSelectionPhase","selectedDream","changeTurn","debug","card1","card2","modifiedChoices","recordChallengeResult","selectCard","skipInsuranceSelection","resolveInsuranceClaim","applyInsuranceEffect","declineInsuranceClaim","currentVitality","updateMaxVitalityForAge","currentValue","updateScore","advanceResult","changeStage","newCards","availableOnDemandInsurances","currentInsuranceTypeChoices","isInProgress","getExpiredInsurances","clearExpiredInsurances","getExpiringsSoonInsurances","insuranceScore","calculateCardPremium","addCardToHand","addCardToDiscardPile","addCardToPlayerDeck","clearHand","setHand","setPhase","getSnapshot","cardState","snapshot","OBJECT_POOLS","gameStates","Object","assign","handlePhaseChange","isWin","getStateManager","getActionProcessor","releaseSnapshot","key","getPerformanceStats","poolStats","challengeResults","cacheHitRate","dirtyFlags","setAIEnabled","_aiEnabled","isAIEnabled","setAIStrategy","getCurrentAIStrategy","getAIStatistics","aiSelectChallenge","aiSelectCards","aiAutoPlay","resetAISettings","Game"],"mappings":"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"}