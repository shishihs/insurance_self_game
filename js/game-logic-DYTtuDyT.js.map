{"version":3,"file":"game-logic-DYTtuDyT.js","sources":["../../src/domain/services/StatisticsDataService.ts","../../src/common/IdGenerator.ts","../../src/domain/entities/Feedback.ts","../../src/domain/services/FeedbackManagementService.ts","../../src/domain/entities/Deck.ts","../../src/domain/valueObjects/CardPower.ts","../../src/domain/valueObjects/InsurancePremium.ts","../../src/domain/entities/Card.ts","../../src/domain/entities/RiskRewardChallenge.ts","../../src/domain/services/CardFactory.ts","../../src/domain/services/CardManager.ts","../../src/domain/valueObjects/RiskFactor.ts","../../src/domain/valueObjects/RiskProfile.ts","../../src/domain/services/InsurancePremiumCalculationService.ts","../../src/domain/services/GameStageManager.ts","../../src/domain/services/InsuranceExpirationManager.ts","../../src/domain/services/ChallengeResolutionService.ts","../../src/domain/services/GameTurnManager.ts","../../src/domain/services/GameChallengeService.ts","../../src/domain/services/GameInsuranceService.ts","../../src/domain/services/GameStateManager.ts","../../src/domain/services/GameActionProcessor.ts","../../src/domain/types/game.types.ts","../../src/domain/valueObjects/Vitality.ts","../../src/domain/entities/Game.ts","../../src/domain/types/tutorial.types.ts"],"sourcesContent":["import type { Game } from '../entities/Game'\r\nimport type { Card } from '../entities/Card'\r\nimport type { PlayerStats, GameStatus, GamePhase } from '../types/game.types'\r\nimport type { GameStage } from '../types/card.types'\r\n\r\n/**\r\n * 統計データ項目の型定義\r\n */\r\nexport interface StatisticsData {\r\n  // 基本統計\r\n  totalGames: number\r\n  completedGames: number\r\n  victoryGames: number\r\n  gameOverCount: number\r\n  totalPlayTime: number\r\n  averageGameDuration: number\r\n  \r\n  // パフォーマンス統計\r\n  totalChallenges: number\r\n  successfulChallenges: number\r\n  challengeSuccessRate: number\r\n  averageVitality: number\r\n  highestVitality: number\r\n  lowestVitality: number\r\n  \r\n  // 進行統計\r\n  averageTurnsPerGame: number\r\n  stageReachCounts: Record<GameStage, number>\r\n  stageSuccessRates: Record<GameStage, number>\r\n  \r\n  // カード統計\r\n  cardsAcquiredTotal: number\r\n  averageCardsPerGame: number\r\n  cardTypeUsage: Record<string, number>\r\n  favoriteCardTypes: string[]\r\n  \r\n  // 保険統計\r\n  totalInsurancePurchases: number\r\n  insuranceTypeUsage: Record<string, number>\r\n  averageInsuranceBurden: number\r\n  insuranceEffectiveness: number\r\n  \r\n  // 時系列データ\r\n  gameHistoryByDate: Array<{\r\n    date: string\r\n    gamesPlayed: number\r\n    averageScore: number\r\n    totalPlayTime: number\r\n  }>\r\n  \r\n  // 戦略パターン\r\n  decisionPatterns: Array<{\r\n    situation: string\r\n    choice: string\r\n    frequency: number\r\n    successRate: number\r\n  }>\r\n  \r\n  // トレンド分析\r\n  recentTrends: {\r\n    performanceImprovement: number // パーセンテージ\r\n    playTimeIncrease: number\r\n    difficultyPreference: 'easy' | 'normal' | 'hard'\r\n    mostActiveTimeSlots: string[]\r\n  }\r\n}\r\n\r\n/**\r\n * リアルタイム統計データ\r\n */\r\nexport interface RealtimeStatistics {\r\n  currentSession: {\r\n    startTime: Date\r\n    gamesPlayed: number\r\n    currentStreak: number\r\n    sessionScore: number\r\n  }\r\n  \r\n  live: {\r\n    vitalityOverTime: Array<{ turn: number; vitality: number }>\r\n    challengeDifficulty: Array<{ turn: number; difficulty: number }>\r\n    decisionTimes: Array<{ turn: number; decisionTime: number }>\r\n    cardUsagePatterns: Array<{ cardType: string; turn: number; effectiveness: number }>\r\n  }\r\n}\r\n\r\n/**\r\n * フィルター設定\r\n */\r\nexport interface StatisticsFilter {\r\n  dateRange?: {\r\n    start: Date\r\n    end: Date\r\n  }\r\n  gameStatus?: GameStatus[]\r\n  stages?: GameStage[]\r\n  difficultyLevel?: string[]\r\n  minPlayTime?: number\r\n  maxPlayTime?: number\r\n}\r\n\r\n/**\r\n * ソート設定\r\n */\r\nexport interface StatisticsSort {\r\n  field: keyof StatisticsData | string\r\n  direction: 'asc' | 'desc'\r\n}\r\n\r\n/**\r\n * 統計データ管理サービス\r\n * \r\n * ゲームプレイ統計の収集、分析、可視化用データの提供を行う\r\n */\r\nexport class StatisticsDataService {\r\n  private static instance: StatisticsDataService\r\n  private gameHistory: Game[] = []\r\n  private currentGameData: RealtimeStatistics | null = null\r\n  private listeners: Set<(data: StatisticsData) => void> = new Set()\r\n  \r\n  private constructor() {}\r\n  \r\n  static getInstance(): StatisticsDataService {\r\n    if (!StatisticsDataService.instance) {\r\n      StatisticsDataService.instance = new StatisticsDataService()\r\n    }\r\n    return StatisticsDataService.instance\r\n  }\r\n  \r\n  /**\r\n   * ゲーム開始時のデータ記録\r\n   */\r\n  startGameTracking(game: Game): void {\r\n    this.currentGameData = {\r\n      currentSession: {\r\n        startTime: new Date(),\r\n        gamesPlayed: 0,\r\n        currentStreak: 0,\r\n        sessionScore: 0\r\n      },\r\n      live: {\r\n        vitalityOverTime: [{ turn: 0, vitality: game.vitality }],\r\n        challengeDifficulty: [],\r\n        decisionTimes: [],\r\n        cardUsagePatterns: []\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * ターン終了時のリアルタイムデータ更新\r\n   */\r\n  updateTurnData(game: Game, decisionTime?: number): void {\r\n    if (!this.currentGameData) return\r\n    \r\n    const { live } = this.currentGameData\r\n    \r\n    // 活力の変化を記録\r\n    live.vitalityOverTime.push({\r\n      turn: game.turn,\r\n      vitality: game.vitality\r\n    })\r\n    \r\n    // 決定時間を記録\r\n    if (decisionTime !== undefined) {\r\n      live.decisionTimes.push({\r\n        turn: game.turn,\r\n        decisionTime\r\n      })\r\n    }\r\n    \r\n    // チャレンジ難易度を記録\r\n    if (game.currentChallenge) {\r\n      live.challengeDifficulty.push({\r\n        turn: game.turn,\r\n        difficulty: game.currentChallenge.power\r\n      })\r\n    }\r\n    \r\n    // カード使用パターンを記録\r\n    const selectedCards = game.selectedCards\r\n    selectedCards.forEach(card => {\r\n      const effectiveness = this.calculateCardEffectiveness(card, game)\r\n      live.cardUsagePatterns.push({\r\n        cardType: card.type,\r\n        turn: game.turn,\r\n        effectiveness\r\n      })\r\n    })\r\n  }\r\n  \r\n  /**\r\n   * ゲーム終了時のデータ保存\r\n   */\r\n  finishGameTracking(game: Game): void {\r\n    if (this.currentGameData) {\r\n      this.currentGameData.currentSession.gamesPlayed++\r\n      \r\n      // 勝利の場合はストリークを更新\r\n      if (game.status === 'victory') {\r\n        this.currentGameData.currentSession.currentStreak++\r\n        this.currentGameData.currentSession.sessionScore += this.calculateGameScore(game)\r\n      } else {\r\n        this.currentGameData.currentSession.currentStreak = 0\r\n      }\r\n    }\r\n    \r\n    // ゲーム履歴に追加（スナップショットではなく実際のゲームインスタンスを保存）\r\n    this.gameHistory.push(game)\r\n    \r\n    // リスナーに通知\r\n    this.notifyListeners()\r\n  }\r\n  \r\n  /**\r\n   * 統計データを生成\r\n   */\r\n  generateStatistics(filter?: StatisticsFilter, sort?: StatisticsSort): StatisticsData {\r\n    const filteredGames = this.applyFilter(this.gameHistory, filter)\r\n    \r\n    const stats: StatisticsData = {\r\n      // 基本統計\r\n      totalGames: filteredGames.length,\r\n      completedGames: filteredGames.filter(g => g.isCompleted()).length,\r\n      victoryGames: filteredGames.filter(g => g.status === 'victory').length,\r\n      gameOverCount: filteredGames.filter(g => g.status === 'game_over').length,\r\n      totalPlayTime: this.calculateTotalPlayTime(filteredGames),\r\n      averageGameDuration: this.calculateAverageGameDuration(filteredGames),\r\n      \r\n      // パフォーマンス統計\r\n      totalChallenges: filteredGames.reduce((sum, g) => sum + g.stats.totalChallenges, 0),\r\n      successfulChallenges: filteredGames.reduce((sum, g) => sum + g.stats.successfulChallenges, 0),\r\n      challengeSuccessRate: this.calculateOverallSuccessRate(filteredGames),\r\n      averageVitality: this.calculateAverageVitality(filteredGames),\r\n      highestVitality: Math.max(...filteredGames.map(g => g.stats.highestVitality)),\r\n      lowestVitality: Math.min(...filteredGames.map(g => g.vitality)),\r\n      \r\n      // 進行統計\r\n      averageTurnsPerGame: filteredGames.reduce((sum, g) => sum + g.turn, 0) / Math.max(filteredGames.length, 1),\r\n      stageReachCounts: this.calculateStageReachCounts(filteredGames),\r\n      stageSuccessRates: this.calculateStageSuccessRates(filteredGames),\r\n      \r\n      // カード統計\r\n      cardsAcquiredTotal: filteredGames.reduce((sum, g) => sum + g.stats.cardsAcquired, 0),\r\n      averageCardsPerGame: this.calculateAverageCardsPerGame(filteredGames),\r\n      cardTypeUsage: this.calculateCardTypeUsage(filteredGames),\r\n      favoriteCardTypes: this.calculateFavoriteCardTypes(filteredGames),\r\n      \r\n      // 保険統計\r\n      totalInsurancePurchases: this.calculateTotalInsurancePurchases(filteredGames),\r\n      insuranceTypeUsage: this.calculateInsuranceTypeUsage(filteredGames),\r\n      averageInsuranceBurden: this.calculateAverageInsuranceBurden(filteredGames),\r\n      insuranceEffectiveness: this.calculateInsuranceEffectiveness(filteredGames),\r\n      \r\n      // 時系列データ\r\n      gameHistoryByDate: this.generateGameHistoryByDate(filteredGames),\r\n      \r\n      // 戦略パターン\r\n      decisionPatterns: this.analyzeDecisionPatterns(filteredGames),\r\n      \r\n      // トレンド分析\r\n      recentTrends: this.analyzeRecentTrends(filteredGames)\r\n    }\r\n    \r\n    return this.applySorting(stats, sort)\r\n  }\r\n  \r\n  /**\r\n   * リアルタイム統計データを取得\r\n   */\r\n  getRealtimeStatistics(): RealtimeStatistics | null {\r\n    return this.currentGameData\r\n  }\r\n  \r\n  /**\r\n   * 統計更新の購読\r\n   */\r\n  subscribe(listener: (data: StatisticsData) => void): () => void {\r\n    this.listeners.add(listener)\r\n    return () => this.listeners.delete(listener)\r\n  }\r\n  \r\n  /**\r\n   * データをエクスポート\r\n   */\r\n  exportData(format: 'json' | 'csv' = 'json'): string {\r\n    const stats = this.generateStatistics()\r\n    \r\n    if (format === 'json') {\r\n      return JSON.stringify(stats, null, 2)\r\n    } else {\r\n      return this.convertToCSV(stats)\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * プライベートメソッド群\r\n   */\r\n  \r\n  private applyFilter(games: Game[], filter?: StatisticsFilter): Game[] {\r\n    if (!filter) return games\r\n    \r\n    return games.filter(game => {\r\n      // 日付範囲フィルター\r\n      if (filter.dateRange && game.startedAt) {\r\n        const gameDate = game.startedAt\r\n        if (gameDate < filter.dateRange.start || gameDate > filter.dateRange.end) {\r\n          return false\r\n        }\r\n      }\r\n      \r\n      // ステータスフィルター\r\n      if (filter.gameStatus && !filter.gameStatus.includes(game.status)) {\r\n        return false\r\n      }\r\n      \r\n      // ステージフィルター\r\n      if (filter.stages && !filter.stages.includes(game.stage)) {\r\n        return false\r\n      }\r\n      \r\n      // プレイ時間フィルター\r\n      const playTime = this.calculateGamePlayTime(game)\r\n      if (filter.minPlayTime && playTime < filter.minPlayTime) {\r\n        return false\r\n      }\r\n      if (filter.maxPlayTime && playTime > filter.maxPlayTime) {\r\n        return false\r\n      }\r\n      \r\n      return true\r\n    })\r\n  }\r\n  \r\n  private applySorting(stats: StatisticsData, sort?: StatisticsSort): StatisticsData {\r\n    if (!sort) return stats\r\n    \r\n    // ソート可能な配列データに対してソートを適用\r\n    if (sort.field === 'gameHistoryByDate') {\r\n      stats.gameHistoryByDate.sort((a, b) => {\r\n        const comparison = a.date.localeCompare(b.date)\r\n        return sort.direction === 'asc' ? comparison : -comparison\r\n      })\r\n    }\r\n    \r\n    if (sort.field === 'decisionPatterns') {\r\n      stats.decisionPatterns.sort((a, b) => {\r\n        const comparison = a.frequency - b.frequency\r\n        return sort.direction === 'asc' ? comparison : -comparison\r\n      })\r\n    }\r\n    \r\n    return stats\r\n  }\r\n  \r\n  private calculateTotalPlayTime(games: Game[]): number {\r\n    return games.reduce((total, game) => {\r\n      return total + this.calculateGamePlayTime(game)\r\n    }, 0)\r\n  }\r\n  \r\n  private calculateGamePlayTime(game: Game): number {\r\n    if (!game.startedAt) return 0\r\n    const endTime = game.completedAt || new Date()\r\n    return endTime.getTime() - game.startedAt.getTime()\r\n  }\r\n  \r\n  private calculateAverageGameDuration(games: Game[]): number {\r\n    if (games.length === 0) return 0\r\n    return this.calculateTotalPlayTime(games) / games.length\r\n  }\r\n  \r\n  private calculateOverallSuccessRate(games: Game[]): number {\r\n    const totalChallenges = games.reduce((sum, g) => sum + g.stats.totalChallenges, 0)\r\n    const successfulChallenges = games.reduce((sum, g) => sum + g.stats.successfulChallenges, 0)\r\n    return totalChallenges > 0 ? (successfulChallenges / totalChallenges) * 100 : 0\r\n  }\r\n  \r\n  private calculateAverageVitality(games: Game[]): number {\r\n    if (games.length === 0) return 0\r\n    return games.reduce((sum, g) => sum + g.vitality, 0) / games.length\r\n  }\r\n  \r\n  private calculateStageReachCounts(games: Game[]): Record<GameStage, number> {\r\n    const counts: Record<GameStage, number> = {\r\n      youth: 0,\r\n      middle: 0,\r\n      fulfillment: 0\r\n    }\r\n    \r\n    games.forEach(game => {\r\n      counts[game.stage]++\r\n    })\r\n    \r\n    return counts\r\n  }\r\n  \r\n  private calculateStageSuccessRates(games: Game[]): Record<GameStage, number> {\r\n    const rates: Record<GameStage, number> = {\r\n      youth: 0,\r\n      middle: 0,\r\n      fulfillment: 0\r\n    }\r\n    \r\n    const stageCounts = this.calculateStageReachCounts(games)\r\n    \r\n    Object.keys(rates).forEach(stage => {\r\n      const stageGames = games.filter(g => g.stage === stage)\r\n      const victories = stageGames.filter(g => g.status === 'victory')\r\n      rates[stage as GameStage] = stageGames.length > 0 ? victories.length / stageGames.length : 0\r\n    })\r\n    \r\n    return rates\r\n  }\r\n  \r\n  private calculateAverageCardsPerGame(games: Game[]): number {\r\n    if (games.length === 0) return 0\r\n    return games.reduce((sum, g) => sum + g.stats.cardsAcquired, 0) / games.length\r\n  }\r\n  \r\n  private calculateCardTypeUsage(games: Game[]): Record<string, number> {\r\n    const usage: Record<string, number> = {}\r\n    \r\n    games.forEach(game => {\r\n      const allCards = [...game.playerDeck.cards, ...game.hand, ...game.discardPile]\r\n      allCards.forEach(card => {\r\n        usage[card.type] = (usage[card.type] || 0) + 1\r\n      })\r\n    })\r\n    \r\n    return usage\r\n  }\r\n  \r\n  private calculateFavoriteCardTypes(games: Game[]): string[] {\r\n    const usage = this.calculateCardTypeUsage(games)\r\n    return Object.entries(usage)\r\n      .sort(([, a], [, b]) => b - a)\r\n      .slice(0, 5)\r\n      .map(([type]) => type)\r\n  }\r\n  \r\n  private calculateTotalInsurancePurchases(games: Game[]): number {\r\n    return games.reduce((total, game) => {\r\n      return total + game.insuranceCards.length\r\n    }, 0)\r\n  }\r\n  \r\n  private calculateInsuranceTypeUsage(games: Game[]): Record<string, number> {\r\n    const usage: Record<string, number> = {}\r\n    \r\n    games.forEach(game => {\r\n      game.insuranceCards.forEach(card => {\r\n        const insuranceType = card.name || 'unknown'\r\n        usage[insuranceType] = (usage[insuranceType] || 0) + 1\r\n      })\r\n    })\r\n    \r\n    return usage\r\n  }\r\n  \r\n  private calculateAverageInsuranceBurden(games: Game[]): number {\r\n    if (games.length === 0) return 0\r\n    return games.reduce((sum, g) => sum + g.insuranceBurden, 0) / games.length\r\n  }\r\n  \r\n  private calculateInsuranceEffectiveness(games: Game[]): number {\r\n    // 保険を持っていたゲームでの成功率を計算\r\n    const gamesWithInsurance = games.filter(g => g.insuranceCards.length > 0)\r\n    const gamesWithoutInsurance = games.filter(g => g.insuranceCards.length === 0)\r\n    \r\n    if (gamesWithInsurance.length === 0) return 0\r\n    \r\n    const withInsuranceSuccessRate = gamesWithInsurance.filter(g => g.status === 'victory').length / gamesWithInsurance.length\r\n    const withoutInsuranceSuccessRate = gamesWithoutInsurance.length > 0\r\n      ? gamesWithoutInsurance.filter(g => g.status === 'victory').length / gamesWithoutInsurance.length\r\n      : 0\r\n    \r\n    return (withInsuranceSuccessRate - withoutInsuranceSuccessRate) * 100\r\n  }\r\n  \r\n  private generateGameHistoryByDate(games: Game[]): Array<{date: string; gamesPlayed: number; averageScore: number; totalPlayTime: number}> {\r\n    const dateMap = new Map<string, {games: Game[], totalScore: number, totalPlayTime: number}>()\r\n    \r\n    games.forEach(game => {\r\n      if (!game.startedAt) return\r\n      \r\n      const dateKey = game.startedAt.toISOString().split('T')[0]\r\n      if (!dateMap.has(dateKey)) {\r\n        dateMap.set(dateKey, { games: [], totalScore: 0, totalPlayTime: 0 })\r\n      }\r\n      \r\n      const entry = dateMap.get(dateKey)!\r\n      entry.games.push(game)\r\n      entry.totalScore += this.calculateGameScore(game)\r\n      entry.totalPlayTime += this.calculateGamePlayTime(game)\r\n    })\r\n    \r\n    return Array.from(dateMap.entries()).map(([date, data]) => ({\r\n      date,\r\n      gamesPlayed: data.games.length,\r\n      averageScore: data.totalScore / data.games.length,\r\n      totalPlayTime: data.totalPlayTime\r\n    })).sort((a, b) => a.date.localeCompare(b.date))\r\n  }\r\n  \r\n  private analyzeDecisionPatterns(games: Game[]): Array<{situation: string; choice: string; frequency: number; successRate: number}> {\r\n    // 簡易的な決定パターン分析\r\n    const patterns: Record<string, {count: number, successes: number}> = {}\r\n    \r\n    games.forEach(game => {\r\n      const situation = `${game.stage}_${game.vitality > 50 ? 'high' : 'low'}_vitality`\r\n      const hasInsurance = game.insuranceCards.length > 0\r\n      const choice = hasInsurance ? 'with_insurance' : 'no_insurance'\r\n      const success = game.status === 'victory'\r\n      \r\n      const key = `${situation}_${choice}`\r\n      if (!patterns[key]) {\r\n        patterns[key] = { count: 0, successes: 0 }\r\n      }\r\n      \r\n      patterns[key].count++\r\n      if (success) patterns[key].successes++\r\n    })\r\n    \r\n    return Object.entries(patterns).map(([key, data]) => {\r\n      const [situation, choice] = key.split('_with_insurance').length > 1 \r\n        ? [key.replace('_with_insurance', ''), 'with_insurance']\r\n        : [key.replace('_no_insurance', ''), 'no_insurance']\r\n      \r\n      return {\r\n        situation,\r\n        choice,\r\n        frequency: data.count,\r\n        successRate: data.count > 0 ? data.successes / data.count : 0\r\n      }\r\n    })\r\n  }\r\n  \r\n  private analyzeRecentTrends(games: Game[]): StatisticsData['recentTrends'] {\r\n    const recentGames = games.slice(-10) // 直近10ゲーム\r\n    const olderGames = games.slice(-20, -10) // その前の10ゲーム\r\n    \r\n    // パフォーマンス改善率\r\n    const recentSuccessRate = recentGames.filter(g => g.status === 'victory').length / Math.max(recentGames.length, 1)\r\n    const olderSuccessRate = olderGames.filter(g => g.status === 'victory').length / Math.max(olderGames.length, 1)\r\n    const performanceImprovement = ((recentSuccessRate - olderSuccessRate) / Math.max(olderSuccessRate, 0.01)) * 100\r\n    \r\n    // プレイ時間の変化\r\n    const recentAvgPlayTime = this.calculateAverageGameDuration(recentGames)\r\n    const olderAvgPlayTime = this.calculateAverageGameDuration(olderGames)\r\n    const playTimeIncrease = recentAvgPlayTime - olderAvgPlayTime\r\n    \r\n    return {\r\n      performanceImprovement: Math.round(performanceImprovement * 10) / 10,\r\n      playTimeIncrease: Math.round(playTimeIncrease / 1000), // 秒単位\r\n      difficultyPreference: 'normal', // 簡易実装\r\n      mostActiveTimeSlots: ['20:00-22:00'] // 簡易実装\r\n    }\r\n  }\r\n  \r\n  private calculateGameScore(game: Game): number {\r\n    let score = 0\r\n    \r\n    // 基本スコア（活力ベース）\r\n    score += game.vitality * 10\r\n    \r\n    // ボーナススコア\r\n    if (game.status === 'victory') score += 1000\r\n    score += game.stats.successfulChallenges * 50\r\n    score += game.stats.cardsAcquired * 25\r\n    \r\n    // ステージボーナス\r\n    const stageMultiplier = { youth: 1, middle: 1.5, fulfillment: 2 }\r\n    score *= stageMultiplier[game.stage]\r\n    \r\n    return Math.round(score)\r\n  }\r\n  \r\n  private calculateCardEffectiveness(card: Card, game: Game): number {\r\n    // カードの効果的さを0-100で評価\r\n    const vitalityRatio = game.vitality / game.maxVitality\r\n    const cardPowerRatio = card.power / 10 // 仮の最大パワー10\r\n    \r\n    return Math.min(100, (cardPowerRatio + vitalityRatio) * 50)\r\n  }\r\n  \r\n  private convertToCSV(stats: StatisticsData): string {\r\n    const rows = [\r\n      ['統計項目', '値'],\r\n      ['総ゲーム数', stats.totalGames.toString()],\r\n      ['完了ゲーム数', stats.completedGames.toString()],\r\n      ['勝利ゲーム数', stats.victoryGames.toString()],\r\n      ['総チャレンジ数', stats.totalChallenges.toString()],\r\n      ['成功チャレンジ数', stats.successfulChallenges.toString()],\r\n      ['チャレンジ成功率', `${stats.challengeSuccessRate.toFixed(1)}%`],\r\n      ['平均活力', stats.averageVitality.toFixed(1)],\r\n      ['最高活力', stats.highestVitality.toString()],\r\n      ['平均ターン数', stats.averageTurnsPerGame.toFixed(1)]\r\n    ]\r\n    \r\n    return rows.map(row => row.join(',')).join('\\n')\r\n  }\r\n  \r\n  private notifyListeners(): void {\r\n    const stats = this.generateStatistics()\r\n    this.listeners.forEach(listener => listener(stats))\r\n  }\r\n}","/**\r\n * 統一されたID生成ユーティリティ\r\n * \r\n * システム全体で一貫したID生成ロジックを提供し、\r\n * 重複コードを排除します。\r\n */\r\nexport class IdGenerator {\r\n  private static counter = 0\r\n  \r\n  /**\r\n   * 汎用的なユニークIDを生成\r\n   * @param prefix プレフィックス（例: 'card', 'game', 'cmd'）\r\n   * @returns ユニークなID文字列\r\n   */\r\n  static generate(prefix: string = 'id'): string {\r\n    return `${prefix}_${Date.now()}_${this.getRandomString()}`\r\n  }\r\n\r\n  /**\r\n   * カード用IDを生成\r\n   */\r\n  static generateCardId(): string {\r\n    return this.generate('card')\r\n  }\r\n\r\n  /**\r\n   * ゲーム用IDを生成\r\n   */\r\n  static generateGameId(): string {\r\n    return this.generate('game')\r\n  }\r\n\r\n  /**\r\n   * コマンド用IDを生成\r\n   */\r\n  static generateCommandId(): string {\r\n    return this.generate('cmd')\r\n  }\r\n\r\n  /**\r\n   * 通知用IDを生成\r\n   */\r\n  static generateNotificationId(): string {\r\n    return this.generate('notification')\r\n  }\r\n\r\n  /**\r\n   * フィードバック用IDを生成\r\n   */\r\n  static generateFeedbackId(): string {\r\n    return this.generate('feedback')\r\n  }\r\n\r\n  /**\r\n   * 連番付きIDを生成（テスト時の予測可能性のため）\r\n   */\r\n  static generateSequential(prefix: string = 'seq'): string {\r\n    return `${prefix}_${++this.counter}`\r\n  }\r\n\r\n  /**\r\n   * UUIDライクなIDを生成（より強固な一意性が必要な場合）\r\n   */\r\n  static generateUUID(prefix?: string): string {\r\n    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n      const r = Math.random() * 16 | 0\r\n      const v = c === 'x' ? r : (r & 0x3 | 0x8)\r\n      return v.toString(16)\r\n    })\r\n    return prefix ? `${prefix}_${uuid}` : uuid\r\n  }\r\n\r\n  /**\r\n   * ランダム文字列を生成（内部用）\r\n   */\r\n  private static getRandomString(length: number = 9): string {\r\n    return Math.random().toString(36).substr(2, length)\r\n  }\r\n\r\n  /**\r\n   * カウンターをリセット（テスト用）\r\n   */\r\n  static resetCounter(): void {\r\n    this.counter = 0\r\n  }\r\n\r\n  /**\r\n   * 現在のカウンター値を取得（テスト用）\r\n   */\r\n  static getCurrentCounter(): number {\r\n    return this.counter\r\n  }\r\n}\r\n\r\n/**\r\n * IDの妥当性をチェックするユーティリティ\r\n */\r\nexport class IdValidator {\r\n  /**\r\n   * IDが有効な形式かチェック\r\n   */\r\n  static isValid(id: string): boolean {\r\n    if (!id || typeof id !== 'string') return false\r\n    \r\n    // 基本的なパターンチェック: prefix_timestamp_randomstring\r\n    const basicPattern = /^[a-zA-Z_]+_\\d+_[a-zA-Z0-9]+$/\r\n    if (basicPattern.test(id)) return true\r\n    \r\n    // UUIDパターンチェック\r\n    const uuidPattern = /^[a-zA-Z_]*_?[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i\r\n    return uuidPattern.test(id)\r\n  }\r\n\r\n  /**\r\n   * IDからプレフィックスを抽出\r\n   */\r\n  static extractPrefix(id: string): string | null {\r\n    if (!this.isValid(id)) return null\r\n    \r\n    const parts = id.split('_')\r\n    return parts.length > 0 ? parts[0] : null\r\n  }\r\n\r\n  /**\r\n   * IDがSpecificなプレフィックスを持っているかチェック\r\n   */\r\n  static hasPrefix(id: string, expectedPrefix: string): boolean {\r\n    const prefix = this.extractPrefix(id)\r\n    return prefix === expectedPrefix\r\n  }\r\n}","import { IdGenerator } from '../../common/IdGenerator'\r\n\r\n/**\r\n * フィードバックのカテゴリ\r\n */\r\nexport enum FeedbackCategory {\r\n  BUG_REPORT = 'bug_report',\r\n  FEATURE_REQUEST = 'feature_request',\r\n  UI_UX = 'ui_ux',\r\n  GAMEPLAY = 'gameplay',\r\n  PERFORMANCE = 'performance',\r\n  ACCESSIBILITY = 'accessibility',\r\n  GENERAL = 'general'\r\n}\r\n\r\n/**\r\n * フィードバックの優先度\r\n */\r\nexport enum FeedbackPriority {\r\n  LOW = 'low',\r\n  MEDIUM = 'medium',\r\n  HIGH = 'high',\r\n  CRITICAL = 'critical'\r\n}\r\n\r\n/**\r\n * フィードバックの状態\r\n */\r\nexport enum FeedbackStatus {\r\n  SUBMITTED = 'submitted',\r\n  UNDER_REVIEW = 'under_review',\r\n  IN_PROGRESS = 'in_progress',\r\n  RESOLVED = 'resolved',\r\n  CLOSED = 'closed'\r\n}\r\n\r\n/**\r\n * 満足度評価\r\n */\r\nexport enum SatisfactionRating {\r\n  VERY_UNSATISFIED = 1,\r\n  UNSATISFIED = 2,\r\n  NEUTRAL = 3,\r\n  SATISFIED = 4,\r\n  VERY_SATISFIED = 5\r\n}\r\n\r\n/**\r\n * フィードバック送信者の情報\r\n */\r\nexport interface FeedbackSubmitter {\r\n  id?: string\r\n  name?: string\r\n  email?: string\r\n  isAnonymous: boolean\r\n  userAgent?: string\r\n  sessionId?: string\r\n}\r\n\r\n/**\r\n * システム情報\r\n */\r\nexport interface SystemInfo {\r\n  userAgent: string\r\n  screenResolution: string\r\n  viewport: string\r\n  gameVersion: string\r\n  timestamp: Date\r\n  gameState?: {\r\n    stage: string\r\n    turn: number\r\n    vitality: number\r\n    phase: string\r\n  }\r\n}\r\n\r\n/**\r\n * バグレポート固有の情報\r\n */\r\nexport interface BugReportData {\r\n  stepsToReproduce: string[]\r\n  expectedBehavior: string\r\n  actualBehavior: string\r\n  screenshot?: string\r\n  errorMessage?: string\r\n  severity: 'low' | 'medium' | 'high' | 'critical'\r\n  reproductionRate: 'always' | 'often' | 'sometimes' | 'rarely'\r\n}\r\n\r\n/**\r\n * レビュー・評価データ\r\n */\r\nexport interface ReviewData {\r\n  overallRating: SatisfactionRating\r\n  aspects: {\r\n    gameplay: SatisfactionRating\r\n    ui: SatisfactionRating\r\n    performance: SatisfactionRating\r\n    accessibility: SatisfactionRating\r\n  }\r\n  wouldRecommend: boolean\r\n  playTime?: number\r\n}\r\n\r\n/**\r\n * フィードバックエンティティ\r\n * ユーザーからのフィードバック情報を管理する\r\n */\r\nexport class Feedback {\r\n  readonly id: string\r\n  readonly category: FeedbackCategory\r\n  readonly title: string\r\n  readonly description: string\r\n  readonly priority: FeedbackPriority\r\n  readonly submitter: FeedbackSubmitter\r\n  readonly systemInfo: SystemInfo\r\n  readonly createdAt: Date\r\n  \r\n  private _status: FeedbackStatus\r\n  private _updatedAt: Date\r\n  private _tags: string[]\r\n  private _adminNotes: string[]\r\n  \r\n  // カテゴリ別の詳細データ\r\n  readonly bugReportData?: BugReportData\r\n  readonly reviewData?: ReviewData\r\n  \r\n  constructor(params: {\r\n    category: FeedbackCategory\r\n    title: string\r\n    description: string\r\n    priority?: FeedbackPriority\r\n    submitter: FeedbackSubmitter\r\n    systemInfo: SystemInfo\r\n    bugReportData?: BugReportData\r\n    reviewData?: ReviewData\r\n    tags?: string[]\r\n  }) {\r\n    this.id = IdGenerator.generateFeedbackId()\r\n    this.category = params.category\r\n    this.title = params.title\r\n    this.description = params.description\r\n    this.priority = params.priority || this.calculateAutoPriority(params)\r\n    this.submitter = params.submitter\r\n    this.systemInfo = params.systemInfo\r\n    this.bugReportData = params.bugReportData\r\n    this.reviewData = params.reviewData\r\n    this.createdAt = new Date()\r\n    \r\n    this._status = FeedbackStatus.SUBMITTED\r\n    this._updatedAt = new Date()\r\n    this._tags = params.tags || []\r\n    this._adminNotes = []\r\n  }\r\n\r\n  /**\r\n   * フィードバックの状態を取得\r\n   */\r\n  get status(): FeedbackStatus {\r\n    return this._status\r\n  }\r\n\r\n  /**\r\n   * 最終更新日時を取得\r\n   */\r\n  get updatedAt(): Date {\r\n    return this._updatedAt\r\n  }\r\n\r\n  /**\r\n   * タグ一覧を取得\r\n   */\r\n  get tags(): string[] {\r\n    return [...this._tags]\r\n  }\r\n\r\n  /**\r\n   * 管理者メモを取得\r\n   */\r\n  get adminNotes(): string[] {\r\n    return [...this._adminNotes]\r\n  }\r\n\r\n  /**\r\n   * フィードバックの状態を更新\r\n   */\r\n  updateStatus(newStatus: FeedbackStatus): void {\r\n    if (this.isValidStatusTransition(newStatus)) {\r\n      this._status = newStatus\r\n      this._updatedAt = new Date()\r\n    } else {\r\n      throw new Error(`Invalid status transition: ${this._status} -> ${newStatus}`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * タグを追加\r\n   */\r\n  addTag(tag: string): void {\r\n    if (!this._tags.includes(tag)) {\r\n      this._tags.push(tag)\r\n      this._updatedAt = new Date()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * タグを削除\r\n   */\r\n  removeTag(tag: string): void {\r\n    const index = this._tags.indexOf(tag)\r\n    if (index > -1) {\r\n      this._tags.splice(index, 1)\r\n      this._updatedAt = new Date()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 管理者メモを追加\r\n   */\r\n  addAdminNote(note: string): void {\r\n    this._adminNotes.push(`${new Date().toISOString()}: ${note}`)\r\n    this._updatedAt = new Date()\r\n  }\r\n\r\n  /**\r\n   * フィードバックの優先度を自動計算\r\n   */\r\n  private calculateAutoPriority(params: {\r\n    category: FeedbackCategory\r\n    bugReportData?: BugReportData\r\n    reviewData?: ReviewData\r\n  }): FeedbackPriority {\r\n    // バグレポートの場合、重要度に基づいて優先度を決定\r\n    if (params.category === FeedbackCategory.BUG_REPORT && params.bugReportData) {\r\n      switch (params.bugReportData.severity) {\r\n        case 'critical':\r\n          return FeedbackPriority.CRITICAL\r\n        case 'high':\r\n          return FeedbackPriority.HIGH\r\n        case 'medium':\r\n          return FeedbackPriority.MEDIUM\r\n        case 'low':\r\n          return FeedbackPriority.LOW\r\n      }\r\n    }\r\n\r\n    // レビューの場合、評価に基づいて優先度を決定\r\n    if (params.category === FeedbackCategory.GENERAL && params.reviewData) {\r\n      if (params.reviewData.overallRating <= 2) {\r\n        return FeedbackPriority.HIGH // 低評価は優先度高\r\n      } else if (params.reviewData.overallRating >= 4) {\r\n        return FeedbackPriority.MEDIUM // 高評価は中程度\r\n      }\r\n    }\r\n\r\n    // アクセシビリティは常に高優先度\r\n    if (params.category === FeedbackCategory.ACCESSIBILITY) {\r\n      return FeedbackPriority.HIGH\r\n    }\r\n\r\n    return FeedbackPriority.MEDIUM\r\n  }\r\n\r\n  /**\r\n   * 状態遷移の妥当性をチェック\r\n   */\r\n  private isValidStatusTransition(newStatus: FeedbackStatus): boolean {\r\n    const validTransitions: Record<FeedbackStatus, FeedbackStatus[]> = {\r\n      [FeedbackStatus.SUBMITTED]: [\r\n        FeedbackStatus.UNDER_REVIEW,\r\n        FeedbackStatus.CLOSED\r\n      ],\r\n      [FeedbackStatus.UNDER_REVIEW]: [\r\n        FeedbackStatus.IN_PROGRESS,\r\n        FeedbackStatus.CLOSED,\r\n        FeedbackStatus.SUBMITTED\r\n      ],\r\n      [FeedbackStatus.IN_PROGRESS]: [\r\n        FeedbackStatus.RESOLVED,\r\n        FeedbackStatus.UNDER_REVIEW,\r\n        FeedbackStatus.CLOSED\r\n      ],\r\n      [FeedbackStatus.RESOLVED]: [\r\n        FeedbackStatus.CLOSED,\r\n        FeedbackStatus.IN_PROGRESS\r\n      ],\r\n      [FeedbackStatus.CLOSED]: []\r\n    }\r\n\r\n    return validTransitions[this._status].includes(newStatus)\r\n  }\r\n\r\n  /**\r\n   * バグレポートかどうか判定\r\n   */\r\n  isBugReport(): boolean {\r\n    return this.category === FeedbackCategory.BUG_REPORT && !!this.bugReportData\r\n  }\r\n\r\n  /**\r\n   * レビューかどうか判定\r\n   */\r\n  isReview(): boolean {\r\n    return !!this.reviewData\r\n  }\r\n\r\n  /**\r\n   * 匿名フィードバックかどうか判定\r\n   */\r\n  isAnonymous(): boolean {\r\n    return this.submitter.isAnonymous\r\n  }\r\n\r\n  /**\r\n   * 高優先度かどうか判定\r\n   */\r\n  isHighPriority(): boolean {\r\n    return this.priority === FeedbackPriority.HIGH || \r\n           this.priority === FeedbackPriority.CRITICAL\r\n  }\r\n\r\n  /**\r\n   * フィードバックの概要を取得\r\n   */\r\n  getSummary(): string {\r\n    const categoryLabel = this.getCategoryLabel()\r\n    const priorityLabel = this.getPriorityLabel()\r\n    const statusLabel = this.getStatusLabel()\r\n    \r\n    return `[${categoryLabel}] ${this.title} (${priorityLabel}) - ${statusLabel}`\r\n  }\r\n\r\n  /**\r\n   * カテゴリのラベルを取得\r\n   */\r\n  private getCategoryLabel(): string {\r\n    const labels: Record<FeedbackCategory, string> = {\r\n      [FeedbackCategory.BUG_REPORT]: 'バグ報告',\r\n      [FeedbackCategory.FEATURE_REQUEST]: '機能要望',\r\n      [FeedbackCategory.UI_UX]: 'UI/UX',\r\n      [FeedbackCategory.GAMEPLAY]: 'ゲームプレイ',\r\n      [FeedbackCategory.PERFORMANCE]: 'パフォーマンス',\r\n      [FeedbackCategory.ACCESSIBILITY]: 'アクセシビリティ',\r\n      [FeedbackCategory.GENERAL]: '一般'\r\n    }\r\n    return labels[this.category]\r\n  }\r\n\r\n  /**\r\n   * 優先度のラベルを取得\r\n   */\r\n  private getPriorityLabel(): string {\r\n    const labels: Record<FeedbackPriority, string> = {\r\n      [FeedbackPriority.LOW]: '低',\r\n      [FeedbackPriority.MEDIUM]: '中',\r\n      [FeedbackPriority.HIGH]: '高',\r\n      [FeedbackPriority.CRITICAL]: '緊急'\r\n    }\r\n    return labels[this.priority]\r\n  }\r\n\r\n  /**\r\n   * 状態のラベルを取得\r\n   */\r\n  private getStatusLabel(): string {\r\n    const labels: Record<FeedbackStatus, string> = {\r\n      [FeedbackStatus.SUBMITTED]: '提出済み',\r\n      [FeedbackStatus.UNDER_REVIEW]: '確認中',\r\n      [FeedbackStatus.IN_PROGRESS]: '対応中',\r\n      [FeedbackStatus.RESOLVED]: '解決済み',\r\n      [FeedbackStatus.CLOSED]: '完了'\r\n    }\r\n    return labels[this.status]\r\n  }\r\n\r\n  /**\r\n   * JSON形式にシリアライズ\r\n   */\r\n  toJSON(): Record<string, any> {\r\n    return {\r\n      id: this.id,\r\n      category: this.category,\r\n      title: this.title,\r\n      description: this.description,\r\n      priority: this.priority,\r\n      status: this._status,\r\n      submitter: this.submitter,\r\n      systemInfo: this.systemInfo,\r\n      bugReportData: this.bugReportData,\r\n      reviewData: this.reviewData,\r\n      tags: this._tags,\r\n      adminNotes: this._adminNotes,\r\n      createdAt: this.createdAt.toISOString(),\r\n      updatedAt: this._updatedAt.toISOString()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * JSON形式からデシリアライズ\r\n   */\r\n  static fromJSON(data: Record<string, any>): Feedback {\r\n    const feedback = new Feedback({\r\n      category: data.category,\r\n      title: data.title,\r\n      description: data.description,\r\n      priority: data.priority,\r\n      submitter: data.submitter,\r\n      systemInfo: {\r\n        ...data.systemInfo,\r\n        timestamp: new Date(data.systemInfo.timestamp)\r\n      },\r\n      bugReportData: data.bugReportData,\r\n      reviewData: data.reviewData,\r\n      tags: data.tags\r\n    })\r\n\r\n    // 内部状態を復元\r\n    feedback._status = data.status\r\n    feedback._updatedAt = new Date(data.updatedAt)\r\n    feedback._adminNotes = data.adminNotes || []\r\n\r\n    return feedback\r\n  }\r\n}","import { \r\n  Feedback, \r\n  FeedbackCategory, \r\n  FeedbackStatus, \r\n  FeedbackPriority,\r\n  SatisfactionRating,\r\n  type FeedbackSubmitter,\r\n  type SystemInfo,\r\n  type BugReportData,\r\n  type ReviewData\r\n} from '../entities/Feedback'\r\n\r\n/**\r\n * フィードバック検索フィルター\r\n */\r\nexport interface FeedbackFilter {\r\n  categories?: FeedbackCategory[]\r\n  statuses?: FeedbackStatus[]\r\n  priorities?: FeedbackPriority[]\r\n  dateRange?: {\r\n    start: Date\r\n    end: Date\r\n  }\r\n  isAnonymous?: boolean\r\n  tags?: string[]\r\n  searchQuery?: string\r\n}\r\n\r\n/**\r\n * フィードバック統計情報\r\n */\r\nexport interface FeedbackStatistics {\r\n  total: number\r\n  byCategory: Record<FeedbackCategory, number>\r\n  byStatus: Record<FeedbackStatus, number>\r\n  byPriority: Record<FeedbackPriority, number>\r\n  averageSatisfactionRating?: number\r\n  resolvedCount: number\r\n  pendingCount: number\r\n  responseTime: {\r\n    average: number // 平均応答時間（時間）\r\n    median: number\r\n  }\r\n  trends: {\r\n    daily: Record<string, number>\r\n    weekly: Record<string, number>\r\n    monthly: Record<string, number>\r\n  }\r\n}\r\n\r\n/**\r\n * フィードバック作成パラメータ\r\n */\r\nexport interface CreateFeedbackParams {\r\n  category: FeedbackCategory\r\n  title: string\r\n  description: string\r\n  submitter: FeedbackSubmitter\r\n  systemInfo: SystemInfo\r\n  bugReportData?: BugReportData\r\n  reviewData?: ReviewData\r\n  tags?: string[]\r\n}\r\n\r\n/**\r\n * フィードバック管理サービス\r\n * フィードバックの作成、更新、検索、統計などを管理する\r\n */\r\nexport class FeedbackManagementService {\r\n  private feedbacks: Map<string, Feedback> = new Map()\r\n  private readonly STORAGE_KEY = 'game_feedback_data'\r\n\r\n  constructor() {\r\n    this.loadFromStorage()\r\n  }\r\n\r\n  /**\r\n   * 新しいフィードバックを作成\r\n   */\r\n  createFeedback(params: CreateFeedbackParams): Feedback {\r\n    const feedback = new Feedback(params)\r\n    this.feedbacks.set(feedback.id, feedback)\r\n    this.saveToStorage()\r\n    \r\n    // 高優先度の場合は即座に通知\r\n    if (feedback.isHighPriority()) {\r\n      this.notifyHighPriorityFeedback(feedback)\r\n    }\r\n    \r\n    return feedback\r\n  }\r\n\r\n  /**\r\n   * バグレポートを作成\r\n   */\r\n  createBugReport(params: {\r\n    title: string\r\n    description: string\r\n    submitter: FeedbackSubmitter\r\n    systemInfo: SystemInfo\r\n    bugReportData: BugReportData\r\n    tags?: string[]\r\n  }): Feedback {\r\n    return this.createFeedback({\r\n      category: FeedbackCategory.BUG_REPORT,\r\n      title: params.title,\r\n      description: params.description,\r\n      submitter: params.submitter,\r\n      systemInfo: params.systemInfo,\r\n      bugReportData: params.bugReportData,\r\n      tags: params.tags\r\n    })\r\n  }\r\n\r\n  /**\r\n   * レビュー・評価を作成\r\n   */\r\n  createReview(params: {\r\n    title: string\r\n    description: string\r\n    submitter: FeedbackSubmitter\r\n    systemInfo: SystemInfo\r\n    reviewData: ReviewData\r\n    tags?: string[]\r\n  }): Feedback {\r\n    return this.createFeedback({\r\n      category: FeedbackCategory.GENERAL,\r\n      title: params.title,\r\n      description: params.description,\r\n      submitter: params.submitter,\r\n      systemInfo: params.systemInfo,\r\n      reviewData: params.reviewData,\r\n      tags: params.tags\r\n    })\r\n  }\r\n\r\n  /**\r\n   * フィードバックをIDで取得\r\n   */\r\n  getFeedbackById(id: string): Feedback | undefined {\r\n    return this.feedbacks.get(id)\r\n  }\r\n\r\n  /**\r\n   * フィルター条件でフィードバックを検索\r\n   */\r\n  searchFeedbacks(filter: FeedbackFilter = {}): Feedback[] {\r\n    let results = Array.from(this.feedbacks.values())\r\n\r\n    // カテゴリフィルター\r\n    if (filter.categories && filter.categories.length > 0) {\r\n      results = results.filter(f => filter.categories!.includes(f.category))\r\n    }\r\n\r\n    // ステータスフィルター\r\n    if (filter.statuses && filter.statuses.length > 0) {\r\n      results = results.filter(f => filter.statuses!.includes(f.status))\r\n    }\r\n\r\n    // 優先度フィルター\r\n    if (filter.priorities && filter.priorities.length > 0) {\r\n      results = results.filter(f => filter.priorities!.includes(f.priority))\r\n    }\r\n\r\n    // 期間フィルター\r\n    if (filter.dateRange) {\r\n      results = results.filter(f => \r\n        f.createdAt >= filter.dateRange!.start && \r\n        f.createdAt <= filter.dateRange!.end\r\n      )\r\n    }\r\n\r\n    // 匿名フィルター\r\n    if (filter.isAnonymous !== undefined) {\r\n      results = results.filter(f => f.isAnonymous() === filter.isAnonymous)\r\n    }\r\n\r\n    // タグフィルター\r\n    if (filter.tags && filter.tags.length > 0) {\r\n      results = results.filter(f => \r\n        filter.tags!.some(tag => f.tags.includes(tag))\r\n      )\r\n    }\r\n\r\n    // テキスト検索\r\n    if (filter.searchQuery) {\r\n      const query = filter.searchQuery.toLowerCase()\r\n      results = results.filter(f => \r\n        f.title.toLowerCase().includes(query) ||\r\n        f.description.toLowerCase().includes(query) ||\r\n        f.tags.some(tag => tag.toLowerCase().includes(query))\r\n      )\r\n    }\r\n\r\n    // 作成日時の降順でソート\r\n    return results.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\r\n  }\r\n\r\n  /**\r\n   * フィードバックの状態を更新\r\n   */\r\n  updateFeedbackStatus(id: string, newStatus: FeedbackStatus): boolean {\r\n    const feedback = this.feedbacks.get(id)\r\n    if (!feedback) {\r\n      return false\r\n    }\r\n\r\n    try {\r\n      feedback.updateStatus(newStatus)\r\n      this.saveToStorage()\r\n      return true\r\n    } catch (error) {\r\n      console.error('Failed to update feedback status:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * フィードバックにタグを追加\r\n   */\r\n  addTagToFeedback(id: string, tag: string): boolean {\r\n    const feedback = this.feedbacks.get(id)\r\n    if (!feedback) {\r\n      return false\r\n    }\r\n\r\n    feedback.addTag(tag)\r\n    this.saveToStorage()\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * フィードバックに管理者メモを追加\r\n   */\r\n  addAdminNote(id: string, note: string): boolean {\r\n    const feedback = this.feedbacks.get(id)\r\n    if (!feedback) {\r\n      return false\r\n    }\r\n\r\n    feedback.addAdminNote(note)\r\n    this.saveToStorage()\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * フィードバック統計を取得\r\n   */\r\n  getStatistics(filter: FeedbackFilter = {}): FeedbackStatistics {\r\n    const feedbacks = this.searchFeedbacks(filter)\r\n    \r\n    const stats: FeedbackStatistics = {\r\n      total: feedbacks.length,\r\n      byCategory: {} as Record<FeedbackCategory, number>,\r\n      byStatus: {} as Record<FeedbackStatus, number>,\r\n      byPriority: {} as Record<FeedbackPriority, number>,\r\n      resolvedCount: 0,\r\n      pendingCount: 0,\r\n      responseTime: { average: 0, median: 0 },\r\n      trends: {\r\n        daily: {},\r\n        weekly: {},\r\n        monthly: {}\r\n      }\r\n    }\r\n\r\n    // 初期化\r\n    Object.values(FeedbackCategory).forEach(category => {\r\n      stats.byCategory[category] = 0\r\n    })\r\n    Object.values(FeedbackStatus).forEach(status => {\r\n      stats.byStatus[status] = 0\r\n    })\r\n    Object.values(FeedbackPriority).forEach(priority => {\r\n      stats.byPriority[priority] = 0\r\n    })\r\n\r\n    // 統計計算\r\n    const responseTimes: number[] = []\r\n    let totalSatisfactionRating = 0\r\n    let reviewCount = 0\r\n\r\n    feedbacks.forEach(feedback => {\r\n      // カテゴリ別\r\n      stats.byCategory[feedback.category]++\r\n      \r\n      // ステータス別\r\n      stats.byStatus[feedback.status]++\r\n      \r\n      // 優先度別\r\n      stats.byPriority[feedback.priority]++\r\n\r\n      // 解決・未解決カウント\r\n      if (feedback.status === FeedbackStatus.RESOLVED || \r\n          feedback.status === FeedbackStatus.CLOSED) {\r\n        stats.resolvedCount++\r\n      } else {\r\n        stats.pendingCount++\r\n      }\r\n\r\n      // 応答時間計算\r\n      if (feedback.status !== FeedbackStatus.SUBMITTED) {\r\n        const responseTime = (feedback.updatedAt.getTime() - feedback.createdAt.getTime()) / (1000 * 60 * 60) // 時間\r\n        responseTimes.push(responseTime)\r\n      }\r\n\r\n      // 満足度評価\r\n      if (feedback.reviewData) {\r\n        totalSatisfactionRating += feedback.reviewData.overallRating\r\n        reviewCount++\r\n      }\r\n\r\n      // トレンド分析\r\n      const dateKey = feedback.createdAt.toISOString().split('T')[0] // YYYY-MM-DD\r\n      stats.trends.daily[dateKey] = (stats.trends.daily[dateKey] || 0) + 1\r\n    })\r\n\r\n    // 平均満足度\r\n    if (reviewCount > 0) {\r\n      stats.averageSatisfactionRating = totalSatisfactionRating / reviewCount\r\n    }\r\n\r\n    // 応答時間統計\r\n    if (responseTimes.length > 0) {\r\n      stats.responseTime.average = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length\r\n      \r\n      const sortedTimes = responseTimes.sort((a, b) => a - b)\r\n      const midIndex = Math.floor(sortedTimes.length / 2)\r\n      stats.responseTime.median = sortedTimes.length % 2 === 0\r\n        ? (sortedTimes[midIndex - 1] + sortedTimes[midIndex]) / 2\r\n        : sortedTimes[midIndex]\r\n    }\r\n\r\n    return stats\r\n  }\r\n\r\n  /**\r\n   * 高優先度フィードバックを取得\r\n   */\r\n  getHighPriorityFeedbacks(): Feedback[] {\r\n    return this.searchFeedbacks({\r\n      priorities: [FeedbackPriority.HIGH, FeedbackPriority.CRITICAL],\r\n      statuses: [FeedbackStatus.SUBMITTED, FeedbackStatus.UNDER_REVIEW, FeedbackStatus.IN_PROGRESS]\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 未解決のバグレポートを取得\r\n   */\r\n  getUnresolvedBugReports(): Feedback[] {\r\n    return this.searchFeedbacks({\r\n      categories: [FeedbackCategory.BUG_REPORT],\r\n      statuses: [FeedbackStatus.SUBMITTED, FeedbackStatus.UNDER_REVIEW, FeedbackStatus.IN_PROGRESS]\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 最新のレビューを取得\r\n   */\r\n  getRecentReviews(limit: number = 10): Feedback[] {\r\n    const reviews = this.searchFeedbacks({\r\n      categories: [FeedbackCategory.GENERAL]\r\n    }).filter(f => f.isReview())\r\n\r\n    return reviews.slice(0, limit)\r\n  }\r\n\r\n  /**\r\n   * フィードバックを削除\r\n   */\r\n  deleteFeedback(id: string): boolean {\r\n    const result = this.feedbacks.delete(id)\r\n    if (result) {\r\n      this.saveToStorage()\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * 全フィードバックを取得\r\n   */\r\n  getAllFeedbacks(): Feedback[] {\r\n    return Array.from(this.feedbacks.values())\r\n      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())\r\n  }\r\n\r\n  /**\r\n   * フィードバックデータをエクスポート\r\n   */\r\n  exportFeedbacks(): string {\r\n    const data = Array.from(this.feedbacks.values()).map(f => f.toJSON())\r\n    return JSON.stringify(data, null, 2)\r\n  }\r\n\r\n  /**\r\n   * フィードバックデータをインポート\r\n   */\r\n  importFeedbacks(jsonData: string): boolean {\r\n    try {\r\n      const data = JSON.parse(jsonData)\r\n      if (!Array.isArray(data)) {\r\n        throw new Error('Invalid data format')\r\n      }\r\n\r\n      data.forEach(item => {\r\n        const feedback = Feedback.fromJSON(item)\r\n        this.feedbacks.set(feedback.id, feedback)\r\n      })\r\n\r\n      this.saveToStorage()\r\n      return true\r\n    } catch (error) {\r\n      console.error('Failed to import feedbacks:', error)\r\n      return false\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 満足度調査の結果を取得\r\n   */\r\n  getSatisfactionSurveyResults(): {\r\n    averageRating: number\r\n    totalResponses: number\r\n    ratingDistribution: Record<SatisfactionRating, number>\r\n    aspectRatings: {\r\n      gameplay: number\r\n      ui: number\r\n      performance: number\r\n      accessibility: number\r\n    }\r\n    recommendationRate: number\r\n  } {\r\n    const reviews = this.getAllFeedbacks().filter(f => f.isReview())\r\n    \r\n    if (reviews.length === 0) {\r\n      return {\r\n        averageRating: 0,\r\n        totalResponses: 0,\r\n        ratingDistribution: {} as Record<SatisfactionRating, number>,\r\n        aspectRatings: { gameplay: 0, ui: 0, performance: 0, accessibility: 0 },\r\n        recommendationRate: 0\r\n      }\r\n    }\r\n\r\n    let totalRating = 0\r\n    let totalRecommendations = 0\r\n    const ratingDistribution: Record<SatisfactionRating, number> = {\r\n      [SatisfactionRating.VERY_UNSATISFIED]: 0,\r\n      [SatisfactionRating.UNSATISFIED]: 0,\r\n      [SatisfactionRating.NEUTRAL]: 0,\r\n      [SatisfactionRating.SATISFIED]: 0,\r\n      [SatisfactionRating.VERY_SATISFIED]: 0\r\n    }\r\n    \r\n    const aspectTotals = { gameplay: 0, ui: 0, performance: 0, accessibility: 0 }\r\n\r\n    reviews.forEach(feedback => {\r\n      if (feedback.reviewData) {\r\n        const { overallRating, aspects, wouldRecommend } = feedback.reviewData\r\n        \r\n        totalRating += overallRating\r\n        ratingDistribution[overallRating]++\r\n        \r\n        if (wouldRecommend) totalRecommendations++\r\n        \r\n        aspectTotals.gameplay += aspects.gameplay\r\n        aspectTotals.ui += aspects.ui\r\n        aspectTotals.performance += aspects.performance\r\n        aspectTotals.accessibility += aspects.accessibility\r\n      }\r\n    })\r\n\r\n    return {\r\n      averageRating: totalRating / reviews.length,\r\n      totalResponses: reviews.length,\r\n      ratingDistribution,\r\n      aspectRatings: {\r\n        gameplay: aspectTotals.gameplay / reviews.length,\r\n        ui: aspectTotals.ui / reviews.length,\r\n        performance: aspectTotals.performance / reviews.length,\r\n        accessibility: aspectTotals.accessibility / reviews.length\r\n      },\r\n      recommendationRate: (totalRecommendations / reviews.length) * 100\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ローカルストレージからデータを読み込み\r\n   */\r\n  private loadFromStorage(): void {\r\n    try {\r\n      const data = localStorage.getItem(this.STORAGE_KEY)\r\n      if (data) {\r\n        const feedbacksData = JSON.parse(data)\r\n        feedbacksData.forEach((item: any) => {\r\n          const feedback = Feedback.fromJSON(item)\r\n          this.feedbacks.set(feedback.id, feedback)\r\n        })\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load feedback data from storage:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ローカルストレージにデータを保存\r\n   */\r\n  private saveToStorage(): void {\r\n    try {\r\n      const data = Array.from(this.feedbacks.values()).map(f => f.toJSON())\r\n      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data))\r\n    } catch (error) {\r\n      console.error('Failed to save feedback data to storage:', error)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 高優先度フィードバックの通知\r\n   */\r\n  private notifyHighPriorityFeedback(feedback: Feedback): void {\r\n    // 実際の実装では、管理者への通知やアラートを送信\r\n    console.warn(`🚨 高優先度フィードバック: ${feedback.getSummary()}`)\r\n    \r\n    // 将来的には以下のような通知機能を実装可能：\r\n    // - メール通知\r\n    // - Slack通知\r\n    // - デスクトップ通知\r\n    // - 管理画面での強調表示\r\n  }\r\n}","import type { Card } from './Card'\r\nimport type { CardType } from '../types/card.types'\r\n\r\n/**\r\n * デッキエンティティ\r\n */\r\nexport class Deck {\r\n  private cards: Card[]\r\n  private name: string\r\n\r\n  constructor(name: string, cards: Card[] = []) {\r\n    this.name = name\r\n    this.cards = [...cards]\r\n  }\r\n\r\n  /**\r\n   * デッキ名を取得\r\n   */\r\n  getName(): string {\r\n    return this.name\r\n  }\r\n\r\n  /**\r\n   * カード枚数を取得\r\n   */\r\n  size(): number {\r\n    return this.cards.length\r\n  }\r\n\r\n  /**\r\n   * デッキが空かどうか\r\n   */\r\n  isEmpty(): boolean {\r\n    return this.cards.length === 0\r\n  }\r\n\r\n  /**\r\n   * カードを追加\r\n   */\r\n  addCard(card: Card): void {\r\n    this.cards.push(card)\r\n  }\r\n\r\n  /**\r\n   * 複数のカードを追加\r\n   */\r\n  addCards(cards: Card[]): void {\r\n    this.cards.push(...cards)\r\n  }\r\n\r\n  /**\r\n   * カードを上から引く\r\n   */\r\n  drawCard(): Card | null {\r\n    return this.cards.pop() || null\r\n  }\r\n\r\n  /**\r\n   * 複数枚のカードを引く\r\n   */\r\n  drawCards(count: number): Card[] {\r\n    const drawn: Card[] = []\r\n    for (let i = 0; i < count && !this.isEmpty(); i++) {\r\n      const card = this.drawCard()\r\n      if (card) drawn.push(card)\r\n    }\r\n    return drawn\r\n  }\r\n\r\n  /**\r\n   * 特定のカードを削除\r\n   */\r\n  removeCard(cardId: string): boolean {\r\n    const index = this.cards.findIndex(card => card.id === cardId)\r\n    if (index !== -1) {\r\n      this.cards.splice(index, 1)\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * デッキをシャッフル（Fisher-Yatesアルゴリズム）\r\n   */\r\n  shuffle(): void {\r\n    for (let i = this.cards.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]]\r\n    }\r\n  }\r\n\r\n  /**\r\n   * デッキの中身を確認（コピーを返す）\r\n   */\r\n  getCards(): Card[] {\r\n    return [...this.cards]\r\n  }\r\n\r\n  /**\r\n   * 特定のタイプのカード枚数を取得\r\n   */\r\n  countCardsByType(type: CardType): number {\r\n    return this.cards.filter(card => card.type === type).length\r\n  }\r\n\r\n  /**\r\n   * デッキをクリア\r\n   */\r\n  clear(): void {\r\n    this.cards = []\r\n  }\r\n\r\n  /**\r\n   * デッキのコピーを作成\r\n   */\r\n  clone(): Deck {\r\n    return new Deck(\r\n      this.name,\r\n      this.cards.map(card => card.clone())\r\n    )\r\n  }\r\n\r\n  /**\r\n   * デッキの統計情報を取得\r\n   */\r\n  getStats(): {\r\n    total: number\r\n    byType: Record<CardType, number>\r\n    averagePower: number\r\n    averageCost: number\r\n  } {\r\n    const stats = {\r\n      total: this.cards.length,\r\n      byType: {\r\n        life: 0,\r\n        insurance: 0,\r\n        pitfall: 0\r\n      } as Record<CardType, number>,\r\n      averagePower: 0,\r\n      averageCost: 0\r\n    }\r\n\r\n    let totalPower = 0\r\n    let totalCost = 0\r\n\r\n    this.cards.forEach(card => {\r\n      stats.byType[card.type]++\r\n      totalPower += card.power\r\n      totalCost += card.cost\r\n    })\r\n\r\n    stats.averagePower = stats.total > 0 ? totalPower / stats.total : 0\r\n    stats.averageCost = stats.total > 0 ? totalCost / stats.total : 0\r\n\r\n    return stats\r\n  }\r\n}","/**\r\n * カードのパワーを表す値オブジェクト\r\n * \r\n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\r\n * ビジネスルール：\r\n * - パワーは0以上、999以下でなければならない\r\n * - 演算結果が最大値を超える場合は最大値に制限される\r\n */\r\nexport class CardPower {\r\n  private static readonly MIN_POWER = 0\r\n  private static readonly MAX_POWER = 999\r\n\r\n  private constructor(private readonly value: number) {\r\n    this.validate()\r\n  }\r\n\r\n  /**\r\n   * CardPower インスタンスを生成する\r\n   * @param value パワー値\r\n   * @throws {Error} 不正な値の場合\r\n   */\r\n  static create(value: number): CardPower {\r\n    return new CardPower(value)\r\n  }\r\n\r\n  /**\r\n   * 値の妥当性を検証する\r\n   * @private\r\n   */\r\n  private validate(): void {\r\n    if (this.value < CardPower.MIN_POWER) {\r\n      throw new Error('CardPower must be non-negative')\r\n    }\r\n    if (this.value > CardPower.MAX_POWER) {\r\n      throw new Error('CardPower cannot exceed maximum')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * パワー値を取得\r\n   */\r\n  getValue(): number {\r\n    return this.value\r\n  }\r\n\r\n  /**\r\n   * 他のCardPowerと加算\r\n   * @param other 加算するCardPower\r\n   * @returns 新しいCardPowerインスタンス\r\n   */\r\n  add(other: CardPower): CardPower {\r\n    const sum = this.value + other.value\r\n    return new CardPower(Math.min(sum, CardPower.MAX_POWER))\r\n  }\r\n\r\n  /**\r\n   * 複数のCardPowerを合計\r\n   * @param powers CardPowerの配列\r\n   * @returns 合計のCardPower\r\n   */\r\n  static sum(powers: CardPower[]): CardPower {\r\n    const total = powers.reduce((sum, power) => sum + power.value, 0)\r\n    return new CardPower(Math.min(total, CardPower.MAX_POWER))\r\n  }\r\n\r\n  /**\r\n   * 倍率を適用\r\n   * @param multiplier 倍率（0以上）\r\n   * @returns 新しいCardPowerインスタンス\r\n   * @throws {Error} 倍率が負の場合\r\n   */\r\n  multiply(multiplier: number): CardPower {\r\n    if (multiplier < 0) {\r\n      throw new Error('Multiplier cannot be negative')\r\n    }\r\n    const result = Math.floor(this.value * multiplier)\r\n    return new CardPower(Math.min(result, CardPower.MAX_POWER))\r\n  }\r\n\r\n  /**\r\n   * 他のCardPowerより大きいか判定\r\n   */\r\n  isGreaterThan(other: CardPower): boolean {\r\n    return this.value > other.value\r\n  }\r\n\r\n  /**\r\n   * 他のCardPower以上か判定\r\n   */\r\n  isGreaterThanOrEqual(other: CardPower): boolean {\r\n    return this.value >= other.value\r\n  }\r\n\r\n  /**\r\n   * 他のCardPowerと等価か判定\r\n   */\r\n  equals(other: CardPower): boolean {\r\n    return this.value === other.value\r\n  }\r\n\r\n  /**\r\n   * 文字列表現を取得\r\n   */\r\n  toString(): string {\r\n    return `Power: ${this.value}`\r\n  }\r\n\r\n  /**\r\n   * ゼロパワーの定数\r\n   */\r\n  static get ZERO(): CardPower {\r\n    return new CardPower(0)\r\n  }\r\n\r\n  /**\r\n   * 最大パワーの定数\r\n   */\r\n  static get MAX(): CardPower {\r\n    return new CardPower(CardPower.MAX_POWER)\r\n  }\r\n}","/**\r\n * 保険料を表す値オブジェクト\r\n * \r\n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\r\n * ビジネスルール：\r\n * - 保険料は0以上、99以下でなければならない\r\n * - 0は無料保険を表す\r\n * - 20以上は高額保険料とみなされる\r\n */\r\nexport class InsurancePremium {\r\n  private static readonly MIN_PREMIUM = 0\r\n  private static readonly MAX_PREMIUM = 99\r\n  private static readonly EXPENSIVE_THRESHOLD = 20\r\n\r\n  private constructor(private readonly value: number) {\r\n    this.validate()\r\n  }\r\n\r\n  /**\r\n   * InsurancePremium インスタンスを生成する\r\n   * @param value 保険料値\r\n   * @throws {Error} 不正な値の場合\r\n   */\r\n  static create(value: number): InsurancePremium {\r\n    return new InsurancePremium(Math.floor(value))\r\n  }\r\n\r\n  /**\r\n   * 値の妥当性を検証する\r\n   * @private\r\n   */\r\n  private validate(): void {\r\n    if (this.value < InsurancePremium.MIN_PREMIUM) {\r\n      throw new Error('InsurancePremium must be non-negative')\r\n    }\r\n    if (this.value > InsurancePremium.MAX_PREMIUM) {\r\n      throw new Error('InsurancePremium cannot exceed maximum')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険料値を取得\r\n   */\r\n  getValue(): number {\r\n    return this.value\r\n  }\r\n\r\n  /**\r\n   * 複数の保険料を合計\r\n   * @param premiums InsurancePremiumの配列\r\n   * @returns 合計の保険料\r\n   */\r\n  static sum(premiums: InsurancePremium[]): InsurancePremium {\r\n    const total = premiums.reduce((sum, premium) => sum + premium.value, 0)\r\n    return new InsurancePremium(Math.min(total, InsurancePremium.MAX_PREMIUM))\r\n  }\r\n\r\n  /**\r\n   * 割引率を適用\r\n   * @param discountRate 割引率（0.0〜1.0）\r\n   * @returns 新しいInsurancePremiumインスタンス\r\n   * @throws {Error} 割引率が不正な場合\r\n   */\r\n  applyDiscount(discountRate: number): InsurancePremium {\r\n    if (discountRate < 0) {\r\n      throw new Error('Discount rate cannot be negative')\r\n    }\r\n    if (discountRate > 1) {\r\n      throw new Error('Discount rate cannot exceed 100%')\r\n    }\r\n    \r\n    const discountedValue = Math.floor(this.value * (1 - discountRate))\r\n    return new InsurancePremium(discountedValue)\r\n  }\r\n\r\n  /**\r\n   * 倍率を適用\r\n   * @param multiplier 倍率（0以上）\r\n   * @returns 新しいInsurancePremiumインスタンス\r\n   * @throws {Error} 倍率が負の場合\r\n   */\r\n  applyMultiplier(multiplier: number): InsurancePremium {\r\n    if (multiplier < 0) {\r\n      throw new Error('Multiplier cannot be negative')\r\n    }\r\n    \r\n    const multipliedValue = Math.floor(this.value * multiplier)\r\n    return new InsurancePremium(Math.min(multipliedValue, InsurancePremium.MAX_PREMIUM))\r\n  }\r\n\r\n  /**\r\n   * 無料保険かどうか判定\r\n   */\r\n  isFree(): boolean {\r\n    return this.value === 0\r\n  }\r\n\r\n  /**\r\n   * 高額保険料かどうか判定\r\n   */\r\n  isExpensive(): boolean {\r\n    return this.value >= InsurancePremium.EXPENSIVE_THRESHOLD\r\n  }\r\n\r\n  /**\r\n   * 他の保険料より高いか判定\r\n   */\r\n  isHigherThan(other: InsurancePremium): boolean {\r\n    return this.value > other.value\r\n  }\r\n\r\n  /**\r\n   * 指定された活力で負担可能か判定\r\n   * @param availableVitality 利用可能な活力\r\n   */\r\n  isAffordableWith(availableVitality: number): boolean {\r\n    return availableVitality >= this.value\r\n  }\r\n\r\n  /**\r\n   * 他のInsurancePremiumと等価か判定\r\n   */\r\n  equals(other: InsurancePremium): boolean {\r\n    return this.value === other.value\r\n  }\r\n\r\n  /**\r\n   * 文字列表現を取得\r\n   */\r\n  toString(): string {\r\n    if (this.isFree()) {\r\n      return '保険料: 無料'\r\n    }\r\n    return `保険料: ${this.value}`\r\n  }\r\n\r\n  /**\r\n   * 無料保険の定数\r\n   */\r\n  static get FREE(): InsurancePremium {\r\n    return new InsurancePremium(0)\r\n  }\r\n}","import type { \r\n  ICard, \r\n  IAdvancedCard,\r\n  CardType, \r\n  CardEffect,\r\n  CardEffectType, \r\n  LifeCardCategory, \r\n  InsuranceType,\r\n  InsuranceDurationType,\r\n  InsuranceEffectType,\r\n  DreamCategory,\r\n  SkillCardProperties,\r\n  ComboCardProperties,\r\n  EventCardProperties,\r\n  SkillRarity\r\n} from '../types/card.types'\r\nimport { CardPower } from '../valueObjects/CardPower'\r\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\r\nimport { IdGenerator } from '../../common/IdGenerator'\r\n\r\n/**\r\n * カードエンティティ - ゲーム内のすべてのカードの基底クラス\r\n * \r\n * このクラスは値オブジェクトを使用してビジネスルールを表現します：\r\n * - power: CardPower値オブジェクト（カードの効果値）\r\n * - cost: InsurancePremium値オブジェクト（保険カードの場合）\r\n * \r\n * @implements {IAdvancedCard} 拡張カードインターフェース\r\n * \r\n * @example\r\n * // 人生カードの作成\r\n * const lifeCard = Card.createLifeCard('アルバイト収入', 1);\r\n * \r\n * // 保険カードの作成\r\n * const insuranceCard = Card.createInsuranceCard('健康保険', 2);\r\n * \r\n * // スキルカードの作成\r\n * const skillCard = Card.createSkillCard('プロフェッショナル', 'rare', 3);\r\n */\r\nexport class Card implements IAdvancedCard {\r\n  readonly id: string\r\n  readonly name: string\r\n  readonly description: string\r\n  readonly type: CardType\r\n  private readonly _power: CardPower\r\n  private readonly _cost: InsurancePremium\r\n  readonly effects: CardEffect[]\r\n  readonly imageUrl?: string\r\n  readonly category?: LifeCardCategory\r\n  readonly insuranceType?: InsuranceType\r\n  readonly coverage?: number\r\n  readonly penalty?: number\r\n  // 保険カード用プロパティ\r\n  readonly ageBonus?: number\r\n  readonly durationType?: InsuranceDurationType\r\n  remainingTurns?: number // 可変プロパティ（ターンごとに減少）\r\n  readonly insuranceEffectType?: InsuranceEffectType\r\n  // Phase 4 夢カード用プロパティ\r\n  readonly dreamCategory?: DreamCategory\r\n  \r\n  // 拡張カード用プロパティ\r\n  readonly skillProperties?: SkillCardProperties\r\n  readonly comboProperties?: ComboCardProperties\r\n  readonly eventProperties?: EventCardProperties\r\n  readonly isUnlockable?: boolean\r\n  readonly unlockCondition?: string\r\n\r\n  /**\r\n   * Cardインスタンスを作成\r\n   * @param {IAdvancedCard} params - カードのパラメータ\r\n   */\r\n  constructor(params: IAdvancedCard) {\r\n    this.id = params.id\r\n    this.name = params.name\r\n    this.description = params.description\r\n    this.type = params.type\r\n    \r\n    // 値オブジェクトでラップ\r\n    this._power = CardPower.create(params.power)\r\n    this._cost = InsurancePremium.create(params.cost)\r\n    \r\n    this.effects = params.effects\r\n    this.imageUrl = params.imageUrl\r\n    this.category = params.category\r\n    this.insuranceType = params.insuranceType\r\n    this.coverage = params.coverage\r\n    this.penalty = params.penalty\r\n    \r\n    // 年齢ボーナスのプロパティ\r\n    if ('ageBonus' in params) {\r\n      this.ageBonus = params.ageBonus\r\n    }\r\n    \r\n    // 保険期間のプロパティ\r\n    if ('durationType' in params) {\r\n      this.durationType = params.durationType\r\n    }\r\n    if ('remainingTurns' in params) {\r\n      this.remainingTurns = params.remainingTurns\r\n    }\r\n    if ('insuranceEffectType' in params) {\r\n      this.insuranceEffectType = params.insuranceEffectType\r\n    }\r\n    \r\n    // Phase 4 夢カードのプロパティ\r\n    if ('dreamCategory' in params) {\r\n      this.dreamCategory = params.dreamCategory\r\n    }\r\n    \r\n    // 拡張カード用プロパティ\r\n    if ('skillProperties' in params) {\r\n      this.skillProperties = params.skillProperties\r\n    }\r\n    if ('comboProperties' in params) {\r\n      this.comboProperties = params.comboProperties\r\n    }\r\n    if ('eventProperties' in params) {\r\n      this.eventProperties = params.eventProperties\r\n    }\r\n    if ('isUnlockable' in params) {\r\n      this.isUnlockable = params.isUnlockable\r\n    }\r\n    if ('unlockCondition' in params) {\r\n      this.unlockCondition = params.unlockCondition\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 後方互換性のためのgetter - カードのパワー値を取得\r\n   * @returns {number} カードのパワー値\r\n   */\r\n  get power(): number {\r\n    return this._power.getValue()\r\n  }\r\n\r\n  /**\r\n   * カードのコストを取得\r\n   * @returns {number} カードのコスト\r\n   */\r\n  get cost(): number {\r\n    return this._cost.getValue()\r\n  }\r\n\r\n  /**\r\n   * 値オブジェクトとしてのpower取得\r\n   * @returns {CardPower} カードパワー値オブジェクト\r\n   */\r\n  getPower(): CardPower {\r\n    return this._power\r\n  }\r\n\r\n  /**\r\n   * 値オブジェクトとしてのcost取得\r\n   * @returns {InsurancePremium} 保険料値オブジェクト\r\n   */\r\n  getCost(): InsurancePremium {\r\n    return this._cost\r\n  }\r\n\r\n  /**\r\n   * カードが特定の効果を持っているか判定\r\n   * @param {CardEffectType} effectType - 確認する効果タイプ\r\n   * @returns {boolean} 効果を持っている場合true\r\n   */\r\n  hasEffect(effectType: CardEffectType): boolean {\r\n    return this.effects.some(effect => effect.type === effectType)\r\n  }\r\n\r\n  /**\r\n   * 特定の効果を取得\r\n   * @param {CardEffectType} effectType - 取得する効果タイプ\r\n   * @returns {CardEffect | undefined} 効果オブジェクトまたはundefined\r\n   */\r\n  getEffect(effectType: CardEffectType): CardEffect | undefined {\r\n    return this.effects.find(effect => effect.type === effectType)\r\n  }\r\n\r\n  /**\r\n   * 保険カードかどうか判定\r\n   * @returns {boolean} 保険カードの場合true\r\n   */\r\n  isInsurance(): boolean {\r\n    return this.type === 'insurance'\r\n  }\r\n\r\n  /**\r\n   * 定期保険かどうか判定\r\n   * @returns {boolean} 定期保険の場合true\r\n   */\r\n  isTermInsurance(): boolean {\r\n    return this.isInsurance() && this.durationType === 'term'\r\n  }\r\n\r\n  /**\r\n   * 終身保険かどうか判定\r\n   * @returns {boolean} 終身保険の場合true\r\n   */\r\n  isWholeLifeInsurance(): boolean {\r\n    return this.isInsurance() && this.durationType === 'whole_life'\r\n  }\r\n\r\n  /**\r\n   * 保険効果タイプを取得\r\n   * @returns {InsuranceEffectType | undefined} 保険効果タイプ\r\n   */\r\n  getInsuranceEffectType(): InsuranceEffectType | undefined {\r\n    if (!this.isInsurance()) return undefined\r\n    return this.insuranceEffectType || 'offensive' // デフォルトは攻撃型\r\n  }\r\n\r\n  /**\r\n   * 防御型保険かどうか判定\r\n   * @returns {boolean} 防御型保険の場合true\r\n   */\r\n  isDefensiveInsurance(): boolean {\r\n    return this.isInsurance() && this.getInsuranceEffectType() === 'defensive'\r\n  }\r\n\r\n  /**\r\n   * 回復型保険かどうか判定\r\n   * @returns {boolean} 回復型保険の場合true\r\n   */\r\n  isRecoveryInsurance(): boolean {\r\n    return this.isInsurance() && this.getInsuranceEffectType() === 'recovery'\r\n  }\r\n\r\n  /**\r\n   * 特化型保険かどうか判定\r\n   * @returns {boolean} 特化型保険の場合true\r\n   */\r\n  isSpecializedInsurance(): boolean {\r\n    return this.isInsurance() && this.getInsuranceEffectType() === 'specialized'\r\n  }\r\n\r\n  /**\r\n   * ダメージ軽減量を計算（防御型保険用）\r\n   * @returns {number} ダメージ軽減量\r\n   */\r\n  calculateDamageReduction(): number {\r\n    if (!this.isDefensiveInsurance()) return 0\r\n    \r\n    // カバレッジに基づいて軽減量を計算\r\n    const baseReduction = Math.floor((this.coverage || 0) / 10)\r\n    \r\n    // ダメージ軽減効果がある場合はその値を加算\r\n    const reductionEffect = this.getEffect('damage_reduction')\r\n    const effectReduction = reductionEffect ? reductionEffect.value : 0\r\n    \r\n    return baseReduction + effectReduction\r\n  }\r\n\r\n  /**\r\n   * ターン回復量を計算（回復型保険用）\r\n   * @returns {number} ターン回復量\r\n   */\r\n  calculateTurnHeal(): number {\r\n    if (!this.isRecoveryInsurance()) return 0\r\n    \r\n    // カバレッジに基づいて回復量を計算\r\n    const baseHeal = Math.floor((this.coverage || 0) / 20)\r\n    \r\n    // ターン回復効果がある場合はその値を加算\r\n    const healEffect = this.getEffect('turn_heal')\r\n    const effectHeal = healEffect ? healEffect.value : 0\r\n    \r\n    return baseHeal + effectHeal\r\n  }\r\n\r\n  /**\r\n   * 特定チャレンジへのボーナスを計算（特化型保険用）\r\n   * @param {string} challengeType チャレンジタイプ\r\n   * @returns {number} ボーナスパワー\r\n   */\r\n  calculateChallengeBonus(challengeType: string): number {\r\n    if (!this.isSpecializedInsurance()) return 0\r\n    \r\n    // 特定チャレンジボーナス効果を確認\r\n    const bonusEffect = this.getEffect('challenge_bonus')\r\n    if (!bonusEffect?.condition) return 0\r\n    \r\n    // 条件が一致する場合のみボーナスを返す\r\n    if (bonusEffect.condition.includes(challengeType)) {\r\n      return bonusEffect.value\r\n    }\r\n    \r\n    return 0\r\n  }\r\n\r\n  /**\r\n   * Phase 4: 夢カードかどうか判定\r\n   * @returns {boolean} 夢カードの場合true\r\n   */\r\n  isDreamCard(): boolean {\r\n    return this.type === 'dream'\r\n  }\r\n\r\n  /**\r\n   * カードのコピーを作成（一部のプロパティを更新可能）\r\n   * @param {Partial<IAdvancedCard>} [updates] - 更新するプロパティ\r\n   * @returns {Card} 新しいCardインスタンス\r\n   */\r\n  copy(updates?: Partial<IAdvancedCard>): Card {\r\n    return new Card({\r\n      ...this,\r\n      power: this.power, // getter経由で取得\r\n      cost: this.cost,   // getter経由で取得\r\n      effects: [...this.effects], // 配列の深いコピー\r\n      ...updates\r\n    })\r\n  }\r\n\r\n  /**\r\n   * カードのクローンを作成（後方互換性のため）\r\n   * @returns {Card} カードの完全なコピー\r\n   * @deprecated copy()メソッドの使用を推奨\r\n   */\r\n  clone(): Card {\r\n    return this.copy()\r\n  }\r\n\r\n  /**\r\n   * 残りターン数を減少させる（定期保険用）\r\n   * @returns {Card} ターン数を減らした新しいCardインスタンス\r\n   */\r\n  decrementRemainingTurns(): Card {\r\n    if (!this.isTermInsurance() || !this.remainingTurns) {\r\n      return this\r\n    }\r\n    \r\n    return this.copy({\r\n      remainingTurns: Math.max(0, this.remainingTurns - 1)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 保険が有効期限切れかどうか判定\r\n   * @returns {boolean} 期限切れの場合true\r\n   */\r\n  isExpired(): boolean {\r\n    if (!this.isTermInsurance()) {\r\n      return false\r\n    }\r\n    return this.remainingTurns === 0\r\n  }\r\n\r\n  /**\r\n   * パワーが指定値以上か判定（値オブジェクトを使用）\r\n   * @param {number} threshold - 闾値\r\n   * @returns {boolean} パワーが闾値以上の場合true\r\n   */\r\n  hasPowerAtLeast(requiredPower: number): boolean {\r\n    const required = CardPower.create(requiredPower)\r\n    return this._power.isGreaterThanOrEqual(required)\r\n  }\r\n\r\n  /**\r\n   * コストが支払い可能か判定（値オブジェクトを使用）\r\n   */\r\n  isAffordableWith(availableVitality: number): boolean {\r\n    return this._cost.isAffordableWith(availableVitality)\r\n  }\r\n\r\n  /**\r\n   * 効果的なパワーを計算（年齢ボーナス等を含む）\r\n   */\r\n  calculateEffectivePower(): number {\r\n    let effectivePower = this.power\r\n\r\n    // 保険カードの年齢ボーナスを適用\r\n    if (this.isInsurance() && this.ageBonus) {\r\n      effectivePower += this.ageBonus\r\n    }\r\n    \r\n    // 攻撃型保険以外はパワーを提供しない\r\n    if (this.isInsurance() && this.getInsuranceEffectType() !== 'offensive') {\r\n      return 0\r\n    }\r\n\r\n    return Math.max(0, effectivePower)\r\n  }\r\n\r\n  /**\r\n   * ライフカードかどうか判定\r\n   */\r\n  isLifeCard(): boolean {\r\n    return this.type === 'life'\r\n  }\r\n\r\n  /**\r\n   * 保険カードかどうか判定（エイリアス）\r\n   */\r\n  isInsuranceCard(): boolean {\r\n    return this.isInsurance()\r\n  }\r\n\r\n  /**\r\n   * 落とし穴カードかどうか判定\r\n   */\r\n  isPitfallCard(): boolean {\r\n    return this.type === 'pitfall'\r\n  }\r\n\r\n  /**\r\n   * スキルカードかどうか判定\r\n   */\r\n  isSkillCard(): boolean {\r\n    return this.type === 'skill'\r\n  }\r\n\r\n  /**\r\n   * コンボカードかどうか判定\r\n   */\r\n  isComboCard(): boolean {\r\n    return this.type === 'combo'\r\n  }\r\n\r\n  /**\r\n   * イベントカードかどうか判定\r\n   */\r\n  isEventCard(): boolean {\r\n    return this.type === 'event'\r\n  }\r\n\r\n  /**\r\n   * レジェンダリーカードかどうか判定\r\n   */\r\n  isLegendaryCard(): boolean {\r\n    return this.type === 'legendary'\r\n  }\r\n\r\n  /**\r\n   * チャレンジカードかどうか判定\r\n   */\r\n  isChallengeCard(): boolean {\r\n    return this.type === 'challenge'\r\n  }\r\n\r\n  /**\r\n   * カードの表示用文字列を生成\r\n   */\r\n  toDisplayString(): string {\r\n    let display = `${this.name} (${this.power})`\r\n    \r\n    if (this.effects.length > 0) {\r\n      const effectDescriptions = this.effects.map(effect => effect.description).join(', ')\r\n      display += ` - ${effectDescriptions}`\r\n    }\r\n    \r\n    return display\r\n  }\r\n\r\n  /**\r\n   * ターン数を減少させる（mutableな操作）\r\n   */\r\n  decrementTurn(): void {\r\n    if (this.remainingTurns !== undefined && this.remainingTurns > 0) {\r\n      this.remainingTurns--\r\n    }\r\n  }\r\n\r\n  // === 静的ファクトリーメソッド（TDD: Green Phase） ===\r\n\r\n  /**\r\n   * ライフカードを作成\r\n   */\r\n  static createLifeCard(name: string, power: number): Card {\r\n    const powerSign = power > 0 ? '+' : ''\r\n    return new Card({\r\n      id: IdGenerator.generate('life'),\r\n      name,\r\n      description: `パワー: ${powerSign}${power}`,\r\n      type: 'life',\r\n      power,\r\n      cost: 0,\r\n      effects: []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * チャレンジカードを作成\r\n   */\r\n  static createChallengeCard(name: string, power: number): Card {\r\n    const card = new Card({\r\n      id: IdGenerator.generate('challenge'),\r\n      name,\r\n      description: `必要パワー: ${power}`,\r\n      type: 'challenge',\r\n      power,\r\n      cost: 0,\r\n      effects: []\r\n    })\r\n    \r\n    return card\r\n  }\r\n\r\n  /**\r\n   * 保険カードを作成\r\n   */\r\n  static createInsuranceCard(name: string, power: number, ...effects: CardEffect[]): Card {\r\n    return new Card({\r\n      id: IdGenerator.generate('insurance'),\r\n      name,\r\n      description: `保険カード - パワー: +${power}`,\r\n      type: 'insurance',\r\n      power,\r\n      cost: 1,\r\n      effects\r\n    })\r\n  }\r\n\r\n  /**\r\n   * スキルカードを作成\r\n   */\r\n  static createSkillCard(name: string, rarity: SkillRarity, power: number, cooldown?: number): Card {\r\n    const rarityDescriptions = {\r\n      common: 'コモン',\r\n      rare: 'レア', \r\n      epic: 'エピック',\r\n      legendary: 'レジェンダリー'\r\n    }\r\n    \r\n    return new Card({\r\n      id: IdGenerator.generate('skill'),\r\n      name,\r\n      description: `${rarityDescriptions[rarity]}スキル - パワー: +${power}`,\r\n      type: 'skill',\r\n      power,\r\n      cost: 0,\r\n      effects: [],\r\n      skillProperties: {\r\n        rarity,\r\n        cooldown,\r\n        remainingCooldown: 0,\r\n        masteryLevel: 1\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * コンボカードを作成\r\n   */\r\n  static createComboCard(name: string, power: number, requiredCards: string[], comboBonus: number): Card {\r\n    return new Card({\r\n      id: IdGenerator.generate('combo'),\r\n      name,\r\n      description: `コンボカード - パワー: +${power} (コンボ時: +${comboBonus})`,\r\n      type: 'combo',\r\n      power,\r\n      cost: 0,\r\n      effects: [],\r\n      comboProperties: {\r\n        requiredCards,\r\n        comboBonus\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * イベントカードを作成\r\n   */\r\n  static createEventCard(name: string, power: number, duration: number, globalEffect = false): Card {\r\n    return new Card({\r\n      id: IdGenerator.generate('event'),\r\n      name,\r\n      description: `イベントカード - ${duration}ターン継続`,\r\n      type: 'event',\r\n      power,\r\n      cost: 0,\r\n      effects: [],\r\n      eventProperties: {\r\n        duration,\r\n        globalEffect\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * レジェンダリーカードを作成\r\n   */\r\n  static createLegendaryCard(name: string, power: number, unlockCondition: string): Card {\r\n    return new Card({\r\n      id: IdGenerator.generate('legendary'),\r\n      name,\r\n      description: `レジェンダリーカード - パワー: +${power}`,\r\n      type: 'legendary',\r\n      power,\r\n      cost: 0,\r\n      effects: [],\r\n      isUnlockable: true,\r\n      unlockCondition\r\n    })\r\n  }\r\n}","import { Card } from './Card'\nimport type { CardEffect, DreamCategory } from '../types/card.types'\nimport { IdGenerator } from '../../common/IdGenerator'\n\n/**\n * リスク・リワードチャレンジカード\n * \n * 高リスク・高リワードの意思決定を促すチャレンジカード。\n * 失敗時のペナルティが大きいが、成功時の報酬も大きい。\n */\nexport class RiskRewardChallenge extends Card {\n  readonly riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n  readonly successBonus: number\n  readonly failurePenalty: number\n  readonly insuranceImmunity: boolean // 保険が効かないかどうか\n\n  constructor(params: {\n    name: string\n    description: string\n    power: number\n    riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n    successBonus: number\n    failurePenalty: number\n    insuranceImmunity?: boolean\n    dreamCategory?: DreamCategory\n  }) {\n    const effects: CardEffect[] = []\n    \n    // リスクレベルに応じた特殊効果\n    if (params.riskLevel === 'extreme') {\n      effects.push({\n        type: 'special_action',\n        value: 0,\n        description: '保険効果無効化',\n        condition: 'このチャレンジでは保険カードのパワーが無効'\n      })\n    }\n\n    super({\n      id: IdGenerator.generateCardId(),\n      type: 'challenge',\n      name: params.name,\n      description: params.description,\n      power: params.power,\n      cost: 0,\n      effects,\n      dreamCategory: params.dreamCategory\n    })\n\n    this.riskLevel = params.riskLevel\n    this.successBonus = params.successBonus\n    this.failurePenalty = params.failurePenalty\n    this.insuranceImmunity = params.insuranceImmunity || params.riskLevel === 'extreme'\n  }\n\n  /**\n   * リスク倍率を取得\n   */\n  getRiskMultiplier(): number {\n    const multipliers = {\n      low: 1.2,\n      medium: 1.5,\n      high: 2.0,\n      extreme: 3.0\n    }\n    return multipliers[this.riskLevel]\n  }\n\n  /**\n   * 成功時の実際の報酬を計算\n   */\n  calculateActualReward(baseReward: number): number {\n    return Math.floor(baseReward * this.getRiskMultiplier()) + this.successBonus\n  }\n\n  /**\n   * 失敗時の実際のペナルティを計算\n   */\n  calculateActualPenalty(basePenalty: number): number {\n    return Math.floor(basePenalty * this.getRiskMultiplier()) + this.failurePenalty\n  }\n\n  /**\n   * リスクレベルの説明を取得\n   */\n  getRiskDescription(): string {\n    const descriptions = {\n      low: '低リスク: 少し危険だが、失敗してもダメージは軽い',\n      medium: '中リスク: 成功と失敗のバランスが取れている',\n      high: '高リスク: 失敗時のダメージが大きいが、報酬も魅力的',\n      extreme: '極限リスク: 保険も効かない危険な挑戦。成功すれば大きな報酬'\n    }\n    return descriptions[this.riskLevel]\n  }\n\n  /**\n   * チャレンジの詳細情報を取得\n   */\n  getChallengeDetails(): string {\n    const details = [\n      `必要パワー: ${this.power}`,\n      `リスクレベル: ${this.riskLevel.toUpperCase()}`,\n      `成功ボーナス: +${this.successBonus} 活力`,\n      `失敗ペナルティ: -${this.failurePenalty} 活力`,\n      this.insuranceImmunity ? '⚠️ 保険無効' : ''\n    ].filter(Boolean)\n\n    return details.join('\\n')\n  }\n\n  /**\n   * ファクトリーメソッド: リスクレベルに応じたチャレンジを作成\n   */\n  static createRiskChallenge(\n    stage: 'youth' | 'middle' | 'fulfillment',\n    riskLevel: 'low' | 'medium' | 'high' | 'extreme'\n  ): RiskRewardChallenge {\n    const challengeTemplates = {\n      youth: {\n        low: {\n          name: '新しいスポーツへの挑戦',\n          description: '未経験の分野に挑戦する勇気',\n          power: 5,\n          successBonus: 2,\n          failurePenalty: 1\n        },\n        medium: {\n          name: '起業への第一歩',\n          description: '安定を捨てて夢を追う決断',\n          power: 7,\n          successBonus: 5,\n          failurePenalty: 3\n        },\n        high: {\n          name: '海外留学',\n          description: '未知の世界への大きな飛躍',\n          power: 9,\n          successBonus: 8,\n          failurePenalty: 5\n        },\n        extreme: {\n          name: '人生を賭けた大勝負',\n          description: '全てを投げ打って挑む最大の挑戦',\n          power: 12,\n          successBonus: 15,\n          failurePenalty: 10\n        }\n      },\n      middle: {\n        low: {\n          name: '副業の開始',\n          description: '新たな収入源への挑戦',\n          power: 6,\n          successBonus: 3,\n          failurePenalty: 2\n        },\n        medium: {\n          name: '独立開業',\n          description: '会社を辞めて独立する決断',\n          power: 9,\n          successBonus: 7,\n          failurePenalty: 5\n        },\n        high: {\n          name: '大型投資',\n          description: '将来を見据えた大胆な投資',\n          power: 11,\n          successBonus: 10,\n          failurePenalty: 7\n        },\n        extreme: {\n          name: '人生の大転換',\n          description: '全てをリセットして新しい道へ',\n          power: 15,\n          successBonus: 20,\n          failurePenalty: 15\n        }\n      },\n      fulfillment: {\n        low: {\n          name: '新しい趣味への挑戦',\n          description: '年齢に関係なく新しいことを始める',\n          power: 7,\n          successBonus: 4,\n          failurePenalty: 2\n        },\n        medium: {\n          name: 'ボランティア活動',\n          description: '社会貢献への新たな一歩',\n          power: 10,\n          successBonus: 8,\n          failurePenalty: 4\n        },\n        high: {\n          name: '遺産の活用',\n          description: '次世代への大きな投資',\n          power: 13,\n          successBonus: 12,\n          failurePenalty: 8\n        },\n        extreme: {\n          name: '人生最後の大冒険',\n          description: '残された時間での究極の挑戦',\n          power: 18,\n          successBonus: 25,\n          failurePenalty: 20\n        }\n      }\n    }\n\n    const template = challengeTemplates[stage][riskLevel]\n    \n    return new RiskRewardChallenge({\n      ...template,\n      riskLevel,\n      dreamCategory: riskLevel === 'extreme' ? 'mixed' : 'physical'\n    })\n  }\n}","import { Card } from '../entities/Card'\r\nimport type { \r\n  LifeCardCategory, \r\n  InsuranceType, \r\n  GameStage,\r\n  DreamCategory,\r\n  SkillRarity,\r\n  CardEffect\r\n} from '../types/card.types'\r\nimport type { InsuranceTypeChoice } from '../types/game.types'\r\nimport { IdGenerator } from '../../common/IdGenerator'\r\nimport { RiskRewardChallenge } from '../entities/RiskRewardChallenge'\r\n\r\n/**\r\n * カードファクトリー\r\n * ゲーム用のカードを生成する\r\n */\r\nexport class CardFactory {\r\n\r\n  /**\r\n   * 年齢ボーナスを計算\r\n   */\r\n  private static calculateAgeBonus(stage: GameStage): number {\r\n    switch(stage) {\r\n      case 'middle': return 0.5\r\n      case 'fulfillment': return 1.0\r\n      default: return 0\r\n    }\r\n  }\r\n\r\n  /**\r\n   * カード配列から実際のカードを生成\r\n   */\r\n  private static createCardsFromDefinitions<T extends { name: string }>(definitions: T[], createFn: (def: T) => Card): Card[] {\r\n    return definitions.map(def => createFn(def))\r\n  }\r\n\r\n  /**\r\n   * 初期デッキ用の人生カードを生成\r\n   */\r\n  static createStarterLifeCards(): Card[] {\r\n    const starterCardDefinitions = [\r\n      // 健康カード\r\n      { name: '朝のジョギング', description: '健康的な一日の始まり', category: 'health' as LifeCardCategory, power: 2, cost: 1 },\r\n      { name: '栄養バランスの良い食事', description: '体調管理の基本', category: 'health' as LifeCardCategory, power: 3, cost: 2 },\r\n      // キャリアカード\r\n      { name: '新しいスキルの習得', description: '成長への投資', category: 'career' as LifeCardCategory, power: 3, cost: 2 },\r\n      { name: 'チームワーク', description: '仲間との協力', category: 'career' as LifeCardCategory, power: 2, cost: 1 },\r\n      // 家族カード\r\n      { name: '家族との団らん', description: '心の充電', category: 'family' as LifeCardCategory, power: 2, cost: 1 },\r\n      // 趣味カード\r\n      { name: '趣味の時間', description: 'リフレッシュタイム', category: 'hobby' as LifeCardCategory, power: 2, cost: 1 },\r\n      // 金融カード\r\n      { name: '計画的な貯蓄', description: '将来への備え', category: 'finance' as LifeCardCategory, power: 3, cost: 2 }\r\n    ]\r\n\r\n    return this.createCardsFromDefinitions(starterCardDefinitions, def => this.createLifeCard(def))\r\n  }\r\n\r\n  /**\r\n   * 基本的な保険カードを生成（簡素化版：すべて終身保険、永続効果）\r\n   */\r\n  static createBasicInsuranceCards(stage: GameStage = 'youth'): Card[] {\r\n    const ageBonus = this.calculateAgeBonus(stage)\r\n    \r\n    const basicInsuranceDefinitions = [\r\n      { name: '医療保険', description: '病気やケガに備える永続保障', insuranceType: 'medical' as InsuranceType, power: 4, cost: 3, coverage: 100 },\r\n      { name: '生命保険', description: '家族を守る永続保障', insuranceType: 'life' as InsuranceType, power: 5, cost: 4, coverage: 200 },\r\n      { name: '収入保障保険', description: '働けなくなった時の永続保障', insuranceType: 'income' as InsuranceType, power: 4, cost: 3, coverage: 150 }\r\n    ]\r\n\r\n    return this.createCardsFromDefinitions(basicInsuranceDefinitions, def => \r\n      this.createInsuranceCard({ ...def, ageBonus })\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 拡張保険カードを生成（簡素化版：すべて永続効果）\r\n   */\r\n  static createExtendedInsuranceCards(stage: GameStage = 'youth'): Card[] {\r\n    const extendedCards: Card[] = []\r\n    \r\n    // 年齢ボーナスの設定\r\n    const ageBonus = this.calculateAgeBonus(stage)\r\n    \r\n    // 基本保険カード\r\n    const baseInsurances = [\r\n      { name: '医療保険', insuranceType: 'medical' as InsuranceType, power: 5, cost: 4, coverage: 100 },\r\n      { name: '生命保険', insuranceType: 'life' as InsuranceType, power: 6, cost: 5, coverage: 200 },\r\n      { name: '収入保障保険', insuranceType: 'income' as InsuranceType, power: 5, cost: 4, coverage: 150 }\r\n    ]\r\n    \r\n    // 基本保険カードを追加\r\n    const baseCards = this.createCardsFromDefinitions(baseInsurances, insurance => \r\n      this.createInsuranceCard({\r\n        name: insurance.name,\r\n        description: `${insurance.name}の永続保障`,\r\n        insuranceType: insurance.insuranceType,\r\n        power: insurance.power,\r\n        cost: insurance.cost,\r\n        coverage: insurance.coverage,\r\n        ageBonus\r\n      })\r\n    )\r\n    extendedCards.push(...baseCards)\r\n\r\n    // 追加の特殊保険カード\r\n    const additionalInsurances = [\r\n      { name: '傷害保険', insuranceType: 'medical' as InsuranceType, power: 4, cost: 3, coverage: 80 },\r\n      { name: '就業不能保険', insuranceType: 'income' as InsuranceType, power: 7, cost: 6, coverage: 250 },\r\n      { name: '介護保険', insuranceType: 'medical' as InsuranceType, power: 6, cost: 5, coverage: 180 },\r\n      { name: 'がん保険', insuranceType: 'medical' as InsuranceType, power: 5, cost: 4, coverage: 120 },\r\n      { name: '個人年金保険', insuranceType: 'income' as InsuranceType, power: 4, cost: 4, coverage: 100 },\r\n      { name: '学資保険', insuranceType: 'life' as InsuranceType, power: 4, cost: 3, coverage: 90 }\r\n    ]\r\n    \r\n    // 追加保険カードを追加\r\n    const additionalCards = this.createCardsFromDefinitions(additionalInsurances, insurance => \r\n      this.createInsuranceCard({\r\n        name: insurance.name,\r\n        description: `${insurance.name}の永続保障`,\r\n        insuranceType: insurance.insuranceType,\r\n        power: insurance.power,\r\n        cost: insurance.cost,\r\n        coverage: insurance.coverage,\r\n        ageBonus\r\n      })\r\n    )\r\n    extendedCards.push(...additionalCards)\r\n\r\n    return extendedCards\r\n  }\r\n\r\n  /**\r\n   * 多様な効果タイプの保険カードを生成\r\n   */\r\n  static createDiverseInsuranceCards(stage: GameStage = 'youth'): Card[] {\r\n    const cards: Card[] = []\r\n    const ageBonus = this.calculateAgeBonus(stage)\r\n\r\n    // 攻撃型保険\r\n    cards.push(new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: '攻撃特化生命保険',\r\n      description: 'チャレンジ時に大きなパワーを提供',\r\n      power: 8,\r\n      cost: 5,\r\n      insuranceType: 'life',\r\n      insuranceEffectType: 'offensive',\r\n      coverage: 150,\r\n      effects: [],\r\n      ageBonus,\r\n      durationType: 'whole_life'\r\n    }))\r\n\r\n    // 防御型保険\r\n    cards.push(new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: '防御特化医療保険',\r\n      description: 'ダメージを軽減する防御的保障',\r\n      power: 0,\r\n      cost: 4,\r\n      insuranceType: 'medical',\r\n      insuranceEffectType: 'defensive',\r\n      coverage: 100,\r\n      effects: [{\r\n        type: 'damage_reduction',\r\n        value: 3,\r\n        description: 'ダメージを3ポイント軽減'\r\n      }],\r\n      ageBonus: 0,\r\n      durationType: 'whole_life'\r\n    }))\r\n\r\n    // 回復型保険\r\n    cards.push(new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: '回復特化健康保険',\r\n      description: '毎ターン活力を回復',\r\n      power: 0,\r\n      cost: 3,\r\n      insuranceType: 'health',\r\n      insuranceEffectType: 'recovery',\r\n      coverage: 80,\r\n      effects: [{\r\n        type: 'turn_heal',\r\n        value: 2,\r\n        description: '毎ターン終了時に2点回復'\r\n      }],\r\n      ageBonus: 0,\r\n      durationType: 'whole_life'\r\n    }))\r\n\r\n    // 特化型保険\r\n    cards.push(new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: '仕事特化収入保障保険',\r\n      description: '仕事関連のチャレンジに特化',\r\n      power: 3,\r\n      cost: 4,\r\n      insuranceType: 'income',\r\n      insuranceEffectType: 'specialized',\r\n      coverage: 120,\r\n      effects: [{\r\n        type: 'challenge_bonus',\r\n        value: 5,\r\n        description: '「就職」「明進」チャレンジ時+5パワー',\r\n        condition: '就職,明進,転職,仕事'\r\n      }],\r\n      ageBonus,\r\n      durationType: 'whole_life'\r\n    }))\r\n\r\n    // 包括型保険\r\n    cards.push(new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: 'オールインワン総合保険',\r\n      description: '複数の効果を持つ高コスト保障',\r\n      power: 3,\r\n      cost: 7,\r\n      insuranceType: 'life',\r\n      insuranceEffectType: 'comprehensive',\r\n      coverage: 200,\r\n      effects: [\r\n        {\r\n          type: 'power_boost',\r\n          value: 3,\r\n          description: 'パワー+3'\r\n        },\r\n        {\r\n          type: 'damage_reduction',\r\n          value: 2,\r\n          description: 'ダメージ-2'\r\n        },\r\n        {\r\n          type: 'turn_heal',\r\n          value: 1,\r\n          description: '毎ターン+1回復'\r\n        }\r\n      ],\r\n      ageBonus,\r\n      durationType: 'whole_life'\r\n    }))\r\n\r\n    return cards\r\n  }\r\n\r\n  /**\r\n   * 保険種類選択肢を生成（定期保険と終身保険の選択肢）\r\n   */\r\n  static createInsuranceTypeChoices(stage: GameStage = 'youth'): InsuranceTypeChoice[] {\r\n    const choices: InsuranceTypeChoice[] = []\r\n    \r\n    // 年齢ボーナスの設定\r\n    const ageBonus = this.calculateAgeBonus(stage)\r\n    \r\n    // 多様な保険タイプの定義（効果タイプ付き）\r\n    const baseInsuranceTypes = [\r\n      { \r\n        type: 'medical' as InsuranceType, \r\n        name: '医療保険', \r\n        description: '病気やケガに備える保障',\r\n        power: 5, \r\n        baseCost: 4, \r\n        coverage: 100,\r\n        effectType: 'offensive' as InsuranceEffectType\r\n      },\r\n      { \r\n        type: 'life' as InsuranceType, \r\n        name: '生命保険', \r\n        description: '家族を守る保障',\r\n        power: 6, \r\n        baseCost: 5, \r\n        coverage: 200,\r\n        effectType: 'offensive' as InsuranceEffectType\r\n      },\r\n      { \r\n        type: 'income' as InsuranceType, \r\n        name: '収入保障保険', \r\n        description: '働けなくなった時の保障',\r\n        power: 5, \r\n        baseCost: 4, \r\n        coverage: 150,\r\n        effectType: 'offensive' as InsuranceEffectType\r\n      },\r\n      {\r\n        type: 'health' as InsuranceType,\r\n        name: '防御型健康保険',\r\n        description: 'ダメージを軽減する防御的保障',\r\n        power: 0,\r\n        baseCost: 3,\r\n        coverage: 80,\r\n        effectType: 'defensive' as InsuranceEffectType\r\n      },\r\n      {\r\n        type: 'disability' as InsuranceType,\r\n        name: '回復型障害保険',\r\n        description: '定期的に活力を回復',\r\n        power: 0,\r\n        baseCost: 3,\r\n        coverage: 60,\r\n        effectType: 'recovery' as InsuranceEffectType\r\n      }\r\n    ]\r\n    \r\n    // 3つからランダムに選択（重複なし）\r\n    const availableTypes = [...baseInsuranceTypes]\r\n    for (let i = 0; i < 3 && availableTypes.length > 0; i++) {\r\n      const randomIndex = Math.floor(Math.random() * availableTypes.length)\r\n      const selectedType = availableTypes.splice(randomIndex, 1)[0]\r\n      \r\n      // 定期保険の期間設定（10ターン）\r\n      const termDuration = 10\r\n      \r\n      // 定期保険のコスト（基本コストの70%）\r\n      const termCost = Math.ceil(selectedType.baseCost * 0.7)\r\n      \r\n      // 終身保険のコスト（基本コスト）\r\n      const wholeLifeCost = selectedType.baseCost\r\n      \r\n      const choice: InsuranceTypeChoice = {\r\n        insuranceType: selectedType.type,\r\n        name: selectedType.name,\r\n        description: selectedType.description,\r\n        baseCard: {\r\n          name: selectedType.name,\r\n          description: selectedType.description,\r\n          type: 'insurance',\r\n          power: selectedType.power,\r\n          cost: selectedType.baseCost, // ベースコスト\r\n          insuranceType: selectedType.type,\r\n          coverage: selectedType.coverage,\r\n          insuranceEffectType: selectedType.effectType,\r\n          effects: [{\r\n            type: 'shield',\r\n            value: selectedType.coverage,\r\n            description: `${selectedType.coverage}ポイントの保障`\r\n          }],\r\n          ageBonus\r\n        },\r\n        termOption: {\r\n          cost: termCost,\r\n          duration: termDuration,\r\n          description: `${termDuration}ターン限定の保障（低コスト）`\r\n        },\r\n        wholeLifeOption: {\r\n          cost: wholeLifeCost,\r\n          description: '生涯にわたる永続保障（高コスト）'\r\n        }\r\n      }\r\n      \r\n      choices.push(choice)\r\n    }\r\n    \r\n    return choices\r\n  }\r\n\r\n  /**\r\n   * 定期保険カードを作成\r\n   */\r\n  static createTermInsuranceCard(choice: InsuranceTypeChoice): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: `定期${choice.name}`,\r\n      description: `${choice.baseCard.description}（${choice.termOption.duration}ターン限定）`,\r\n      power: choice.baseCard.power,\r\n      cost: choice.termOption.cost,\r\n      insuranceType: choice.insuranceType,\r\n      coverage: choice.baseCard.coverage,\r\n      effects: choice.baseCard.effects,\r\n      ageBonus: choice.baseCard.ageBonus,\r\n      insuranceEffectType: choice.baseCard.insuranceEffectType,\r\n      durationType: 'term',\r\n      remainingTurns: choice.termOption.duration\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 終身保険カードを作成\r\n   */\r\n  static createWholeLifeInsuranceCard(choice: InsuranceTypeChoice): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: `終身${choice.name}`,\r\n      description: `${choice.baseCard.description}（永続保障）`,\r\n      power: choice.baseCard.power,\r\n      cost: choice.wholeLifeOption.cost,\r\n      insuranceType: choice.insuranceType,\r\n      coverage: choice.baseCard.coverage,\r\n      effects: choice.baseCard.effects,\r\n      ageBonus: choice.baseCard.ageBonus,\r\n      insuranceEffectType: choice.baseCard.insuranceEffectType,\r\n      durationType: 'whole_life'\r\n    })\r\n  }\r\n\r\n  /**\r\n   * チャレンジカードを生成\r\n   */\r\n  static createChallengeCards(stage: GameStage): Card[] {\r\n    const challengeDefinitionsByStage = {\r\n      youth: [\r\n        // 基本チャレンジ（難易度: 低）\r\n        { name: 'アルバイト探し', description: '初めての収入を得る', power: 3, dreamCategory: 'physical' as DreamCategory },\r\n        { name: '一人暮らし', description: '独立への第一歩', power: 4, dreamCategory: 'physical' as DreamCategory },\r\n        { name: '資格試験', description: 'スキルアップのチャンス', power: 5, dreamCategory: 'intellectual' as DreamCategory },\r\n        { name: '就職活動', description: '新たなキャリアの始まり', power: 6, dreamCategory: 'physical' as DreamCategory },\r\n        // 中級チャレンジ\r\n        { name: '恋人との別れ', description: '初めての大きな失意', power: 5, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '転職活動', description: 'キャリアの分岐点', power: 6, dreamCategory: 'intellectual' as DreamCategory }\r\n      ],\r\n      middle: [\r\n        // 基本チャレンジ（難易度: 中）\r\n        { name: '結婚資金', description: '新しい家族のスタート', power: 6, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '子育て', description: '家族の成長', power: 7, dreamCategory: 'physical' as DreamCategory },\r\n        { name: '両親の健康', description: '家族の支え合い', power: 8, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '住宅購入', description: '大きな決断', power: 9, dreamCategory: 'physical' as DreamCategory },\r\n        // 高難度チャレンジ\r\n        { name: '親の介護', description: '家族の責任', power: 10, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '教育資金', description: '子供の将来への投資', power: 8, dreamCategory: 'intellectual' as DreamCategory }\r\n      ],\r\n      fulfillment: [\r\n        // 基本チャレンジ（難易度: 高）\r\n        { name: '健康管理', description: '健やかな老後のために', power: 8, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '趣味の充実', description: '人生の新たな楽しみ', power: 9, dreamCategory: 'intellectual' as DreamCategory },\r\n        { name: '社会貢献', description: '経験を活かした活動', power: 10, dreamCategory: 'mixed' as DreamCategory },\r\n        { name: '定年退職', description: '新しい人生のスタート', power: 11, dreamCategory: 'intellectual' as DreamCategory },\r\n        // 最高難度チャレンジ\r\n        { name: '遺産相続', description: '家族への最後の贈り物', power: 12, dreamCategory: 'intellectual' as DreamCategory },\r\n        { name: '健康上の大きな試練', description: '人生最大の挑戦', power: 13, dreamCategory: 'physical' as DreamCategory }\r\n      ]\r\n    }\r\n\r\n    const definitions = challengeDefinitionsByStage[stage] || challengeDefinitionsByStage.fulfillment\r\n    \r\n    // ステージごとに適切な難易度のチャレンジを選択\r\n    // ランダムに3-4枚選ぶが、難易度のバランスを考慮\r\n    const shuffled = [...definitions].sort(() => Math.random() - 0.5)\r\n    const selectedCount = 3 + Math.floor(Math.random() * 2) // 3-4枚\r\n    const selected = shuffled.slice(0, selectedCount)\r\n    \r\n    const normalChallenges = this.createCardsFromDefinitions(selected, def => this.createChallengeCard(def))\r\n    \r\n    // リスク・リワードチャレンジを追加（20%の確率）\r\n    const riskChallenges = this.createRiskRewardChallenges(stage)\r\n    \r\n    return [...normalChallenges, ...riskChallenges]\r\n  }\r\n\r\n  /**\r\n   * リスク・リワードチャレンジを生成\r\n   */\r\n  static createRiskRewardChallenges(stage: GameStage): Card[] {\r\n    const challenges: Card[] = []\r\n    \r\n    // ステージに応じたリスクレベルの分布\r\n    const riskDistribution = {\r\n      youth: { low: 0.5, medium: 0.3, high: 0.15, extreme: 0.05 },\r\n      middle: { low: 0.3, medium: 0.4, high: 0.2, extreme: 0.1 },\r\n      fulfillment: { low: 0.2, medium: 0.3, high: 0.3, extreme: 0.2 }\r\n    }\r\n    \r\n    const distribution = riskDistribution[stage as 'youth' | 'middle' | 'fulfillment'] || riskDistribution.youth\r\n    \r\n    // 各リスクレベルのチャレンジを生成（確率に基づく）\r\n    const random = Math.random()\r\n    \r\n    if (random < 0.2) { // 20%の確率でリスクチャレンジを追加\r\n      let riskLevel: 'low' | 'medium' | 'high' | 'extreme'\r\n      const levelRandom = Math.random()\r\n      \r\n      if (levelRandom < distribution.low) {\r\n        riskLevel = 'low'\r\n      } else if (levelRandom < distribution.low + distribution.medium) {\r\n        riskLevel = 'medium'\r\n      } else if (levelRandom < distribution.low + distribution.medium + distribution.high) {\r\n        riskLevel = 'high'\r\n      } else {\r\n        riskLevel = 'extreme'\r\n      }\r\n      \r\n      const riskChallenge = RiskRewardChallenge.createRiskChallenge(\r\n        stage as 'youth' | 'middle' | 'fulfillment',\r\n        riskLevel\r\n      )\r\n      \r\n      challenges.push(riskChallenge)\r\n    }\r\n    \r\n    return challenges\r\n  }\r\n\r\n  /**\r\n   * 落とし穴カードを生成\r\n   */\r\n  static createPitfallCards(): Card[] {\r\n    const pitfallDefinitions = [\r\n      { name: '急な入院', description: '予期せぬ医療費', power: 0, penalty: 3 },\r\n      { name: '失業', description: '収入の途絶', power: 0, penalty: 4 },\r\n      { name: '事故', description: '予期せぬトラブル', power: 0, penalty: 2 }\r\n    ]\r\n\r\n    return this.createCardsFromDefinitions(pitfallDefinitions, def => this.createPitfallCard(def))\r\n  }\r\n\r\n  /**\r\n   * 人生カードを作成（テスト用にpublicインスタンスメソッドも追加）\r\n   */\r\n  createLifeCard(params: {\r\n    category: LifeCardCategory\r\n    basePower: number\r\n    baseCost: number\r\n  }): Card {\r\n    return CardFactory.createLifeCard({\r\n      name: `テスト${params.category}カード`,\r\n      description: `${params.category}のテストカード`,\r\n      category: params.category,\r\n      power: params.basePower,\r\n      cost: params.baseCost\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 人生カードを作成（静的メソッド）\r\n   */\r\n  private static createLifeCard(params: {\r\n    name: string\r\n    description: string\r\n    category: LifeCardCategory\r\n    power: number\r\n    cost: number\r\n  }): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'life',\r\n      name: params.name,\r\n      description: params.description,\r\n      power: params.power,\r\n      cost: params.cost,\r\n      category: params.category,\r\n      effects: []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 保険カードを作成（Phase 2対応）\r\n   */\r\n  private static createInsuranceCard(params: {\r\n    name: string\r\n    description: string\r\n    insuranceType: InsuranceType\r\n    power: number\r\n    cost: number\r\n    coverage: number\r\n    ageBonus?: number\r\n  }): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'insurance',\r\n      name: params.name,\r\n      description: params.description,\r\n      power: params.power,\r\n      cost: params.cost,\r\n      insuranceType: params.insuranceType,\r\n      coverage: params.coverage,\r\n      effects: [{\r\n        type: 'shield',\r\n        value: params.coverage,\r\n        description: `${params.coverage}ポイントの保障`\r\n      }],\r\n      ageBonus: params.ageBonus || 0\r\n    })\r\n  }\r\n\r\n  /**\r\n   * チャレンジカードを作成\r\n   */\r\n  private static createChallengeCard(params: {\r\n    name: string\r\n    description: string\r\n    power: number\r\n    dreamCategory?: DreamCategory\r\n  }): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: params.dreamCategory ? 'dream' : 'challenge', // 夢カテゴリがある場合はdreamタイプ\r\n      name: params.name,\r\n      description: params.description,\r\n      power: params.power,\r\n      cost: 0,\r\n      effects: [],\r\n      dreamCategory: params.dreamCategory\r\n    })\r\n  }\r\n\r\n  /**\r\n   * 落とし穴カードを作成\r\n   */\r\n  private static createPitfallCard(params: {\r\n    name: string\r\n    description: string\r\n    power: number\r\n    penalty: number\r\n  }): Card {\r\n    return new Card({\r\n      id: IdGenerator.generateCardId(),\r\n      type: 'pitfall',\r\n      name: params.name,\r\n      description: params.description,\r\n      power: params.power,\r\n      cost: 0,\r\n      penalty: params.penalty,\r\n      effects: []\r\n    })\r\n  }\r\n\r\n  /**\r\n   * スキルカードを生成\r\n   */\r\n  static createSkillCards(stage: GameStage = 'youth'): Card[] {\r\n    const skillDefinitionsByStage = {\r\n      youth: [\r\n        { name: '集中力', description: '集中して取り組む能力', rarity: 'common' as SkillRarity, power: 3, cooldown: 0 },\r\n        { name: 'コミュニケーション', description: '人との関わりを深める', rarity: 'common' as SkillRarity, power: 4, cooldown: 1 },\r\n        { name: 'リーダーシップ', description: 'チームを率いる力', rarity: 'rare' as SkillRarity, power: 6, cooldown: 2 },\r\n        { name: '創造性', description: '新しいアイデアを生み出す', rarity: 'epic' as SkillRarity, power: 8, cooldown: 3 }\r\n      ],\r\n      middle: [\r\n        { name: '戦略的思考', description: '長期的な視点で考える', rarity: 'rare' as SkillRarity, power: 7, cooldown: 2 },\r\n        { name: 'メンタリング', description: '後輩を指導する能力', rarity: 'rare' as SkillRarity, power: 6, cooldown: 1 },\r\n        { name: '危機管理', description: 'リスクを予測し対処する', rarity: 'epic' as SkillRarity, power: 9, cooldown: 3 },\r\n        { name: 'イノベーション', description: '革新的な変化を起こす', rarity: 'legendary' as SkillRarity, power: 12, cooldown: 4 }\r\n      ],\r\n      fulfillment: [\r\n        { name: '人生の知恵', description: '経験から得た深い洞察', rarity: 'epic' as SkillRarity, power: 10, cooldown: 2 },\r\n        { name: 'レガシー構築', description: '次世代への価値ある遺産', rarity: 'legendary' as SkillRarity, power: 15, cooldown: 5 },\r\n        { name: '精神的平和', description: '内なる調和と安定', rarity: 'legendary' as SkillRarity, power: 13, cooldown: 3 }\r\n      ]\r\n    }\r\n\r\n    const definitions = skillDefinitionsByStage[stage] || skillDefinitionsByStage.youth\r\n    return this.createCardsFromDefinitions(definitions, def => \r\n      Card.createSkillCard(def.name, def.rarity, def.power, def.cooldown)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * コンボカードを生成\r\n   */\r\n  static createComboCards(): Card[] {\r\n    const comboDefinitions = [\r\n      { \r\n        name: 'ワークライフバランス', \r\n        power: 2, \r\n        requiredCards: ['career', 'family'], \r\n        comboBonus: 4,\r\n        description: 'キャリアと家族の調和' \r\n      },\r\n      { \r\n        name: '健康的な成功', \r\n        power: 3, \r\n        requiredCards: ['health', 'finance'], \r\n        comboBonus: 5,\r\n        description: '健康と経済的安定の両立' \r\n      },\r\n      { \r\n        name: '充実した人生', \r\n        power: 4, \r\n        requiredCards: ['hobby', 'family', 'career'], \r\n        comboBonus: 8,\r\n        description: '趣味・家族・キャリアの三位一体' \r\n      }\r\n    ]\r\n\r\n    return this.createCardsFromDefinitions(comboDefinitions, def => \r\n      Card.createComboCard(def.name, def.power, def.requiredCards, def.comboBonus)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * イベントカードを生成\r\n   */\r\n  static createEventCards(stage: GameStage = 'youth'): Card[] {\r\n    const eventDefinitionsByStage = {\r\n      youth: [\r\n        { name: '新年の抱負', description: '新しい年への決意', power: 5, duration: 3, globalEffect: false },\r\n        { name: '就職ブーム', description: '雇用機会の増加', power: 4, duration: 2, globalEffect: true },\r\n        { name: '健康ブーム', description: '健康への意識向上', power: 3, duration: 4, globalEffect: true }\r\n      ],\r\n      middle: [\r\n        { name: '経済成長期', description: '社会全体の活況', power: 6, duration: 3, globalEffect: true },\r\n        { name: '家族の絆', description: '家族関係の深化', power: 7, duration: 2, globalEffect: false },\r\n        { name: '技術革新', description: 'テクノロジーの進歩', power: 8, duration: 4, globalEffect: true }\r\n      ],\r\n      fulfillment: [\r\n        { name: '人生の総決算', description: '経験の統合と成熟', power: 10, duration: 2, globalEffect: false },\r\n        { name: '世代交代', description: '次世代への継承', power: 9, duration: 3, globalEffect: true }\r\n      ]\r\n    }\r\n\r\n    const definitions = eventDefinitionsByStage[stage] || eventDefinitionsByStage.youth\r\n    return this.createCardsFromDefinitions(definitions, def => \r\n      Card.createEventCard(def.name, def.power, def.duration, def.globalEffect)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * レジェンダリーカードを生成（アンロック制）\r\n   */\r\n  static createLegendaryCards(): Card[] {\r\n    const legendaryDefinitions = [\r\n      { \r\n        name: '人生の達人', \r\n        power: 20, \r\n        unlockCondition: '全ステージで50回以上成功',\r\n        description: '人生経験の集大成'\r\n      },\r\n      { \r\n        name: '運命を変える決断', \r\n        power: 25, \r\n        unlockCondition: '連続10回チャレンジ成功',\r\n        description: '人生を劇的に変える瞬間'\r\n      },\r\n      { \r\n        name: '完璧な調和', \r\n        power: 30, \r\n        unlockCondition: '全カテゴリのカードを50枚以上獲得',\r\n        description: 'すべての側面が完璧にバランスした状態'\r\n      }\r\n    ]\r\n\r\n    return this.createCardsFromDefinitions(legendaryDefinitions, def => \r\n      Card.createLegendaryCard(def.name, def.power, def.unlockCondition)\r\n    )\r\n  }\r\n}","import type { Card } from '../entities/Card'\r\nimport { Deck } from '../entities/Deck'\r\nimport type { GameConfig } from '../types/game.types'\r\n\r\n/**\r\n * カード管理の状態\r\n */\r\nexport interface CardManagerState {\r\n  hand: Card[]\r\n  discardPile: Card[]\r\n  playerDeck: Deck\r\n  challengeDeck: Deck\r\n  selectedCards: Card[]\r\n  cardChoices?: Card[]\r\n}\r\n\r\n/**\r\n * カードドロー結果\r\n */\r\nexport interface DrawResult {\r\n  drawnCards: Card[]\r\n  discardedCards: Card[] // 手札上限により捨てられたカード\r\n}\r\n\r\n/**\r\n * CardManagerのインターフェース\r\n */\r\nexport interface ICardManager {\r\n  /**\r\n   * カード管理状態を初期化\r\n   */\r\n  initialize(playerDeck: Deck, challengeDeck: Deck, config: GameConfig): void\r\n\r\n  /**\r\n   * 現在の状態を取得\r\n   */\r\n  getState(): CardManagerState\r\n\r\n  /**\r\n   * 状態を復元\r\n   */\r\n  setState(state: CardManagerState): void\r\n\r\n  /**\r\n   * 指定した枚数のカードをドロー\r\n   */\r\n  drawCards(count: number): DrawResult\r\n\r\n  /**\r\n   * カードを選択/選択解除\r\n   */\r\n  toggleCardSelection(card: Card): boolean\r\n\r\n  /**\r\n   * 選択中のカードをクリア\r\n   */\r\n  clearSelection(): void\r\n\r\n  /**\r\n   * 選択されたカードを手札から捨て札に移動\r\n   */\r\n  discardSelectedCards(): Card[]\r\n\r\n  /**\r\n   * カードを手札に追加\r\n   */\r\n  addToHand(card: Card): void\r\n\r\n  /**\r\n   * カードを捨て札に追加\r\n   */\r\n  addToDiscardPile(card: Card): void\r\n\r\n  /**\r\n   * カードをプレイヤーデッキに追加\r\n   */\r\n  addToPlayerDeck(card: Card): void\r\n\r\n  /**\r\n   * 手札上限チェックと調整\r\n   */\r\n  enforceHandLimit(): Card[]\r\n\r\n  /**\r\n   * カード選択肢を設定\r\n   */\r\n  setCardChoices(choices: Card[]): void\r\n\r\n  /**\r\n   * カード選択肢をクリア\r\n   */\r\n  clearCardChoices(): void\r\n\r\n  /**\r\n   * 指定IDのカードを選択肢から取得\r\n   */\r\n  getCardChoiceById(cardId: string): Card | undefined\r\n}\r\n\r\n/**\r\n * カード管理サービス（最適化版）\r\n */\r\nexport class CardManager implements ICardManager {\r\n  private hand: Card[] = []\r\n  private discardPile: Card[] = []\r\n  private playerDeck: Deck = new Deck('Player Deck')\r\n  private challengeDeck: Deck = new Deck('Challenge Deck')\r\n  private selectedCards: Card[] = []\r\n  private cardChoices?: Card[]\r\n  private config?: GameConfig\r\n\r\n  // パフォーマンス最適化: オブジェクトプール\r\n  private static readonly CARD_POOLS = {\r\n    drawResults: [] as DrawResult[],\r\n    selectedIds: new Set<string>() // IDベースの選択状態管理\r\n  }\r\n\r\n  // キャッシュ\r\n  private _cachedState?: CardManagerState\r\n  private _stateVersion = 0\r\n\r\n  /**\r\n   * カード管理状態を初期化\r\n   */\r\n  initialize(playerDeck: Deck, challengeDeck: Deck, config: GameConfig): void {\r\n    this.playerDeck = playerDeck\r\n    this.challengeDeck = challengeDeck\r\n    this.hand = []\r\n    this.discardPile = []\r\n    this.selectedCards = []\r\n    this.cardChoices = undefined\r\n    this.config = config\r\n  }\r\n\r\n  /**\r\n   * 現在の状態を取得（キャッシュ最適化版）\r\n   */\r\n  getState(): CardManagerState {\r\n    // キャッシュが有効な場合はそれを返す\r\n    if (this._cachedState && this._stateVersion > 0) {\r\n      return this._cachedState\r\n    }\r\n\r\n    // 新しい状態を作成\r\n    const state: CardManagerState = {\r\n      hand: [...this.hand],\r\n      discardPile: [...this.discardPile],\r\n      playerDeck: this.playerDeck.clone(),\r\n      challengeDeck: this.challengeDeck.clone(),\r\n      selectedCards: [...this.selectedCards],\r\n      cardChoices: this.cardChoices ? [...this.cardChoices] : undefined\r\n    }\r\n\r\n    // キャッシュに保存\r\n    this._cachedState = state\r\n    this._stateVersion++\r\n\r\n    return state\r\n  }\r\n\r\n  /**\r\n   * 状態を復元\r\n   */\r\n  setState(state: CardManagerState): void {\r\n    this.hand = [...state.hand]\r\n    this.discardPile = [...state.discardPile]\r\n    this.playerDeck = state.playerDeck.clone()\r\n    this.challengeDeck = state.challengeDeck.clone()\r\n    this.selectedCards = [...state.selectedCards]\r\n    this.cardChoices = state.cardChoices ? [...state.cardChoices] : undefined\r\n    \r\n    // キャッシュを無効化\r\n    this.invalidateCache()\r\n  }\r\n\r\n  /**\r\n   * キャッシュを無効化\r\n   */\r\n  private invalidateCache(): void {\r\n    this._cachedState = undefined\r\n    this._stateVersion = 0\r\n  }\r\n\r\n  /**\r\n   * 指定した枚数のカードをドロー（最適化版）\r\n   */\r\n  drawCards(count: number): DrawResult {\r\n    if (!this.config) {\r\n      throw new Error('CardManager not initialized')\r\n    }\r\n\r\n    // オブジェクトプールからDrawResultを取得\r\n    let result = CardManager.CARD_POOLS.drawResults.pop()\r\n    if (!result) {\r\n      result = { drawnCards: [], discardedCards: [] }\r\n    } else {\r\n      // 配列をクリア\r\n      result.drawnCards.length = 0\r\n      result.discardedCards.length = 0\r\n    }\r\n\r\n    for (let i = 0; i < count; i++) {\r\n      // デッキが空の場合、捨て札をシャッフルして山札に戻す\r\n      if (this.playerDeck.isEmpty() && this.discardPile.length > 0) {\r\n        this.reshuffleDeck()\r\n      }\r\n      \r\n      const card = this.playerDeck.drawCard()\r\n      if (card) {\r\n        result.drawnCards.push(card)\r\n        this.hand.push(card)\r\n      }\r\n    }\r\n    \r\n    // 手札上限チェック\r\n    const discardedCards = this.enforceHandLimit()\r\n    result.discardedCards.push(...discardedCards)\r\n    \r\n    // キャッシュを無効化\r\n    this.invalidateCache()\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * カードを選択/選択解除（最適化版）\r\n   */\r\n  toggleCardSelection(card: Card): boolean {\r\n    const cardId = card.id\r\n    \r\n    // SetベースのIDチェックで高速化\r\n    if (CardManager.CARD_POOLS.selectedIds.has(cardId)) {\r\n      // 選択解除\r\n      CardManager.CARD_POOLS.selectedIds.delete(cardId)\r\n      const index = this.selectedCards.findIndex(c => c.id === cardId)\r\n      if (index !== -1) {\r\n        this.selectedCards.splice(index, 1)\r\n      }\r\n      this.invalidateCache()\r\n      return false // 選択解除\r\n    } else {\r\n      // 選択\r\n      CardManager.CARD_POOLS.selectedIds.add(cardId)\r\n      this.selectedCards.push(card)\r\n      this.invalidateCache()\r\n      return true // 選択\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 選択中のカードをクリア（最適化版）\r\n   */\r\n  clearSelection(): void {\r\n    this.selectedCards.length = 0\r\n    CardManager.CARD_POOLS.selectedIds.clear()\r\n    this.invalidateCache()\r\n  }\r\n\r\n  /**\r\n   * 選択されたカードを手札から捨て札に移動\r\n   */\r\n  discardSelectedCards(): Card[] {\r\n    const discardedCards: Card[] = []\r\n    \r\n    this.selectedCards.forEach(card => {\r\n      const index = this.hand.findIndex(c => c.id === card.id)\r\n      if (index !== -1) {\r\n        const removedCard = this.hand.splice(index, 1)[0]\r\n        this.discardPile.push(removedCard)\r\n        discardedCards.push(removedCard)\r\n      }\r\n    })\r\n    \r\n    this.selectedCards = []\r\n    return discardedCards\r\n  }\r\n\r\n  /**\r\n   * カードを手札に追加\r\n   */\r\n  addToHand(card: Card): void {\r\n    this.hand.push(card)\r\n    this.invalidateCache()\r\n  }\r\n\r\n  /**\r\n   * カードを捨て札に追加\r\n   */\r\n  addToDiscardPile(card: Card): void {\r\n    this.discardPile.push(card)\r\n    this.invalidateCache()\r\n  }\r\n\r\n  /**\r\n   * カードをプレイヤーデッキに追加\r\n   */\r\n  addToPlayerDeck(card: Card): void {\r\n    this.playerDeck.addCard(card)\r\n    this.invalidateCache()\r\n  }\r\n\r\n  /**\r\n   * 手札上限チェックと調整\r\n   */\r\n  enforceHandLimit(): Card[] {\r\n    if (!this.config) {\r\n      return []\r\n    }\r\n\r\n    const discardedCards: Card[] = []\r\n    \r\n    // 手札上限チェック - 古いカードを捨て札に\r\n    while (this.hand.length > this.config.maxHandSize) {\r\n      const discarded = this.hand.shift()\r\n      if (discarded) {\r\n        this.discardPile.push(discarded)\r\n        discardedCards.push(discarded)\r\n      }\r\n    }\r\n    \r\n    return discardedCards\r\n  }\r\n\r\n  /**\r\n   * カード選択肢を設定\r\n   */\r\n  setCardChoices(choices: Card[]): void {\r\n    this.cardChoices = [...choices]\r\n  }\r\n\r\n  /**\r\n   * カード選択肢をクリア\r\n   */\r\n  clearCardChoices(): void {\r\n    this.cardChoices = undefined\r\n  }\r\n\r\n  /**\r\n   * 指定IDのカードを選択肢から取得\r\n   */\r\n  getCardChoiceById(cardId: string): Card | undefined {\r\n    return this.cardChoices?.find(card => card.id === cardId)\r\n  }\r\n\r\n  /**\r\n   * 捨て札をシャッフルして山札に戻す\r\n   */\r\n  private reshuffleDeck(): void {\r\n    this.playerDeck.addCards(this.discardPile)\r\n    this.playerDeck.shuffle()\r\n    this.discardPile = []\r\n  }\r\n}","/**\n * リスクファクター値オブジェクト\n * \n * 保険料計算に使用されるリスク要因を表現する値オブジェクト。\n * 各要因は0.0〜1.0の範囲で表現され、高いほどリスクが高いことを示す。\n */\nexport class RiskFactor {\n  private constructor(\n    private readonly value: number,\n    private readonly factorType: RiskFactorType\n  ) {}\n\n  /**\n   * リスクファクターを作成\n   * @param value リスク値（0.0-1.0）\n   * @param factorType リスクの種類\n   * @returns RiskFactorインスタンス\n   * @throws {Error} 値が範囲外の場合\n   */\n  static create(value: number, factorType: RiskFactorType): RiskFactor {\n    if (value < 0 || value > 1) {\n      throw new Error(`Risk factor value must be between 0 and 1, got ${value}`)\n    }\n    return new RiskFactor(value, factorType)\n  }\n\n  /**\n   * リスク値を取得\n   */\n  getValue(): number {\n    return this.value\n  }\n\n  /**\n   * リスクタイプを取得\n   */\n  getType(): RiskFactorType {\n    return this.factorType\n  }\n\n  /**\n   * リスクレベルを取得（低・中・高）\n   */\n  getRiskLevel(): RiskLevel {\n    if (this.value <= 0.3) return 'low'\n    if (this.value <= 0.7) return 'medium'\n    return 'high'\n  }\n\n  /**\n   * 保険料への影響倍率を計算\n   * @returns 保険料倍率（1.0が基準）\n   */\n  getPremiumMultiplier(): number {\n    // リスクタイプごとに異なる影響度\n    const impactFactors: Record<RiskFactorType, number> = {\n      age: 0.5,         // 年齢は50%の影響\n      health: 0.3,      // 健康状態は30%の影響\n      claims: 0.4,      // 請求履歴は40%の影響\n      lifestyle: 0.2    // ライフスタイルは20%の影響\n    }\n\n    const impact = impactFactors[this.factorType] || 0.3\n    // 基準1.0に対して、リスク値に応じて倍率を調整\n    return 1.0 + (this.value * impact)\n  }\n\n  /**\n   * リスクを調整（イベントによる変動）\n   * @param adjustment 調整値（-1.0〜1.0）\n   * @returns 新しいRiskFactorインスタンス\n   */\n  adjust(adjustment: number): RiskFactor {\n    const newValue = Math.max(0, Math.min(1, this.value + adjustment))\n    return new RiskFactor(newValue, this.factorType)\n  }\n\n  /**\n   * 他のリスクファクターと結合\n   * @param other 他のリスクファクター\n   * @param weight 結合時の重み（0.0-1.0）\n   * @returns 新しいRiskFactorインスタンス\n   */\n  combine(other: RiskFactor, weight: number = 0.5): RiskFactor {\n    if (this.factorType !== other.factorType) {\n      throw new Error('Cannot combine different risk factor types')\n    }\n    \n    const combinedValue = this.value * (1 - weight) + other.value * weight\n    return new RiskFactor(combinedValue, this.factorType)\n  }\n\n  /**\n   * 等価性の確認\n   */\n  equals(other: RiskFactor): boolean {\n    return this.value === other.value && this.factorType === other.factorType\n  }\n\n  /**\n   * 文字列表現\n   */\n  toString(): string {\n    return `RiskFactor(${this.factorType}: ${this.value.toFixed(2)} - ${this.getRiskLevel()})`\n  }\n}\n\n/**\n * リスクファクターの種類\n */\nexport type RiskFactorType = 'age' | 'health' | 'claims' | 'lifestyle'\n\n/**\n * リスクレベル\n */\nexport type RiskLevel = 'low' | 'medium' | 'high'\n\n/**\n * リスクプロファイル - 複数のリスクファクターの集合\n */\nexport class RiskProfile {\n  private constructor(\n    private readonly factors: Map<RiskFactorType, RiskFactor>\n  ) {}\n\n  /**\n   * 空のリスクプロファイルを作成\n   */\n  static empty(): RiskProfile {\n    return new RiskProfile(new Map())\n  }\n\n  /**\n   * デフォルトのリスクプロファイルを作成\n   */\n  static default(): RiskProfile {\n    const factors = new Map<RiskFactorType, RiskFactor>()\n    factors.set('age', RiskFactor.create(0.3, 'age'))\n    factors.set('health', RiskFactor.create(0.2, 'health'))\n    factors.set('claims', RiskFactor.create(0.0, 'claims'))\n    factors.set('lifestyle', RiskFactor.create(0.3, 'lifestyle'))\n    return new RiskProfile(factors)\n  }\n\n  /**\n   * リスクファクターを追加/更新\n   */\n  withFactor(factor: RiskFactor): RiskProfile {\n    const newFactors = new Map(this.factors)\n    newFactors.set(factor.getType(), factor)\n    return new RiskProfile(newFactors)\n  }\n\n  /**\n   * 特定のリスクファクターを取得\n   */\n  getFactor(type: RiskFactorType): RiskFactor | undefined {\n    return this.factors.get(type)\n  }\n\n  /**\n   * 全体のリスクスコアを計算（0.0-1.0）\n   */\n  getOverallRiskScore(): number {\n    if (this.factors.size === 0) return 0\n\n    let totalScore = 0\n    this.factors.forEach(factor => {\n      totalScore += factor.getValue()\n    })\n    \n    return totalScore / this.factors.size\n  }\n\n  /**\n   * 保険料への総合的な影響倍率を計算\n   */\n  getTotalPremiumMultiplier(): number {\n    if (this.factors.size === 0) return 1.0\n\n    let multiplier = 1.0\n    this.factors.forEach(factor => {\n      // 各ファクターの倍率を乗算的に適用\n      multiplier *= factor.getPremiumMultiplier()\n    })\n    \n    return multiplier\n  }\n\n  /**\n   * リスクプロファイルの要約を取得\n   */\n  getSummary(): string {\n    const overallScore = this.getOverallRiskScore()\n    const level = overallScore <= 0.3 ? '低リスク' : \n                  overallScore <= 0.7 ? '中リスク' : '高リスク'\n    \n    return `${level} (スコア: ${overallScore.toFixed(2)})`\n  }\n}","/**\r\n * リスクプロファイル値オブジェクト\r\n * \r\n * プレイヤーのリスク特性を表現する値オブジェクト。\r\n * 保険料計算やゲーム難易度調整に使用される。\r\n */\r\nexport class RiskProfile {\r\n  private constructor(\r\n    private readonly healthRisk: number,\r\n    private readonly financialRisk: number,\r\n    private readonly behavioralRisk: number\r\n  ) {}\r\n\r\n  /**\r\n   * デフォルトのリスクプロファイルを作成\r\n   */\r\n  static default(): RiskProfile {\r\n    return new RiskProfile(0.5, 0.5, 0.5)\r\n  }\r\n\r\n  /**\r\n   * カスタムリスクプロファイルを作成\r\n   * @param healthRisk 健康リスク（0.0-1.0）\r\n   * @param financialRisk 財務リスク（0.0-1.0）\r\n   * @param behavioralRisk 行動リスク（0.0-1.0）\r\n   * @returns RiskProfileインスタンス\r\n   * @throws {Error} 値が範囲外の場合\r\n   */\r\n  static create(\r\n    healthRisk: number,\r\n    financialRisk: number,\r\n    behavioralRisk: number\r\n  ): RiskProfile {\r\n    const validateRisk = (value: number, name: string) => {\r\n      if (value < 0 || value > 1) {\r\n        throw new Error(`${name} must be between 0 and 1, got ${value}`)\r\n      }\r\n    }\r\n\r\n    validateRisk(healthRisk, 'Health risk')\r\n    validateRisk(financialRisk, 'Financial risk')\r\n    validateRisk(behavioralRisk, 'Behavioral risk')\r\n\r\n    return new RiskProfile(healthRisk, financialRisk, behavioralRisk)\r\n  }\r\n\r\n  /**\r\n   * 健康リスクを取得\r\n   */\r\n  getHealthRisk(): number {\r\n    return this.healthRisk\r\n  }\r\n\r\n  /**\r\n   * 財務リスクを取得\r\n   */\r\n  getFinancialRisk(): number {\r\n    return this.financialRisk\r\n  }\r\n\r\n  /**\r\n   * 行動リスクを取得\r\n   */\r\n  getBehavioralRisk(): number {\r\n    return this.behavioralRisk\r\n  }\r\n\r\n  /**\r\n   * 総合リスクスコアを計算\r\n   * @returns 0.0-1.0の範囲の総合リスクスコア\r\n   */\r\n  getOverallRisk(): number {\r\n    return (this.healthRisk + this.financialRisk + this.behavioralRisk) / 3\r\n  }\r\n\r\n  /**\r\n   * リスクレベルを取得\r\n   * @returns 'low' | 'medium' | 'high'\r\n   */\r\n  getRiskLevel(): 'low' | 'medium' | 'high' {\r\n    const overall = this.getOverallRisk()\r\n    if (overall <= 0.3) return 'low'\r\n    if (overall <= 0.7) return 'medium'\r\n    return 'high'\r\n  }\r\n\r\n  /**\r\n   * プレイヤーの行動に基づいてリスクプロファイルを更新\r\n   * @param healthChange 健康リスクの変化量\r\n   * @param financialChange 財務リスクの変化量\r\n   * @param behavioralChange 行動リスクの変化量\r\n   * @returns 新しいRiskProfileインスタンス\r\n   */\r\n  updateRisks(\r\n    healthChange: number = 0,\r\n    financialChange: number = 0,\r\n    behavioralChange: number = 0\r\n  ): RiskProfile {\r\n    const clamp = (value: number): number => Math.max(0, Math.min(1, value))\r\n\r\n    return new RiskProfile(\r\n      clamp(this.healthRisk + healthChange),\r\n      clamp(this.financialRisk + financialChange),\r\n      clamp(this.behavioralRisk + behavioralChange)\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 保険料係数を計算\r\n   * @returns 保険料計算に使用する係数（0.5-2.0）\r\n   */\r\n  getPremiumMultiplier(): number {\r\n    const overall = this.getOverallRisk()\r\n    // リスクが低い場合は0.5倍、高い場合は2.0倍\r\n    return 0.5 + (overall * 1.5)\r\n  }\r\n\r\n  /**\r\n   * デバッグ用の文字列表現\r\n   */\r\n  toString(): string {\r\n    return `RiskProfile(health: ${this.healthRisk.toFixed(2)}, financial: ${this.financialRisk.toFixed(2)}, behavioral: ${this.behavioralRisk.toFixed(2)})`\r\n  }\r\n}","import { InsurancePremium } from '../valueObjects/InsurancePremium'\r\nimport type { Card } from '../entities/Card'\r\nimport type { GameStage } from '../types/card.types'\r\nimport type { InsuranceType } from '../types/card.types'\r\nimport { RiskFactor, type RiskFactorType } from '../valueObjects/RiskFactor'\r\nimport { RiskProfile } from '../valueObjects/RiskProfile'\r\n\r\n/**\r\n * 保険料計算ドメインサービス\r\n * \r\n * 保険料に関する複雑なビジネスロジックを集約し、\r\n * 年齢調整、保険種別調整、リスク調整等を統一的に管理します。\r\n * \r\n * このサービスは状態を持たず、純粋なビジネスロジックのみを提供します。\r\n */\r\nexport class InsurancePremiumCalculationService {\r\n  \r\n  /**\r\n   * 年齢ステージによる保険料倍率\r\n   */\r\n  private static readonly AGE_MULTIPLIERS: Record<GameStage, number> = {\r\n    'youth': 1.0,          // 青年期: 基準倍率\r\n    'adult': 1.0,          // 成人期: 基準倍率\r\n    'middle_age': 1.2,     // 中年期: 20%増し\r\n    'middle': 1.2,         // 中年期（旧定義）: 20%増し\r\n    'elder': 1.5,          // 老年期: 50%増し\r\n    'elderly': 1.5,        // 老年期（旧定義）: 50%増し\r\n    'fulfillment': 1.3     // 充実期: 30%増し\r\n  }\r\n\r\n  /**\r\n   * 保険種別による基本料率\r\n   */\r\n  private static readonly INSURANCE_TYPE_RATES: Record<InsuranceType, number> = {\r\n    'health': 1.0,         // 健康保険: 基準料率\r\n    'life': 1.2,           // 生命保険: 20%高\r\n    'disability': 0.8,     // 障害保険: 20%安\r\n    'accident': 0.6,       // 事故保険: 40%安\r\n    'cancer': 1.5,         // がん保険: 50%高\r\n    'dental': 0.4,         // 歯科保険: 60%安\r\n    'travel': 0.3          // 旅行保険: 70%安\r\n  }\r\n\r\n  /**\r\n   * 年齢調整済み保険料を計算\r\n   * \r\n   * @param basePremium 基本保険料\r\n   * @param stage プレイヤーの現在ステージ\r\n   * @returns 年齢調整済み保険料\r\n   */\r\n  calculateAgeAdjustedPremium(basePremium: InsurancePremium, stage: GameStage): InsurancePremium {\r\n    const multiplier = InsurancePremiumCalculationService.AGE_MULTIPLIERS[stage] || 1.0\r\n    return basePremium.applyMultiplier(multiplier)\r\n  }\r\n\r\n  /**\r\n   * 保険カードの総合保険料を計算\r\n   * \r\n   * 基本料金 + 年齢調整 + 保険種別調整 + カバレッジ調整 + リスク調整を総合的に計算\r\n   * \r\n   * @param card 保険カード\r\n   * @param stage プレイヤーの現在ステージ\r\n   * @param riskProfile プレイヤーのリスクプロファイル（オプション）\r\n   * @returns 総合保険料\r\n   */\r\n  calculateComprehensivePremium(\r\n    card: Card, \r\n    stage: GameStage,\r\n    riskProfile?: RiskProfile\r\n  ): InsurancePremium {\r\n    if (card.type !== 'insurance') {\r\n      throw new Error('Card must be an insurance card')\r\n    }\r\n\r\n    // 基本保険料取得\r\n    const basePremium = card.getCost()\r\n    \r\n    // 年齢調整\r\n    const ageAdjustedPremium = this.calculateAgeAdjustedPremium(basePremium, stage)\r\n    \r\n    // 保険種別調整\r\n    const typeAdjustedPremium = this.applyInsuranceTypeAdjustment(ageAdjustedPremium, card.insuranceType)\r\n    \r\n    // カバレッジ調整\r\n    const coverageAdjustedPremium = this.applyCoverageAdjustment(typeAdjustedPremium, card.coverage)\r\n    \r\n    // リスクプロファイル調整\r\n    if (riskProfile) {\r\n      const riskMultiplier = this.calculateRiskAdjustment(riskProfile, card.insuranceType)\r\n      return coverageAdjustedPremium.applyMultiplier(riskMultiplier)\r\n    }\r\n    \r\n    return coverageAdjustedPremium\r\n  }\r\n\r\n  /**\r\n   * 保険料負担の総計算\r\n   * \r\n   * 複数の保険を持つプレイヤーの総保険料負担を計算\r\n   * 3枚ごとの負担増加ルールを適用\r\n   * \r\n   * @param insuranceCards アクティブな保険カード配列\r\n   * @param stage プレイヤーの現在ステージ\r\n   * @param riskProfile プレイヤーのリスクプロファイル（オプション）\r\n   * @returns 総保険料負担\r\n   */\r\n  calculateTotalInsuranceBurden(\r\n    insuranceCards: Card[], \r\n    stage: GameStage,\r\n    riskProfile?: RiskProfile\r\n  ): InsurancePremium {\r\n    // 各保険の個別料金計算\r\n    const individualPremiums = insuranceCards.map(card => \r\n      this.calculateComprehensivePremium(card, stage, riskProfile)\r\n    )\r\n    \r\n    // 基本合計\r\n    const baseTotalPremium = InsurancePremium.sum(individualPremiums)\r\n    \r\n    // 3枚ごとの負担増加ルール\r\n    const penaltyMultiplier = this.calculateMultiInsurancePenalty(insuranceCards.length)\r\n    \r\n    return baseTotalPremium.applyMultiplier(penaltyMultiplier)\r\n  }\r\n\r\n  /**\r\n   * 保険更新時の料金計算\r\n   * \r\n   * 既存保険の更新時における料金調整\r\n   * 継続割引、経験調整、年齢変化を考慮\r\n   * \r\n   * @param card 更新対象の保険カード\r\n   * @param currentStage 現在のステージ\r\n   * @param usageHistory 使用履歴（使用回数）\r\n   * @returns 更新時保険料\r\n   */\r\n  calculateRenewalPremium(card: Card, currentStage: GameStage, usageHistory: number): InsurancePremium {\r\n    // 基本更新料金\r\n    const basePremium = this.calculateComprehensivePremium(card, currentStage)\r\n    \r\n    // 継続割引適用（長期継続者優遇）\r\n    const continuityDiscount = this.calculateContinuityDiscount(usageHistory)\r\n    const discountedPremium = basePremium.applyDiscount(continuityDiscount)\r\n    \r\n    // 使用実績による調整（リスク評価）\r\n    const riskMultiplier = this.calculateRiskMultiplier(usageHistory)\r\n    \r\n    return discountedPremium.applyMultiplier(riskMultiplier)\r\n  }\r\n\r\n  /**\r\n   * 最適保険ポートフォリオの提案\r\n   * \r\n   * プレイヤーの状況に応じた最適な保険組み合わせを計算\r\n   * \r\n   * @param availableBudget 利用可能予算（活力）\r\n   * @param stage 現在ステージ\r\n   * @param riskProfile リスクプロファイル\r\n   * @returns 推奨保険料上限\r\n   */\r\n  calculateOptimalInsuranceBudget(\r\n    availableBudget: number, \r\n    stage: GameStage, \r\n    riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'\r\n  ): InsurancePremium {\r\n    const budgetRatios = {\r\n      'conservative': 0.15,  // 予算の15%\r\n      'balanced': 0.25,      // 予算の25%\r\n      'aggressive': 0.35     // 予算の35%\r\n    }\r\n    \r\n    const ratio = budgetRatios[riskProfile]\r\n    const recommendedBudget = Math.floor(availableBudget * ratio)\r\n    \r\n    return InsurancePremium.create(recommendedBudget)\r\n  }\r\n\r\n  /**\r\n   * 保険種別調整を適用\r\n   * @private\r\n   */\r\n  private applyInsuranceTypeAdjustment(\r\n    premium: InsurancePremium, \r\n    insuranceType?: InsuranceType\r\n  ): InsurancePremium {\r\n    if (!insuranceType) {\r\n      return premium\r\n    }\r\n    \r\n    const typeRate = InsurancePremiumCalculationService.INSURANCE_TYPE_RATES[insuranceType] || 1.0\r\n    return premium.applyMultiplier(typeRate)\r\n  }\r\n\r\n  /**\r\n   * カバレッジ調整を適用\r\n   * @private\r\n   */\r\n  private applyCoverageAdjustment(premium: InsurancePremium, coverage?: number): InsurancePremium {\r\n    if (!coverage || coverage <= 0) {\r\n      // カバレッジ0の場合は基本料金の50%割引\r\n      return premium.applyMultiplier(0.5)\r\n    }\r\n    \r\n    // カバレッジが高いほど保険料も高くなる\r\n    // 基準カバレッジを50として、比例計算\r\n    const baselineCoverage = 50\r\n    const coverageMultiplier = Math.max(0.5, coverage / baselineCoverage)\r\n    \r\n    return premium.applyMultiplier(coverageMultiplier)\r\n  }\r\n\r\n  /**\r\n   * 複数保険ペナルティを計算\r\n   * @private\r\n   */\r\n  private calculateMultiInsurancePenalty(insuranceCount: number): number {\r\n    // 3枚ごとに10%ずつ負担増加\r\n    const penaltySteps = Math.floor(insuranceCount / 3)\r\n    return 1.0 + (penaltySteps * 0.1)\r\n  }\r\n\r\n  /**\r\n   * 継続割引率を計算\r\n   * @private\r\n   */\r\n  private calculateContinuityDiscount(usageHistory: number): number {\r\n    // 使用履歴が少ないほど継続割引率が高い（優良顧客）\r\n    if (usageHistory === 0) return 0.1      // 10%割引\r\n    if (usageHistory <= 2) return 0.05      // 5%割引\r\n    return 0                                 // 割引なし\r\n  }\r\n\r\n  /**\r\n   * リスク倍率を計算\r\n   * @private\r\n   */\r\n  private calculateRiskMultiplier(usageHistory: number): number {\r\n    // 使用履歴が多いほどリスクが高いとみなして料金増加\r\n    if (usageHistory >= 5) return 1.3       // 30%増し\r\n    if (usageHistory >= 3) return 1.1       // 10%増し\r\n    return 1.0                               // 基準料金\r\n  }\r\n\r\n  /**\r\n   * リスクプロファイルに基づく保険料調整を計算\r\n   * @private\r\n   */\r\n  private calculateRiskAdjustment(riskProfile: RiskProfile, insuranceType?: InsuranceType): number {\r\n    // 基本的なリスク倍率\r\n    let baseMultiplier = riskProfile.getTotalPremiumMultiplier()\r\n    \r\n    // 保険種類ごとに特定のリスクファクターの影響を強化\r\n    if (insuranceType) {\r\n      const typeSpecificAdjustments: Partial<Record<InsuranceType, RiskFactorType>> = {\r\n        'health': 'health',      // 健康保険は健康リスクの影響大\r\n        'life': 'age',          // 生命保険は年齢リスクの影響大\r\n        'disability': 'health',  // 障害保険は健康リスクの影響大\r\n        'accident': 'lifestyle', // 事故保険はライフスタイルの影響大\r\n        'cancer': 'health',      // がん保険は健康リスクの影響大\r\n      }\r\n      \r\n      const relevantFactorType = typeSpecificAdjustments[insuranceType]\r\n      if (relevantFactorType) {\r\n        const specificFactor = riskProfile.getFactor(relevantFactorType)\r\n        if (specificFactor) {\r\n          // 特定リスクの影響を20%強化\r\n          const specificMultiplier = specificFactor.getPremiumMultiplier()\r\n          baseMultiplier = baseMultiplier * 0.8 + specificMultiplier * 0.2\r\n        }\r\n      }\r\n    }\r\n    \r\n    return baseMultiplier\r\n  }\r\n\r\n  /**\r\n   * プレイヤーの行動履歴からリスクプロファイルを生成\r\n   * \r\n   * @param playerHistory プレイヤーの行動履歴\r\n   * @param currentStage 現在のステージ\r\n   * @returns 計算されたリスクプロファイル\r\n   */\r\n  generateRiskProfile(playerHistory: PlayerHistory, currentStage: GameStage): RiskProfile {\r\n    let profile = RiskProfile.default()\r\n    \r\n    // 年齢リスクの計算\r\n    const ageRiskValue = this.calculateAgeRisk(currentStage)\r\n    profile = profile.withFactor(RiskFactor.create(ageRiskValue, 'age'))\r\n    \r\n    // 健康リスクの計算（ダメージ履歴から）\r\n    const healthRiskValue = this.calculateHealthRisk(playerHistory)\r\n    profile = profile.withFactor(RiskFactor.create(healthRiskValue, 'health'))\r\n    \r\n    // 請求履歴リスクの計算\r\n    const claimsRiskValue = this.calculateClaimsRisk(playerHistory)\r\n    profile = profile.withFactor(RiskFactor.create(claimsRiskValue, 'claims'))\r\n    \r\n    // ライフスタイルリスクの計算（プレイスタイルから）\r\n    const lifestyleRiskValue = this.calculateLifestyleRisk(playerHistory)\r\n    profile = profile.withFactor(RiskFactor.create(lifestyleRiskValue, 'lifestyle'))\r\n    \r\n    return profile\r\n  }\r\n\r\n  /**\r\n   * リスクプロファイルを考慮した保険料を計算\r\n   * \r\n   * @param card 保険カード\r\n   * @param stage ゲームステージ\r\n   * @param riskProfile リスクプロファイル（オプション）\r\n   * @returns リスク調整済み保険料\r\n   */\r\n  calculateRiskAdjustedPremium(\r\n    card: Card,\r\n    stage: GameStage,\r\n    riskProfile?: RiskProfile\r\n  ): InsurancePremium {\r\n    // 基本的な総合保険料を計算\r\n    const basePremium = this.calculateComprehensivePremium(card, stage)\r\n    \r\n    // リスクプロファイルがない場合は基本保険料をそのまま返す\r\n    if (!riskProfile) {\r\n      return basePremium\r\n    }\r\n    \r\n    // リスク調整倍率を計算\r\n    const riskMultiplier = this.calculateRiskAdjustment(riskProfile, card.insuranceType)\r\n    \r\n    // リスク調整を適用\r\n    return basePremium.applyMultiplier(riskMultiplier)\r\n  }\r\n\r\n  /**\r\n   * 年齢によるリスク値を計算\r\n   * @private\r\n   */\r\n  private calculateAgeRisk(stage: GameStage): number {\r\n    const ageRiskMap: Record<GameStage, number> = {\r\n      'youth': 0.2,\r\n      'adult': 0.3,\r\n      'middle_age': 0.5,\r\n      'middle': 0.5,\r\n      'elder': 0.8,\r\n      'elderly': 0.8,\r\n      'fulfillment': 0.6\r\n    }\r\n    return ageRiskMap[stage] || 0.5\r\n  }\r\n\r\n  /**\r\n   * 健康履歴からリスク値を計算\r\n   * @private\r\n   */\r\n  private calculateHealthRisk(history: PlayerHistory): number {\r\n    const totalDamageTaken = history.totalDamageTaken || 0\r\n    const turnsPlayed = history.turnsPlayed || 1\r\n    const averageDamagePerTurn = totalDamageTaken / turnsPlayed\r\n    \r\n    // 平均ダメージが多いほどリスクが高い\r\n    if (averageDamagePerTurn >= 3) return 0.8\r\n    if (averageDamagePerTurn >= 2) return 0.6\r\n    if (averageDamagePerTurn >= 1) return 0.4\r\n    return 0.2\r\n  }\r\n\r\n  /**\r\n   * 保険請求履歴からリスク値を計算\r\n   * @private\r\n   */\r\n  private calculateClaimsRisk(history: PlayerHistory): number {\r\n    const claimCount = history.insuranceClaimCount || 0\r\n    const totalInsurances = history.totalInsurancePurchased || 1\r\n    const claimRate = claimCount / totalInsurances\r\n    \r\n    // 請求率が高いほどリスクが高い\r\n    if (claimRate >= 0.5) return 0.9\r\n    if (claimRate >= 0.3) return 0.6\r\n    if (claimRate >= 0.1) return 0.3\r\n    return 0.1\r\n  }\r\n\r\n  /**\r\n   * プレイスタイルからライフスタイルリスクを計算\r\n   * @private\r\n   */\r\n  private calculateLifestyleRisk(history: PlayerHistory): number {\r\n    const riskyChoices = history.riskyChoiceCount || 0\r\n    const totalChoices = history.totalChoiceCount || 1\r\n    const riskRate = riskyChoices / totalChoices\r\n    \r\n    // リスキーな選択が多いほどリスクが高い\r\n    if (riskRate >= 0.6) return 0.8\r\n    if (riskRate >= 0.4) return 0.5\r\n    if (riskRate >= 0.2) return 0.3\r\n    return 0.1\r\n  }\r\n}\r\n\r\n/**\r\n * プレイヤー履歴インターフェース\r\n */\r\nexport interface PlayerHistory {\r\n  turnsPlayed: number\r\n  totalDamageTaken: number\r\n  insuranceClaimCount: number\r\n  totalInsurancePurchased: number\r\n  riskyChoiceCount: number\r\n  totalChoiceCount: number\r\n}","import type { GameStage } from '../types/card.types'\r\n\r\n/**\r\n * ゲームステージ管理サービス\r\n * \r\n * ゲームのステージ進行ロジックを管理する単一責任クラス\r\n */\r\nexport class GameStageManager {\r\n  private static readonly STAGE_TRANSITION_TURNS = {\r\n    YOUTH_TO_MIDDLE: 8,\r\n    MIDDLE_TO_FULFILLMENT: 15\r\n  } as const\r\n\r\n  /**\r\n   * ターン数に基づいてステージ進行をチェックし、必要に応じて更新\r\n   * @param currentStage 現在のステージ\r\n   * @param turn 現在のターン数\r\n   * @returns 新しいステージ（変更がない場合は元のステージ）\r\n   */\r\n  checkStageProgression(currentStage: GameStage, turn: number): {\r\n    newStage: GameStage\r\n    hasChanged: boolean\r\n    transitionMessage?: string\r\n  } {\r\n    const oldStage = currentStage\r\n    let newStage = currentStage\r\n\r\n    if (turn >= GameStageManager.STAGE_TRANSITION_TURNS.YOUTH_TO_MIDDLE && currentStage === 'youth') {\r\n      newStage = 'middle'\r\n    } else if (turn >= GameStageManager.STAGE_TRANSITION_TURNS.MIDDLE_TO_FULFILLMENT && currentStage === 'middle') {\r\n      newStage = 'fulfillment'\r\n    }\r\n\r\n    const hasChanged = oldStage !== newStage\r\n    const transitionMessage = hasChanged \r\n      ? `🎯 ステージが変化しました: ${oldStage} → ${newStage}`\r\n      : undefined\r\n\r\n    return {\r\n      newStage,\r\n      hasChanged,\r\n      transitionMessage\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 手動でステージを進める\r\n   * @param currentStage 現在のステージ\r\n   * @returns 次のステージと完了状態\r\n   */\r\n  advanceStage(currentStage: GameStage): {\r\n    newStage: GameStage | null\r\n    isCompleted: boolean\r\n  } {\r\n    switch (currentStage) {\r\n      case 'youth':\r\n        return { newStage: 'middle', isCompleted: false }\r\n      case 'middle':\r\n        return { newStage: 'fulfillment', isCompleted: false }\r\n      case 'fulfillment':\r\n        return { newStage: null, isCompleted: true }\r\n      default:\r\n        return { newStage: null, isCompleted: true }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 指定されたステージが最終ステージかどうか判定\r\n   */\r\n  isFinalStage(stage: GameStage): boolean {\r\n    return stage === 'fulfillment'\r\n  }\r\n}","import type { Card } from '../entities/Card'\r\nimport type { InsuranceExpirationNotice } from '../types/game.types'\r\n\r\n/**\r\n * 保険期限管理サービス\r\n * \r\n * 保険カードの期限切れ処理を専門に扱う単一責任クラス\r\n */\r\nexport class InsuranceExpirationManager {\r\n  private static readonly EXPIRING_SOON_THRESHOLD = 2\r\n\r\n  /**\r\n   * 定期保険の期限を更新し、期限切れをチェック\r\n   * @param insuranceCards 現在有効な保険カード配列（変更される）\r\n   * @param expiredInsurances 期限切れ保険カード配列（変更される）\r\n   * @param currentTurn 現在のターン数\r\n   * @returns 期限切れ通知（期限切れがない場合はundefined）\r\n   */\r\n  updateInsuranceExpirations(\r\n    insuranceCards: Card[], \r\n    expiredInsurances: Card[], \r\n    currentTurn: number\r\n  ): InsuranceExpirationNotice | undefined {\r\n    // 期限切れになった保険を一時的に保存\r\n    const nowExpired: Card[] = []\r\n    \r\n    // 全ての保険カードの期限を更新\r\n    insuranceCards.forEach(card => {\r\n      if (card.isTermInsurance()) {\r\n        card.decrementTurn()\r\n        \r\n        // 期限切れになったものを記録\r\n        if (card.isExpired()) {\r\n          nowExpired.push(card)\r\n        }\r\n      }\r\n    })\r\n    \r\n    // 期限切れの保険を active から expired に移動\r\n    if (nowExpired.length > 0) {\r\n      // 期限切れカードを保険カード配列から削除\r\n      nowExpired.forEach(expiredCard => {\r\n        const index = insuranceCards.findIndex(card => card.id === expiredCard.id)\r\n        if (index !== -1) {\r\n          insuranceCards.splice(index, 1)\r\n        }\r\n      })\r\n      \r\n      // 期限切れ配列に追加\r\n      expiredInsurances.push(...nowExpired)\r\n      \r\n      // 期限切れ通知を作成\r\n      return this.createExpirationNotice(nowExpired, currentTurn)\r\n    }\r\n    \r\n    return undefined\r\n  }\r\n\r\n  /**\r\n   * 期限が近い保険カードを取得（残り指定ターン以下）\r\n   */\r\n  getExpiringSoonInsurances(insuranceCards: Card[]): Card[] {\r\n    return insuranceCards.filter(card => \r\n      card.isTermInsurance() && \r\n      card.remainingTurns !== undefined && \r\n      card.remainingTurns <= InsuranceExpirationManager.EXPIRING_SOON_THRESHOLD && \r\n      card.remainingTurns > 0\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 保険期限切れの警告メッセージを取得\r\n   */\r\n  getExpirationWarnings(insuranceCards: Card[]): string[] {\r\n    const expiringSoon = this.getExpiringSoonInsurances(insuranceCards)\r\n    return expiringSoon.map(card => \r\n      `⚠️ 「${card.name}」の期限まであと${card.remainingTurns}ターンです`\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 期限切れ通知を作成\r\n   * @private\r\n   */\r\n  private createExpirationNotice(expiredCards: Card[], turnNumber: number): InsuranceExpirationNotice {\r\n    const expiredNames = expiredCards.map(card => card.name).join('、')\r\n    const message = expiredCards.length === 1 \r\n      ? `定期保険「${expiredNames}」の期限が切れました。`\r\n      : `定期保険${expiredCards.length}件（${expiredNames}）の期限が切れました。`\r\n    \r\n    return {\r\n      expiredCards,\r\n      message,\r\n      showRenewalOption: true, // 将来的に更新オプションを実装するため\r\n      turnNumber\r\n    }\r\n  }\r\n}","import type { Card } from '../entities/Card'\r\nimport type { ChallengeResult, GameStage } from '../types/card.types'\r\nimport type { ICardManager } from './CardManager'\r\nimport type { Game } from '../entities/Game'\r\nimport { RiskRewardChallenge } from '../entities/RiskRewardChallenge'\r\n\r\n/**\r\n * チャレンジ解決サービス\r\n * \r\n * チャレンジの解決ロジックを専門に扱う単一責任クラス\r\n */\r\nexport class ChallengeResolutionService {\r\n  /**\r\n   * チャレンジを解決し、結果を計算\r\n   * @param challenge チャレンジカード\r\n   * @param selectedCards 選択されたカード\r\n   * @param cardManager カード管理サービス\r\n   * @param stage 現在のゲームステージ\r\n   * @param insuranceBurden 保険料負担\r\n   * @param game ゲームエンティティ（保険情報取得用）\r\n   * @returns チャレンジ結果\r\n   */\r\n  resolveChallenge(\r\n    challenge: Card,\r\n    selectedCards: Card[],\r\n    cardManager: ICardManager,\r\n    stage: GameStage,\r\n    insuranceBurden: number,\r\n    game?: Game\r\n  ): ChallengeResult {\r\n    // リスクチャレンジの特殊ルールを確認\r\n    const isRiskChallenge = challenge instanceof RiskRewardChallenge\r\n    const insuranceImmunity = isRiskChallenge && challenge.insuranceImmunity\r\n    \r\n    // 保険効果を適用（特化型保険のボーナス）\r\n    const insuranceBonus = (game && !insuranceImmunity) ? this.calculateInsuranceBonus(game, challenge) : 0\r\n    \r\n    // パワー計算の詳細\r\n    const powerBreakdown = this.calculateTotalPower(selectedCards, insuranceBurden, insuranceBonus)\r\n    const playerPower = powerBreakdown.total\r\n    \r\n    // 夢カードの場合は年齢調整を適用\r\n    const challengePower = this.getDreamRequiredPower(challenge, stage)\r\n    \r\n    // 成功判定\r\n    const success = playerPower >= challengePower\r\n    \r\n    // 活力変更計算\r\n    let vitalityChange = 0\r\n    if (success) {\r\n      const baseReward = Math.floor((playerPower - challengePower) / 2)\r\n      // リスクチャレンジの場合は報酬を調整\r\n      if (isRiskChallenge) {\r\n        vitalityChange = challenge.calculateActualReward(baseReward)\r\n      } else {\r\n        vitalityChange = baseReward\r\n      }\r\n    } else {\r\n      // 失敗時のダメージ計算\r\n      const baseDamage = challengePower - playerPower\r\n      // 防御型保険によるダメージ軽減（保険無効の場合は0）\r\n      const damageReduction = (game && !insuranceImmunity) ? this.calculateDamageReduction(game) : 0\r\n      const actualDamage = Math.max(1, baseDamage - damageReduction)\r\n      \r\n      // リスクチャレンジの場合はペナルティを調整\r\n      if (isRiskChallenge) {\r\n        vitalityChange = -challenge.calculateActualPenalty(actualDamage)\r\n      } else {\r\n        vitalityChange = -actualDamage\r\n      }\r\n    }\r\n    \r\n    // 使用したカードを捨て札に\r\n    cardManager.discardSelectedCards()\r\n    \r\n    // 結果作成\r\n    const result: ChallengeResult = {\r\n      success,\r\n      playerPower,\r\n      challengePower,\r\n      vitalityChange,\r\n      message: success \r\n        ? `チャレンジ成功！ +${vitalityChange} 活力`\r\n        : `チャレンジ失敗... ${vitalityChange} 活力`,\r\n      powerBreakdown\r\n    }\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * 総合パワーを詳細に計算\r\n   * @param cards 使用するカード\r\n   * @param insuranceBurden 保険料負担\r\n   * @param insuranceBonus 保険ボーナス\r\n   * @returns パワーの詳細な内訳\r\n   */\r\n  private calculateTotalPower(cards: Card[], insuranceBurden: number, insuranceBonus: number = 0): {\r\n    base: number\r\n    insurance: number\r\n    burden: number\r\n    total: number\r\n  } {\r\n    // 基本パワー（保険以外のカード）\r\n    let basePower = 0\r\n    let insurancePower = 0\r\n    \r\n    cards.forEach(card => {\r\n      if (card.type === 'insurance') {\r\n        // 保険カードのパワー（年齢ボーナス込み）\r\n        insurancePower += card.calculateEffectivePower()\r\n      } else {\r\n        // その他のカードの基本パワー\r\n        basePower += card.calculateEffectivePower()\r\n      }\r\n    })\r\n    \r\n    // 保険ボーナスを保険パワーに加算\r\n    insurancePower += insuranceBonus\r\n    \r\n    // 総合パワー\r\n    const total = basePower + insurancePower - insuranceBurden\r\n    \r\n    return {\r\n      base: basePower,\r\n      insurance: insurancePower,\r\n      burden: -insuranceBurden, // 負の値として表示\r\n      total: Math.max(0, total) // 総合パワーは0以下にならない\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険無効チャレンジ用のパワー計算\r\n   * @private\r\n   */\r\n  private calculatePowerWithoutInsurance(cards: Card[], insuranceBurden: number): {\r\n    base: number\r\n    insurance: number\r\n    burden: number\r\n    total: number\r\n  } {\r\n    let basePower = 0\r\n    \r\n    // 保険以外のカードのみパワーを計算\r\n    cards.forEach(card => {\r\n      if (card.type !== 'insurance') {\r\n        basePower += card.calculateEffectivePower()\r\n      }\r\n    })\r\n    \r\n    // 保険パワーは0、保険料負担はそのまま\r\n    return {\r\n      base: basePower,\r\n      insurance: 0,\r\n      burden: -insuranceBurden,\r\n      total: Math.max(0, basePower - insuranceBurden)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 夢カードの必要パワーを年齢調整込みで計算\r\n   */\r\n  private getDreamRequiredPower(challenge: Card, stage: GameStage): number {\r\n    // 夢カードでない場合は基本パワーをそのまま返す\r\n    if (!challenge.isDreamCard() || !challenge.dreamCategory) {\r\n      return challenge.power\r\n    }\r\n    \r\n    // 青年期は調整なし\r\n    if (stage === 'youth') {\r\n      return challenge.power\r\n    }\r\n    \r\n    // 中年期・充実期の年齢調整を適用（簡易版）\r\n    const adjustment = stage === 'middle' ? 1 : 2\r\n    const adjustedPower = challenge.power + adjustment\r\n    \r\n    // 最小値は1\r\n    return Math.max(1, adjustedPower)\r\n  }\r\n\r\n  /**\r\n   * 保険によるチャレンジボーナスを計算\r\n   * @private\r\n   */\r\n  private calculateInsuranceBonus(game: Game, challenge: Card): number {\r\n    let totalBonus = 0\r\n    const insuranceCards = game.getActiveInsurances()\r\n    \r\n    insuranceCards.forEach(insurance => {\r\n      // 特化型保険のボーナスを計算\r\n      if (insurance.isSpecializedInsurance()) {\r\n        const challengeType = challenge.name // チャレンジ名で判定\r\n        const bonus = insurance.calculateChallengeBonus(challengeType)\r\n        totalBonus += bonus\r\n      }\r\n    })\r\n    \r\n    return totalBonus\r\n  }\r\n\r\n  /**\r\n   * 防御型保険によるダメージ軽減を計算\r\n   * @private\r\n   */\r\n  private calculateDamageReduction(game: Game): number {\r\n    let totalReduction = 0\r\n    const insuranceCards = game.getActiveInsurances()\r\n    \r\n    insuranceCards.forEach(insurance => {\r\n      if (insurance.isDefensiveInsurance()) {\r\n        totalReduction += insurance.calculateDamageReduction()\r\n      }\r\n    })\r\n    \r\n    return totalReduction\r\n  }\r\n}","/**\r\n * ゲームターン管理サービス\r\n * \r\n * Game.tsから分離されたターン管理の責任を持つ\r\n * \r\n * @class GameTurnManager\r\n * @description\r\n * ゲームのターン進行に関するすべてのロジックを管理します。\r\n * ステージ進行、保険期限管理、ターン開始時のドローなどを担当します。\r\n * \r\n * @example\r\n * ```typescript\r\n * const turnManager = new GameTurnManager(stageManager, expirationManager);\r\n * const result = turnManager.nextTurn(game);\r\n * console.log(`Turn ${game.turn} - Expired insurances: ${result.newExpiredCount}`);\r\n * ```\r\n */\r\n\r\nimport type { Game } from '../entities/Game'\r\nimport type { TurnResult } from '../types/game.types'\r\nimport type { GameStageManager } from './GameStageManager'\r\nimport type { InsuranceExpirationManager } from './InsuranceExpirationManager'\r\n\r\nexport class GameTurnManager {\r\n  constructor(\r\n    private readonly stageManager: GameStageManager,\r\n    private readonly expirationManager: InsuranceExpirationManager\r\n  ) {}\r\n\r\n  /**\r\n   * 次のターンへ進める\r\n   * \r\n   * @method nextTurn\r\n   * @param {Game} game - ゲームインスタンス\r\n   * @returns {TurnResult} ターン結果（期限切れ保険情報を含む）\r\n   * @throws {Error} ゲームが進行中でない場合\r\n   * \r\n   * @description\r\n   * 1. ゲーム状態を検証\r\n   * 2. ターン数をインクリメント\r\n   * 3. ステージ進行をチェック\r\n   * 4. 保険期限を更新\r\n   * 5. カードをドロー\r\n   */\r\n  nextTurn(game: Game): TurnResult {\r\n    this.validateGameState(game)\r\n    \r\n    // ターンを進める\r\n    game.turn++\r\n    game.stats.turnsPlayed++\r\n    game.phase = 'draw'\r\n    \r\n    // ステージ進行の判定\r\n    this.checkStageProgression(game)\r\n    \r\n    // 保険期限の更新\r\n    const expirationResult = this.updateInsuranceExpirations(game)\r\n    \r\n    // ターン開始時のドロー\r\n    game.drawCards(1)\r\n    \r\n    // 回復型保険の効果を適用\r\n    this.applyRecoveryInsuranceEffects(game)\r\n    \r\n    return {\r\n      insuranceExpirations: expirationResult,\r\n      newExpiredCount: expirationResult?.expiredCards.length || 0,\r\n      remainingInsuranceCount: game.insuranceCards.length\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ゲーム状態の検証\r\n   * @private\r\n   */\r\n  private validateGameState(game: Game): void {\r\n    if (game.status !== 'in_progress') {\r\n      throw new Error('Game is not in progress')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ステージ進行をチェック\r\n   * @private\r\n   */\r\n  private checkStageProgression(game: Game): void {\r\n    const progressionResult = this.stageManager.checkStageProgression(\r\n      game.stage, \r\n      game.turn\r\n    )\r\n    \r\n    if (progressionResult.hasChanged) {\r\n      game.setStage(progressionResult.newStage)\r\n      \r\n      if (progressionResult.transitionMessage) {\r\n        console.log(progressionResult.transitionMessage)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険期限を更新\r\n   * @private\r\n   */\r\n  private updateInsuranceExpirations(game: Game) {\r\n    const expirationResult = this.expirationManager.updateInsuranceExpirations(\r\n      game.insuranceCards,\r\n      game.expiredInsurances,\r\n      game.turn\r\n    )\r\n    \r\n    // 期限切れがあった場合は保険料負担を再計算\r\n    if (expirationResult) {\r\n      // Gameクラスのメソッドを呼び出して更新\r\n      // これにより、Gameクラスの内部状態の一貫性を保つ\r\n      (game as any).updateInsuranceBurden()\r\n    }\r\n    \r\n    return expirationResult\r\n  }\r\n\r\n  /**\r\n   * 回復型保険の効果を適用\r\n   * @private\r\n   */\r\n  private applyRecoveryInsuranceEffects(game: Game): void {\r\n    const activeInsurances = game.getActiveInsurances()\r\n    let totalHeal = 0\r\n    \r\n    activeInsurances.forEach(insurance => {\r\n      if (insurance.isRecoveryInsurance()) {\r\n        totalHeal += insurance.calculateTurnHeal()\r\n      }\r\n    })\r\n    \r\n    if (totalHeal > 0) {\r\n      game.heal(totalHeal)\r\n      console.log(`💚 回復型保険効果: +${totalHeal} 活力`)\r\n    }\r\n  }\r\n}","/**\r\n * ゲームチャレンジ処理サービス\r\n * \r\n * チャレンジの解決に関する複雑なロジックを管理\r\n * \r\n * @class GameChallengeService\r\n * @description\r\n * チャレンジの開始から解決までの一連のプロセスを管理します。\r\n * パワー計算、成功判定、活力変更、統計更新などを担当します。\r\n * \r\n * @example\r\n * ```typescript\r\n * const challengeService = new GameChallengeService(resolutionService);\r\n * \r\n * // チャレンジを開始\r\n * challengeService.startChallenge(game, challengeCard);\r\n * \r\n * // チャレンジを解決\r\n * const result = challengeService.resolveChallenge(game);\r\n * if (result.success) {\r\n *   console.log('チャレンジ成功！');\r\n * }\r\n * ```\r\n */\r\n\r\nimport type { Card } from '../entities/Card'\r\nimport type { Game } from '../entities/Game'\r\nimport type { ChallengeResult, InsuranceTypeChoice } from '../types/game.types'\r\nimport { CardFactory } from './CardFactory'\r\nimport type { ChallengeResolutionService } from './ChallengeResolutionService'\r\n\r\n/**\r\n * パワー計算の内訳\r\n * \r\n * @interface PowerBreakdown\r\n * @property {number} base - 基本カードのパワー合計\r\n * @property {number} insurance - 保険カードのパワー合計\r\n * @property {number} burden - 保険料負担（負の値）\r\n * @property {number} total - 総合パワー（最小値は0）\r\n */\r\nexport interface PowerBreakdown {\r\n  base: number\r\n  insurance: number\r\n  burden: number\r\n  total: number\r\n}\r\n\r\nexport class GameChallengeService {\r\n  constructor(\r\n    private readonly resolutionService: ChallengeResolutionService\r\n  ) {}\r\n\r\n  /**\r\n   * チャレンジを開始\r\n   */\r\n  startChallenge(game: Game, challengeCard: Card): void {\r\n    this.validatePhase(game, 'draw')\r\n    \r\n    game.currentChallenge = challengeCard\r\n    game.cardManager.clearSelection()\r\n    game.phase = 'challenge'\r\n  }\r\n\r\n  /**\r\n   * チャレンジを解決\r\n   */\r\n  resolveChallenge(game: Game): ChallengeResult {\r\n    this.validateChallenge(game)\r\n    \r\n    // 新しいChallengeResolutionServiceを使用\r\n    const result = this.resolutionService.resolveChallenge(\r\n      game.currentChallenge!,\r\n      game.selectedCards,\r\n      game.cardManager,\r\n      game.stage,\r\n      game.insuranceBurden,\r\n      game\r\n    )\r\n    \r\n    // 統計更新\r\n    this.updateStatistics(game, result.success)\r\n    \r\n    // 活力更新\r\n    this.updateVitality(game, result.vitalityChange)\r\n    \r\n    // 成功時は保険種類選択肢を追加\r\n    if (result.success) {\r\n      const choices = CardFactory.createInsuranceTypeChoices(game.stage)\r\n      game.insuranceTypeChoices = choices\r\n      result.insuranceTypeChoices = choices\r\n    }\r\n    \r\n    this.updateGameStateAfterChallenge(game, result)\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * 総合パワーを計算\r\n   * \r\n   * @method calculateTotalPower\r\n   * @param {Game} game - ゲームインスタンス\r\n   * @param {Card[]} cards - 計算対象のカード配列\r\n   * @returns {PowerBreakdown} パワーの詳細な内訳\r\n   * \r\n   * @description\r\n   * 選択されたカードのパワーを計算し、保険料負担を考慮した\r\n   * 総合パワーを算出します。結果は常に0以上になります。\r\n   */\r\n  calculateTotalPower(game: Game, cards: Card[]): PowerBreakdown {\r\n    let basePower = 0\r\n    let insurancePower = 0\r\n    \r\n    for (const card of cards) {\r\n      if (card.type === 'insurance') {\r\n        insurancePower += card.calculateEffectivePower()\r\n      } else {\r\n        basePower += card.calculateEffectivePower()\r\n      }\r\n    }\r\n    \r\n    const burden = game.insuranceBurden\r\n    const total = Math.max(0, basePower + insurancePower + burden)\r\n    \r\n    return { base: basePower, insurance: insurancePower, burden, total }\r\n  }\r\n\r\n  /**\r\n   * チャレンジ結果を作成\r\n   * @private\r\n   */\r\n  private createChallengeResult(\r\n    game: Game,\r\n    powerBreakdown: PowerBreakdown,\r\n    challengePower: number\r\n  ): ChallengeResult {\r\n    const playerPower = powerBreakdown.total\r\n    const success = playerPower >= challengePower\r\n    \r\n    // 統計更新\r\n    this.updateStatistics(game, success)\r\n    \r\n    // 活力変更を計算\r\n    const vitalityChange = this.calculateVitalityChange(\r\n      success,\r\n      playerPower,\r\n      challengePower\r\n    )\r\n    \r\n    // 活力を更新\r\n    this.updateVitality(game, vitalityChange)\r\n    \r\n    const result: ChallengeResult = {\r\n      success,\r\n      playerPower,\r\n      challengePower,\r\n      vitalityChange,\r\n      message: this.createResultMessage(success, vitalityChange),\r\n      powerBreakdown\r\n    }\r\n    \r\n    // 成功時は保険種類選択肢を追加\r\n    if (success) {\r\n      const choices = CardFactory.createInsuranceTypeChoices(game.stage)\r\n      game.insuranceTypeChoices = choices\r\n      result.insuranceTypeChoices = choices\r\n    }\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * チャレンジ後のゲーム状態更新\r\n   * @private\r\n   */\r\n  private updateGameStateAfterChallenge(\r\n    game: Game,\r\n    result: ChallengeResult\r\n  ): void {\r\n    // 使用したカードを捨て札に\r\n    game.cardManager.discardSelectedCards()\r\n    \r\n    // フェーズ更新\r\n    game.phase = result.success \r\n      ? 'insurance_type_selection' \r\n      : 'resolution'\r\n    \r\n    // チャレンジをクリア\r\n    game.currentChallenge = undefined\r\n    game.cardManager.clearSelection()\r\n  }\r\n\r\n  /**\r\n   * バリデーション: フェーズチェック\r\n   * @private\r\n   */\r\n  private validatePhase(game: Game, expectedPhase: string): void {\r\n    if (game.phase !== expectedPhase) {\r\n      throw new Error(`Can only perform this action during ${expectedPhase} phase`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * バリデーション: チャレンジ存在チェック\r\n   * @private\r\n   */\r\n  private validateChallenge(game: Game): void {\r\n    if (!game.currentChallenge || game.phase !== 'challenge') {\r\n      throw new Error('No active challenge to resolve')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * チャレンジの必要パワーを取得\r\n   * @private\r\n   */\r\n  private getChallengePower(game: Game): number {\r\n    if (!game.currentChallenge) {\r\n      throw new Error('No active challenge')\r\n    }\r\n    \r\n    // 夢カードの年齢調整を適用\r\n    return game.getDreamRequiredPower(game.currentChallenge)\r\n  }\r\n\r\n  /**\r\n   * 統計を更新\r\n   * @private\r\n   */\r\n  private updateStatistics(game: Game, success: boolean): void {\r\n    game.stats.totalChallenges++\r\n    if (success) {\r\n      game.stats.successfulChallenges++\r\n    } else {\r\n      game.stats.failedChallenges++\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 活力変更量を計算（保険効果を考慮）\r\n   * @private\r\n   */\r\n  private calculateVitalityChange(\r\n    game: Game,\r\n    success: boolean,\r\n    playerPower: number,\r\n    challengePower: number\r\n  ): number {\r\n    if (success) {\r\n      return Math.floor((playerPower - challengePower) / 2)\r\n    } else {\r\n      // 失敗時のダメージ計算\r\n      const baseDamage = challengePower - playerPower\r\n      \r\n      // 防御型保険によるダメージ軽渚\r\n      const activeInsurances = game.getActiveInsurances()\r\n      let damageReduction = 0\r\n      \r\n      activeInsurances.forEach(insurance => {\r\n        if (insurance.isDefensiveInsurance()) {\r\n          damageReduction += insurance.calculateDamageReduction()\r\n        }\r\n      })\r\n      \r\n      return -(Math.max(1, baseDamage - damageReduction))\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 活力を更新\r\n   * @private\r\n   */\r\n  private updateVitality(game: Game, change: number): void {\r\n    if (change >= 0) {\r\n      game.heal(change)\r\n    } else {\r\n      game.applyDamage(-change)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 結果メッセージを作成\r\n   * @private\r\n   */\r\n  private createResultMessage(success: boolean, vitalityChange: number): string {\r\n    if (success) {\r\n      return `チャレンジ成功！ +${vitalityChange} 活力`\r\n    } else {\r\n      return `チャレンジ失敗... ${vitalityChange} 活力`\r\n    }\r\n  }\r\n}","/**\r\n * 保険管理サービス\r\n * \r\n * 保険関連の処理を集約\r\n */\r\n\r\nimport type { Card } from '../entities/Card'\r\nimport type { Game } from '../entities/Game'\r\nimport type { InsuranceTypeSelectionResult } from '../types/game.types'\r\nimport { CardFactory } from './CardFactory'\r\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\r\nimport type { InsurancePremiumCalculationService } from './InsurancePremiumCalculationService'\r\n\r\nexport class GameInsuranceService {\r\n  constructor(\r\n    private readonly premiumService: InsurancePremiumCalculationService\r\n  ) {}\r\n\r\n  /**\r\n   * 保険を追加\r\n   */\r\n  addInsurance(game: Game, card: Card): void {\r\n    if (!card.isInsurance()) {\r\n      throw new Error('Only insurance cards can be added')\r\n    }\r\n    \r\n    game.insuranceCards.push(card)\r\n    this.updateInsuranceBurden(game)\r\n  }\r\n\r\n  /**\r\n   * 保険種類を選択\r\n   */\r\n  selectInsuranceType(\r\n    game: Game,\r\n    insuranceType: string,\r\n    durationType: 'term' | 'whole_life'\r\n  ): InsuranceTypeSelectionResult {\r\n    this.validateInsuranceSelection(game)\r\n    \r\n    const choice = this.findInsuranceChoice(game, insuranceType)\r\n    if (!choice) {\r\n      return {\r\n        success: false,\r\n        message: 'Invalid insurance type selection'\r\n      }\r\n    }\r\n    \r\n    const selectedCard = this.createInsuranceCard(choice, durationType)\r\n    \r\n    this.addInsuranceCard(game, selectedCard)\r\n    this.updatePlayerHistory(game, insuranceType)\r\n    this.updateRiskProfile(game)\r\n    this.completeInsuranceSelection(game)\r\n    \r\n    return this.createSelectionResult(selectedCard, choice, durationType)\r\n  }\r\n\r\n  /**\r\n   * 保険料負担を計算\r\n   */\r\n  calculateInsuranceBurden(game: Game): number {\r\n    if (game.insuranceCards.length === 0) {\r\n      return 0\r\n    }\r\n\r\n    try {\r\n      const totalBurden = this.premiumService.calculateTotalInsuranceBurden(\r\n        game.insuranceCards,\r\n        game.stage,\r\n        game.getRiskProfile()\r\n      )\r\n      \r\n      // 負の値として返す（活力から差し引かれるため）\r\n      return -totalBurden.getValue()\r\n    } catch (error) {\r\n      console.warn('保険料計算でエラーが発生しました:', error)\r\n      return this.fallbackBurdenCalculation(game)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険料負担を更新\r\n   */\r\n  updateInsuranceBurden(game: Game): void {\r\n    const burden = this.calculateInsuranceBurden(game)\r\n    // Gameクラスの内部プロパティを更新\r\n    const absValue = Math.abs(burden)\r\n    ;(game as any)._insuranceBurden = InsurancePremium.create(absValue)\r\n    \r\n    // ダーティフラグを更新\r\n    if ((game as any)._dirtyFlags) {\r\n      (game as any)._dirtyFlags.insurance = true\r\n      ;(game as any)._dirtyFlags.burden = true\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 推奨保険予算を取得\r\n   */\r\n  getRecommendedInsuranceBudget(\r\n    vitality: number,\r\n    stage: string,\r\n    riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'\r\n  ): InsurancePremium {\r\n    return this.premiumService.calculateOptimalInsuranceBudget(\r\n      vitality,\r\n      stage as any,\r\n      riskProfile\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 期限が近い保険を取得\r\n   */\r\n  getExpiringSoonInsurances(insuranceCards: Card[]): Card[] {\r\n    return insuranceCards.filter(card => {\r\n      if (!card.isTermInsurance() || !card.remainingTurns) {\r\n        return false\r\n      }\r\n      return card.remainingTurns <= 2\r\n    })\r\n  }\r\n\r\n  /**\r\n   * バリデーション\r\n   * @private\r\n   */\r\n  private validateInsuranceSelection(game: Game): void {\r\n    if (game.phase !== 'insurance_type_selection') {\r\n      throw new Error('Not in insurance type selection phase')\r\n    }\r\n    \r\n    if (!game.insuranceTypeChoices) {\r\n      throw new Error('No insurance type choices available')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険選択肢を検索\r\n   * @private\r\n   */\r\n  private findInsuranceChoice(game: Game, insuranceType: string) {\r\n    return game.insuranceTypeChoices?.find(\r\n      choice => choice.insuranceType === insuranceType\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 保険カードを作成\r\n   * @private\r\n   */\r\n  private createInsuranceCard(choice: any, durationType: 'term' | 'whole_life'): Card {\r\n    if (durationType === 'term') {\r\n      return CardFactory.createTermInsuranceCard(choice)\r\n    } else {\r\n      return CardFactory.createWholeLifeInsuranceCard(choice)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 保険カードを追加\r\n   * @private\r\n   */\r\n  private addInsuranceCard(game: Game, card: Card): void {\r\n    game.cardManager.addToPlayerDeck(card)\r\n    game.stats.cardsAcquired++\r\n    game.insuranceCards.push(card)\r\n    this.updateInsuranceBurden(game)\r\n  }\r\n\r\n  /**\r\n   * 保険選択を完了\r\n   * @private\r\n   */\r\n  private completeInsuranceSelection(game: Game): void {\r\n    game.insuranceTypeChoices = undefined\r\n    game.phase = 'resolution'\r\n  }\r\n\r\n  /**\r\n   * 選択結果を作成\r\n   * @private\r\n   */\r\n  private createSelectionResult(\r\n    card: Card,\r\n    choice: any,\r\n    durationType: 'term' | 'whole_life'\r\n  ): InsuranceTypeSelectionResult {\r\n    const durationText = durationType === 'term' \r\n      ? `定期保険（${choice.termOption.duration}ターン）` \r\n      : '終身保険'\r\n    \r\n    return {\r\n      success: true,\r\n      selectedCard: card,\r\n      message: `${choice.name}（${durationText}）を選択しました。コスト: ${card.cost}`\r\n    }\r\n  }\r\n\r\n  /**\r\n   * フォールバック計算\r\n   * @private\r\n   */\r\n  private fallbackBurdenCalculation(game: Game): number {\r\n    const activeInsuranceCount = game.insuranceCards.length\r\n    const burden = Math.floor(activeInsuranceCount / 3)\r\n    return burden === 0 ? 0 : -burden\r\n  }\r\n\r\n  /**\r\n   * プレイヤー履歴を更新\r\n   * @private\r\n   */\r\n  private updatePlayerHistory(game: Game, insuranceType: string): void {\r\n    const history = game.getPlayerHistory()\r\n    history.totalInsurancePurchased++\r\n    \r\n    // リスクの高い保険種類を選んだ場合\r\n    if (insuranceType === 'life' || insuranceType === 'cancer') {\r\n      history.riskyChoiceCount++\r\n    }\r\n    history.totalChoiceCount++\r\n    \r\n    // Gameの内部プロパティを更新\r\n    ;(game as any)._playerHistory = history\r\n  }\r\n\r\n  /**\r\n   * リスクプロファイルを更新\r\n   * @private\r\n   */\r\n  private updateRiskProfile(game: Game): void {\r\n    const newProfile = this.premiumService.generateRiskProfile(\r\n      game.getPlayerHistory(),\r\n      game.stage\r\n    )\r\n    ;(game as any)._riskProfile = newProfile\r\n  }\r\n}","import type { GameStage, GamePhase, GameStatus } from '../types/game.types'\r\nimport type { Card } from '../entities/Card'\r\n\r\n/**\r\n * ゲーム状態の変更イベント\r\n */\r\nexport interface GameStateChangeEvent {\r\n  type: 'phase_change' | 'status_change' | 'stage_change' | 'turn_change'\r\n  previousValue: any\r\n  newValue: any\r\n  timestamp: number\r\n}\r\n\r\n/**\r\n * ゲーム状態変更の履歴管理\r\n */\r\nexport interface GameStateHistory {\r\n  events: GameStateChangeEvent[]\r\n  maxEvents: number\r\n}\r\n\r\n/**\r\n * ゲーム状態管理の専門サービス\r\n * \r\n * Single Responsibility: ゲーム状態の管理とイベント発行に特化\r\n * Open/Closed: 新しい状態タイプは拡張で対応\r\n */\r\nexport class GameStateManager {\r\n  private listeners: Map<string, Array<(event: GameStateChangeEvent) => void>> = new Map()\r\n  private history: GameStateHistory = {\r\n    events: [],\r\n    maxEvents: 50 // パフォーマンス考慮で制限\r\n  }\r\n\r\n  /**\r\n   * 状態変更イベントリスナーを登録\r\n   * \r\n   * @param eventType イベントタイプ\r\n   * @param listener リスナー関数\r\n   * @returns リスナー解除関数\r\n   */\r\n  addEventListener(\r\n    eventType: GameStateChangeEvent['type'],\r\n    listener: (event: GameStateChangeEvent) => void\r\n  ): () => void {\r\n    const existingListeners = this.listeners.get(eventType) || []\r\n    existingListeners.push(listener)\r\n    this.listeners.set(eventType, existingListeners)\r\n\r\n    // リスナー解除関数を返す\r\n    return () => {\r\n      const current = this.listeners.get(eventType) || []\r\n      const index = current.indexOf(listener)\r\n      if (index > -1) {\r\n        current.splice(index, 1)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 状態変更を通知し、履歴に記録\r\n   * \r\n   * @param type 変更タイプ\r\n   * @param previousValue 以前の値\r\n   * @param newValue 新しい値\r\n   */\r\n  notifyStateChange(\r\n    type: GameStateChangeEvent['type'],\r\n    previousValue: any,\r\n    newValue: any\r\n  ): void {\r\n    const event: GameStateChangeEvent = {\r\n      type,\r\n      previousValue,\r\n      newValue,\r\n      timestamp: Date.now()\r\n    }\r\n\r\n    // 履歴に追加\r\n    this.addToHistory(event)\r\n\r\n    // リスナーに通知\r\n    const listeners = this.listeners.get(type) || []\r\n    listeners.forEach(listener => {\r\n      try {\r\n        listener(event)\r\n      } catch (error) {\r\n        console.error(`GameStateManager: イベントリスナーでエラーが発生しました`, error)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * フェーズ変更を通知\r\n   */\r\n  notifyPhaseChange(previousPhase: GamePhase, newPhase: GamePhase): void {\r\n    this.notifyStateChange('phase_change', previousPhase, newPhase)\r\n  }\r\n\r\n  /**\r\n   * ステータス変更を通知\r\n   */\r\n  notifyStatusChange(previousStatus: GameStatus, newStatus: GameStatus): void {\r\n    this.notifyStateChange('status_change', previousStatus, newStatus)\r\n  }\r\n\r\n  /**\r\n   * ステージ変更を通知\r\n   */\r\n  notifyStageChange(previousStage: GameStage, newStage: GameStage): void {\r\n    this.notifyStateChange('stage_change', previousStage, newStage)\r\n  }\r\n\r\n  /**\r\n   * ターン変更を通知\r\n   */\r\n  notifyTurnChange(previousTurn: number, newTurn: number): void {\r\n    this.notifyStateChange('turn_change', previousTurn, newTurn)\r\n  }\r\n\r\n  /**\r\n   * 状態変更履歴を取得\r\n   */\r\n  getHistory(): GameStateHistory {\r\n    return { ...this.history }\r\n  }\r\n\r\n  /**\r\n   * 特定タイプのイベント履歴のみを取得\r\n   */\r\n  getHistoryByType(type: GameStateChangeEvent['type']): GameStateChangeEvent[] {\r\n    return this.history.events.filter(event => event.type === type)\r\n  }\r\n\r\n  /**\r\n   * 履歴をクリア\r\n   */\r\n  clearHistory(): void {\r\n    this.history.events = []\r\n  }\r\n\r\n  /**\r\n   * 履歴に追加（上限管理付き）\r\n   */\r\n  private addToHistory(event: GameStateChangeEvent): void {\r\n    this.history.events.push(event)\r\n    \r\n    // 上限を超えた場合は古いイベントを削除\r\n    if (this.history.events.length > this.history.maxEvents) {\r\n      this.history.events.shift()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 全リスナーを解除\r\n   */\r\n  removeAllListeners(): void {\r\n    this.listeners.clear()\r\n  }\r\n\r\n  /**\r\n   * 特定タイプのリスナーを解除\r\n   */\r\n  removeListenersForType(eventType: GameStateChangeEvent['type']): void {\r\n    this.listeners.delete(eventType)\r\n  }\r\n}","import type { Card } from '../entities/Card'\r\nimport type { ChallengeResult, TurnResult, InsuranceTypeSelectionResult } from '../types/game.types'\r\nimport type { Game } from '../entities/Game'\r\n\r\n/**\r\n * ゲームアクションの結果\r\n */\r\nexport interface ActionResult<T = any> {\r\n  success: boolean\r\n  data?: T\r\n  error?: string\r\n  effects?: GameEffect[]\r\n}\r\n\r\n/**\r\n * ゲーム効果\r\n */\r\nexport interface GameEffect {\r\n  type: 'vitality_change' | 'card_draw' | 'insurance_add' | 'stage_advance'\r\n  description: string\r\n  value?: number\r\n  cards?: Card[]\r\n}\r\n\r\n/**\r\n * アクション処理の抽象基底クラス\r\n * Template Method Pattern を使用\r\n */\r\nexport abstract class BaseActionProcessor<TInput, TOutput> {\r\n  /**\r\n   * アクション実行のテンプレートメソッド\r\n   */\r\n  async execute(game: Game, input: TInput): Promise<ActionResult<TOutput>> {\r\n    try {\r\n      // 前処理バリデーション\r\n      const validationResult = await this.validate(game, input)\r\n      if (!validationResult.success) {\r\n        return validationResult as ActionResult<TOutput>\r\n      }\r\n\r\n      // メイン処理\r\n      const result = await this.process(game, input)\r\n      \r\n      // 後処理\r\n      await this.postProcess(game, result)\r\n      \r\n      return result\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : String(error)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * バリデーション処理（サブクラスでオーバーライド）\r\n   */\r\n  protected async validate(game: Game, input: TInput): Promise<ActionResult<void>> {\r\n    return { success: true }\r\n  }\r\n\r\n  /**\r\n   * メイン処理（サブクラスで必須実装）\r\n   */\r\n  protected abstract process(game: Game, input: TInput): Promise<ActionResult<TOutput>>\r\n\r\n  /**\r\n   * 後処理（サブクラスでオーバーライド）\r\n   */\r\n  protected async postProcess(game: Game, result: ActionResult<TOutput>): Promise<void> {\r\n    // デフォルトは何もしない\r\n  }\r\n}\r\n\r\n/**\r\n * カードドロー処理\r\n */\r\nexport class DrawCardsProcessor extends BaseActionProcessor<number, Card[]> {\r\n  protected async validate(game: Game, count: number): Promise<ActionResult<void>> {\r\n    if (count <= 0) {\r\n      return { success: false, error: 'ドロー枚数は1以上である必要があります' }\r\n    }\r\n    \r\n    if (count > 10) {\r\n      return { success: false, error: 'ドロー枚数は10枚以下である必要があります' }\r\n    }\r\n    \r\n    return { success: true }\r\n  }\r\n\r\n  protected async process(game: Game, count: number): Promise<ActionResult<Card[]>> {\r\n    const drawnCards = game.drawCardsSync(count)\r\n    \r\n    return {\r\n      success: true,\r\n      data: drawnCards,\r\n      effects: [{\r\n        type: 'card_draw',\r\n        description: `${count}枚のカードをドローしました`,\r\n        cards: drawnCards\r\n      }]\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * チャレンジ開始処理\r\n */\r\nexport class StartChallengeProcessor extends BaseActionProcessor<Card, void> {\r\n  protected async validate(game: Game, challengeCard: Card): Promise<ActionResult<void>> {\r\n    if (game.phase !== 'draw') {\r\n      return { success: false, error: 'ドローフェーズでのみチャレンジを開始できます' }\r\n    }\r\n    \r\n    if (challengeCard.type !== 'challenge') {\r\n      return { success: false, error: 'チャレンジカード以外は選択できません' }\r\n    }\r\n    \r\n    return { success: true }\r\n  }\r\n\r\n  protected async process(game: Game, challengeCard: Card): Promise<ActionResult<void>> {\r\n    game.startChallenge(challengeCard)\r\n    \r\n    return {\r\n      success: true,\r\n      effects: [{\r\n        type: 'stage_advance',\r\n        description: `チャレンジ「${challengeCard.name}」を開始しました`\r\n      }]\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * チャレンジ解決処理\r\n */\r\nexport class ResolveChallengeProcessor extends BaseActionProcessor<void, ChallengeResult> {\r\n  protected async validate(game: Game, input: void): Promise<ActionResult<void>> {\r\n    if (!game.currentChallenge) {\r\n      return { success: false, error: 'アクティブなチャレンジがありません' }\r\n    }\r\n    \r\n    if (game.selectedCards.length === 0) {\r\n      return { success: false, error: 'カードが選択されていません' }\r\n    }\r\n    \r\n    return { success: true }\r\n  }\r\n\r\n  protected async process(game: Game, input: void): Promise<ActionResult<ChallengeResult>> {\r\n    const result = game.resolveChallenge()\r\n    \r\n    const effects: GameEffect[] = []\r\n    \r\n    if (result.success) {\r\n      effects.push({\r\n        type: 'vitality_change',\r\n        description: 'チャレンジに成功しました',\r\n        value: result.vitalityChange\r\n      })\r\n    } else {\r\n      effects.push({\r\n        type: 'vitality_change', \r\n        description: 'チャレンジに失敗しました',\r\n        value: result.vitalityChange\r\n      })\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      data: result,\r\n      effects\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 保険選択処理\r\n */\r\nexport class SelectInsuranceProcessor extends BaseActionProcessor<\r\n  { insuranceType: string; durationType: 'term' | 'whole_life' },\r\n  InsuranceTypeSelectionResult\r\n> {\r\n  protected async validate(\r\n    game: Game, \r\n    input: { insuranceType: string; durationType: 'term' | 'whole_life' }\r\n  ): Promise<ActionResult<void>> {\r\n    if (!input.insuranceType) {\r\n      return { success: false, error: '保険種類が指定されていません' }\r\n    }\r\n    \r\n    if (!['term', 'whole_life'].includes(input.durationType)) {\r\n      return { success: false, error: '無効な保険期間タイプです' }\r\n    }\r\n    \r\n    return { success: true }\r\n  }\r\n\r\n  protected async process(\r\n    game: Game,\r\n    input: { insuranceType: string; durationType: 'term' | 'whole_life' }\r\n  ): Promise<ActionResult<InsuranceTypeSelectionResult>> {\r\n    const result = game.selectInsuranceType(input.insuranceType, input.durationType)\r\n    \r\n    return {\r\n      success: true,\r\n      data: result,\r\n      effects: [{\r\n        type: 'insurance_add',\r\n        description: `${input.durationType === 'term' ? '定期' : '終身'}${input.insuranceType}保険を追加しました`\r\n      }]\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * アクション処理管理クラス\r\n */\r\nexport class GameActionProcessor {\r\n  private processors: Map<string, BaseActionProcessor<any, any>> = new Map()\r\n\r\n  constructor() {\r\n    // 標準プロセッサを登録\r\n    this.registerProcessor('draw_cards', new DrawCardsProcessor())\r\n    this.registerProcessor('start_challenge', new StartChallengeProcessor())\r\n    this.registerProcessor('resolve_challenge', new ResolveChallengeProcessor())\r\n    this.registerProcessor('select_insurance', new SelectInsuranceProcessor())\r\n  }\r\n\r\n  /**\r\n   * プロセッサを登録\r\n   */\r\n  registerProcessor<TInput, TOutput>(\r\n    actionType: string,\r\n    processor: BaseActionProcessor<TInput, TOutput>\r\n  ): void {\r\n    this.processors.set(actionType, processor)\r\n  }\r\n\r\n  /**\r\n   * アクションを実行\r\n   */\r\n  async executeAction<TInput, TOutput>(\r\n    actionType: string,\r\n    game: Game,\r\n    input: TInput\r\n  ): Promise<ActionResult<TOutput>> {\r\n    const processor = this.processors.get(actionType)\r\n    \r\n    if (!processor) {\r\n      return {\r\n        success: false,\r\n        error: `未知のアクションタイプ: ${actionType}`\r\n      }\r\n    }\r\n\r\n    return await processor.execute(game, input)\r\n  }\r\n\r\n  /**\r\n   * 登録されているアクションタイプ一覧を取得\r\n   */\r\n  getAvailableActions(): string[] {\r\n    return Array.from(this.processors.keys())\r\n  }\r\n\r\n  /**\r\n   * プロセッサを削除\r\n   */\r\n  unregisterProcessor(actionType: string): boolean {\r\n    return this.processors.delete(actionType)\r\n  }\r\n}","import type { GameStage, Difficulty, InsuranceType } from './card.types'\r\nimport type { Card } from '../entities/Card'\r\nimport type { Deck } from '../entities/Deck'\r\n\r\n/**\r\n * ゲーム状態\r\n */\r\nexport type GameStatus = \r\n  | 'not_started'\r\n  | 'in_progress'\r\n  | 'stage_clear'\r\n  | 'game_over'\r\n  | 'victory'\r\n\r\n/**\r\n * ゲームフェーズ\r\n */\r\nexport type GamePhase = \r\n  | 'setup'                    // セットアップ\r\n  | 'draw'                     // ドロー\r\n  | 'challenge'                // チャレンジ\r\n  | 'resolution'               // 結果処理\r\n  | 'card_selection'           // カード選択（チャレンジ成功時）\r\n  | 'insurance_type_selection' // 保険種類選択（チャレンジ成功時）\r\n  | 'upgrade'                  // アップグレード（ステージクリア時）\r\n  | 'end'                     // 終了\r\n\r\n/**\r\n * プレイヤー統計\r\n */\r\nexport interface PlayerStats {\r\n  totalChallenges: number\r\n  successfulChallenges: number\r\n  failedChallenges: number\r\n  cardsAcquired: number\r\n  highestVitality: number\r\n  turnsPlayed: number\r\n  // 分析・テスト用の追加統計\r\n  totalTurns?: number\r\n  score?: number\r\n  challengesCompleted?: number\r\n  challengesFailed?: number\r\n  finalVitality?: number\r\n  finalInsuranceBurden?: number\r\n}\r\n\r\n/**\r\n * ゲーム設定\r\n */\r\nexport interface GameConfig {\r\n  difficulty: Difficulty\r\n  startingVitality: number\r\n  startingHandSize: number\r\n  maxHandSize: number\r\n  dreamCardCount: number // 最終試練で選ぶ夢カードの数\r\n  // テスト・分析用の追加設定\r\n  maxTurns?: number\r\n}\r\n\r\n/**\r\n * 保険種類選択肢\r\n */\r\nexport interface InsuranceTypeChoice {\r\n  insuranceType: InsuranceType\r\n  name: string\r\n  description: string\r\n  baseCard: Omit<Card, 'id' | 'durationType' | 'remainingTurns'>\r\n  termOption: {\r\n    cost: number\r\n    duration: number // ターン数\r\n    description: string\r\n  }\r\n  wholeLifeOption: {\r\n    cost: number\r\n    description: string\r\n  }\r\n}\r\n\r\n/**\r\n * チャレンジ結果\r\n */\r\nexport interface ChallengeResult {\r\n  success: boolean\r\n  playerPower: number\r\n  challengePower: number\r\n  rewards?: Card[]\r\n  cardChoices?: Card[]  // カード選択肢（3枚）\r\n  insuranceTypeChoices?: InsuranceTypeChoice[]  // 保険種類選択肢（3種類）\r\n  vitalityChange: number\r\n  message: string\r\n  // Phase 3: パワー計算の詳細\r\n  powerBreakdown?: {\r\n    base: number\r\n    insurance: number\r\n    burden: number\r\n    total: number\r\n  }\r\n}\r\n\r\n/**\r\n * 保険期限切れ通知\r\n */\r\nexport interface InsuranceExpirationNotice {\r\n  expiredCards: Card[]\r\n  message: string\r\n  showRenewalOption: boolean\r\n  turnNumber: number\r\n}\r\n\r\n/**\r\n * ターン結果（期限切れ通知を含む）\r\n */\r\nexport interface TurnResult {\r\n  insuranceExpirations?: InsuranceExpirationNotice\r\n  newExpiredCount: number\r\n  remainingInsuranceCount: number\r\n}\r\n\r\n/**\r\n * 保険種類選択結果\r\n */\r\nexport interface InsuranceTypeSelectionResult {\r\n  success: boolean\r\n  selectedCard?: Card\r\n  message: string\r\n}\r\n\r\n/**\r\n * ゲーム状態\r\n */\r\n/**\r\n * 年齢別パラメータ\r\n */\r\nexport interface AgeParameters {\r\n  maxVitality: number\r\n  label: string\r\n  ageMultiplier: number  // 保険効果の年齢倍率\r\n}\r\n\r\n/**\r\n * 年齢別設定\r\n */\r\nexport const AGE_PARAMETERS: Record<GameStage, AgeParameters> = {\r\n  youth: { \r\n    maxVitality: 35, \r\n    label: '青年期',\r\n    ageMultiplier: 0\r\n  },\r\n  middle: { \r\n    maxVitality: 30, \r\n    label: '中年期',\r\n    ageMultiplier: 0.5\r\n  },\r\n  fulfillment: { \r\n    maxVitality: 27, \r\n    label: '充実期',\r\n    ageMultiplier: 1.0\r\n  }\r\n}\r\n\r\n/**\r\n * 夢カードの年齢調整値\r\n */\r\nexport const DREAM_AGE_ADJUSTMENTS = {\r\n  physical: 3,      // 体力系：年齢で+3パワー必要\r\n  intellectual: -2, // 知識系：年齢で-2パワー\r\n  mixed: 0         // 複合系：変化なし\r\n}\r\n\r\n\r\n\r\nexport interface IGameState {\r\n  id: string\r\n  status: GameStatus\r\n  phase: GamePhase\r\n  stage: GameStage\r\n  turn: number\r\n  vitality: number\r\n  maxVitality: number\r\n  \r\n  // デッキ関連\r\n  playerDeck: Deck\r\n  hand: Card[]\r\n  discardPile: Card[]\r\n  challengeDeck: Deck\r\n  \r\n  // チャレンジ関連\r\n  currentChallenge?: Card\r\n  selectedCards: Card[]\r\n  cardChoices?: Card[]  // 現在の選択肢カード\r\n  insuranceTypeChoices?: InsuranceTypeChoice[]  // 現在の保険種類選択肢\r\n  \r\n  // Phase 2-4: 保険カード管理\r\n  insuranceCards?: Card[]  // 現在有効な保険カード\r\n  expiredInsurances?: Card[]  // 期限切れになった保険カード\r\n  \r\n  // Phase 3: 保険料負担\r\n  insuranceBurden?: number  // 保険料による負担（負の値）\r\n  \r\n  \r\n  // 統計\r\n  stats: PlayerStats\r\n  \r\n  // 設定\r\n  config: GameConfig\r\n  \r\n  // タイムスタンプ\r\n  startedAt?: Date\r\n  completedAt?: Date\r\n}\r\n","/**\r\n * 活力を表す値オブジェクト\r\n * \r\n * このクラスはイミュータブルであり、すべての操作は新しいインスタンスを返します。\r\n * ビジネスルール：\r\n * - 活力は0以上100以下でなければならない\r\n */\r\nexport class Vitality {\r\n  private static readonly DEFAULT_MAX_VITALITY = 100\r\n\r\n  private constructor(\r\n    private readonly value: number,\r\n    private readonly maxVitality: number = Vitality.DEFAULT_MAX_VITALITY\r\n  ) {\r\n    this.validate()\r\n  }\r\n\r\n  /**\r\n   * Vitality インスタンスを生成する\r\n   * @param value 活力値\r\n   * @param maxVitality 最大活力値（デフォルト: 100）\r\n   * @throws {Error} 不正な値の場合\r\n   */\r\n  static create(value: number, maxVitality: number = Vitality.DEFAULT_MAX_VITALITY): Vitality {\r\n    return new Vitality(value, maxVitality)\r\n  }\r\n\r\n  /**\r\n   * 値の妥当性を検証する\r\n   * @private\r\n   */\r\n  private validate(): void {\r\n    if (this.maxVitality <= 0) {\r\n      throw new Error('Maximum vitality must be positive')\r\n    }\r\n    if (this.value < 0) {\r\n      throw new Error('Vitality value cannot be negative')\r\n    }\r\n    if (this.value > this.maxVitality) {\r\n      throw new Error(`Vitality value cannot exceed maximum (${this.maxVitality})`)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 現在の活力値を取得\r\n   */\r\n  getValue(): number {\r\n    return this.value\r\n  }\r\n\r\n  /**\r\n   * 最大活力値を取得\r\n   */\r\n  getMax(): number {\r\n    return this.maxVitality\r\n  }\r\n\r\n  /**\r\n   * 活力を減少させる\r\n   * @param amount 減少量\r\n   * @returns 新しいVitalityインスタンス\r\n   * @throws {Error} 減少量が負の場合\r\n   */\r\n  decrease(amount: number): Vitality {\r\n    if (amount < 0) {\r\n      throw new Error('Decrease amount must be non-negative')\r\n    }\r\n    return new Vitality(Math.max(0, this.value - amount), this.maxVitality)\r\n  }\r\n\r\n  /**\r\n   * 活力を増加させる\r\n   * @param amount 増加量\r\n   * @returns 新しいVitalityインスタンス\r\n   * @throws {Error} 増加量が負の場合\r\n   */\r\n  increase(amount: number): Vitality {\r\n    if (amount < 0) {\r\n      throw new Error('Increase amount must be non-negative')\r\n    }\r\n    return new Vitality(Math.min(this.maxVitality, this.value + amount), this.maxVitality)\r\n  }\r\n\r\n  /**\r\n   * パーセンテージを取得（0-100）\r\n   */\r\n  getPercentage(): number {\r\n    return Math.floor((this.value / this.maxVitality) * 100)\r\n  }\r\n\r\n  /**\r\n   * 活力が枯渇しているか判定\r\n   */\r\n  isDepleted(): boolean {\r\n    return this.value === 0\r\n  }\r\n\r\n  /**\r\n   * 活力が満タンか判定\r\n   */\r\n  isFull(): boolean {\r\n    return this.value === this.maxVitality\r\n  }\r\n\r\n  /**\r\n   * 最大活力値を変更したVitalityインスタンスを作成\r\n   * 現在の活力値が新しい最大値を超える場合は最大値に調整\r\n   * @param newMaxVitality 新しい最大活力値\r\n   * @returns 新しいVitalityインスタンス\r\n   */\r\n  withMaxVitality(newMaxVitality: number): Vitality {\r\n    const adjustedValue = Math.min(this.value, newMaxVitality)\r\n    return new Vitality(adjustedValue, newMaxVitality)\r\n  }\r\n\r\n  /**\r\n   * 他のVitalityインスタンスと等価か判定\r\n   */\r\n  equals(other: Vitality): boolean {\r\n    return this.value === other.value && this.maxVitality === other.maxVitality\r\n  }\r\n\r\n  /**\r\n   * 文字列表現を取得\r\n   */\r\n  toString(): string {\r\n    return `${this.value}/${this.maxVitality} (${this.getPercentage()}%)`\r\n  }\r\n}","import type { Card } from './Card'\r\nimport { Deck } from './Deck'\r\nimport { CardFactory } from '../services/CardFactory'\r\nimport { CardManager, type ICardManager } from '../services/CardManager'\r\nimport { InsurancePremiumCalculationService } from '../services/InsurancePremiumCalculationService'\r\nimport { GameStageManager } from '../services/GameStageManager'\r\nimport { InsuranceExpirationManager } from '../services/InsuranceExpirationManager'\r\nimport { ChallengeResolutionService } from '../services/ChallengeResolutionService'\r\nimport { GameTurnManager } from '../services/GameTurnManager'\r\nimport { GameChallengeService } from '../services/GameChallengeService'\r\nimport { GameInsuranceService } from '../services/GameInsuranceService'\r\nimport { GameStateManager } from '../services/GameStateManager'\r\nimport { GameActionProcessor } from '../services/GameActionProcessor'\r\nimport { IdGenerator } from '../../common/IdGenerator'\r\nimport type {\r\n  IGameState,\r\n  GameStatus,\r\n  GamePhase,\r\n  GameConfig,\r\n  PlayerStats,\r\n  ChallengeResult,\r\n  TurnResult,\r\n  InsuranceExpirationNotice,\r\n  InsuranceTypeChoice,\r\n  InsuranceTypeSelectionResult\r\n} from '../types/game.types'\r\nimport { DREAM_AGE_ADJUSTMENTS, AGE_PARAMETERS } from '../types/game.types'\r\nimport type { GameStage } from '../types/card.types'\r\nimport { Vitality } from '../valueObjects/Vitality'\r\nimport { InsurancePremium } from '../valueObjects/InsurancePremium'\r\nimport { RiskProfile } from '../valueObjects/RiskFactor'\r\nimport type { PlayerHistory } from '../services/InsurancePremiumCalculationService'\r\n\r\n/**\r\n * ゲームエンティティ - ゲーム全体の状態と進行を管理する中核クラス\r\n * \r\n * このクラスは値オブジェクトを使用してゲーム状態を管理します：\r\n * - vitality: Vitality値オブジェクトで管理（プレイヤーの活力）\r\n * - insuranceBurden: InsurancePremium値オブジェクトで管理（保険料負担）\r\n * \r\n * @implements {IGameState} ゲーム状態のインターフェース\r\n * \r\n * @example\r\n * // ゲームの初期化\r\n * const config = { startingVitality: 20, maxHandSize: 7 };\r\n * const game = new Game(config);\r\n * game.start();\r\n * \r\n * // ターンの進行\r\n * game.drawCards(5);\r\n * const challenge = game.challengeDeck.drawCard();\r\n * game.startChallenge(challenge);\r\n */\r\nexport class Game implements IGameState {\r\n  id: string\r\n  status: GameStatus\r\n  phase: GamePhase\r\n  stage: GameStage\r\n  turn: number\r\n  private _vitality: Vitality\r\n  \r\n  // カード管理を移譲\r\n  public cardManager: ICardManager\r\n  \r\n  // ドメインサービス\r\n  private premiumCalculationService: InsurancePremiumCalculationService\r\n  private stageManager: GameStageManager\r\n  private expirationManager: InsuranceExpirationManager\r\n  private challengeResolutionService: ChallengeResolutionService\r\n  private turnManager: GameTurnManager\r\n  private challengeService: GameChallengeService\r\n  private insuranceService: GameInsuranceService\r\n  \r\n  // 新しいアーキテクチャ\r\n  private stateManager: GameStateManager\r\n  private actionProcessor: GameActionProcessor\r\n  \r\n  currentChallenge?: Card\r\n  \r\n  stats: PlayerStats\r\n  config: GameConfig\r\n  \r\n  // Phase 5: リスクプロファイルとプレイヤー履歴\r\n  private _riskProfile: RiskProfile\r\n  private _playerHistory: PlayerHistory\r\n  \r\n  // Phase 2-4: 保険カード管理\r\n  insuranceCards: Card[]\r\n  expiredInsurances: Card[]\r\n  \r\n  // Phase 3: 保険料負担\r\n  private _insuranceBurden: InsurancePremium\r\n  \r\n  // 保険種類選択\r\n  insuranceTypeChoices?: InsuranceTypeChoice[]\r\n  \r\n  // パフォーマンス最適化: オブジェクトプール\r\n  private static readonly OBJECT_POOLS = {\r\n    cards: [] as Card[],\r\n    gameStates: [] as Partial<IGameState>[],\r\n    challengeResults: [] as Partial<ChallengeResult>[]\r\n  }\r\n\r\n  // ダーティフラグシステムの導入\r\n  private _dirtyFlags = {\r\n    vitality: false,\r\n    insurance: false,\r\n    burden: false,\r\n    stats: false,\r\n    gameState: false\r\n  }\r\n\r\n  // キャッシュシステム\r\n  private _cachedValues = {\r\n    insuranceBurden: 0,\r\n    availableVitality: 0,\r\n    totalInsuranceCount: 0,\r\n    lastUpdateTime: 0\r\n  }\r\n  \r\n  startedAt?: Date\r\n  completedAt?: Date\r\n\r\n  /**\r\n   * Gameインスタンスを作成\r\n   * @param {GameConfig} [config] - ゲーム設定（オプション）\r\n   * @param {string} [config.difficulty='normal'] - 難易度\r\n   * @param {number} [config.startingVitality=100] - 初期活力\r\n   * @param {number} [config.startingHandSize=5] - 初期手札枚数\r\n   * @param {number} [config.maxHandSize=10] - 最大手札枚数\r\n   * @param {number} [config.dreamCardCount=3] - 夢カード枚数\r\n   */\r\n  constructor(config?: GameConfig) {\r\n    this.id = this.generateId()\r\n    this.status = 'not_started'\r\n    this.phase = 'setup'\r\n    this.stage = 'youth'\r\n    this.turn = 0\r\n    \r\n    // 値オブジェクトで初期化（年齢別最大活力を適用）\r\n    const startingVitality = config?.startingVitality ?? 100\r\n    const maxVitality = AGE_PARAMETERS[this.stage].maxVitality\r\n    this._vitality = Vitality.create(Math.min(startingVitality, maxVitality), maxVitality)\r\n    \r\n    // CardManagerを初期化\r\n    this.cardManager = new CardManager()\r\n    \r\n    // ドメインサービスを初期化\r\n    this.premiumCalculationService = new InsurancePremiumCalculationService()\r\n    this.stageManager = new GameStageManager()\r\n    this.expirationManager = new InsuranceExpirationManager()\r\n    this.challengeResolutionService = new ChallengeResolutionService()\r\n    this.turnManager = new GameTurnManager(this.stageManager, this.expirationManager)\r\n    this.challengeService = new GameChallengeService(this.challengeResolutionService)\r\n    this.insuranceService = new GameInsuranceService(this.premiumCalculationService)\r\n    \r\n    // 新しいアーキテクチャを初期化\r\n    this.stateManager = new GameStateManager()\r\n    this.actionProcessor = new GameActionProcessor()\r\n    \r\n    // 状態変更イベントの監視を設定\r\n    this.setupStateListeners()\r\n    const playerDeck = new Deck('Player Deck')\r\n    const challengeDeck = new Deck('Challenge Deck')\r\n    \r\n    // 初期デッキを作成\r\n    const initialCards = CardFactory.createStarterLifeCards()\r\n    initialCards.forEach(card => playerDeck.addCard(card))\r\n    \r\n    // チャレンジデッキを作成\r\n    const challengeCards = CardFactory.createChallengeCards(this.stage)\r\n    challengeCards.forEach(card => challengeDeck.addCard(card))\r\n    \r\n    this.cardManager.initialize(playerDeck, challengeDeck, config)\r\n    \r\n    this.stats = {\r\n      totalChallenges: 0,\r\n      successfulChallenges: 0,\r\n      failedChallenges: 0,\r\n      cardsAcquired: 0,\r\n      highestVitality: startingVitality,\r\n      turnsPlayed: 0\r\n    }\r\n    \r\n    // Phase 5: リスクプロファイルと履歴の初期化\r\n    this._riskProfile = RiskProfile.default()\r\n    this._playerHistory = {\r\n      turnsPlayed: 0,\r\n      totalDamageTaken: 0,\r\n      insuranceClaimCount: 0,\r\n      totalInsurancePurchased: 0,\r\n      riskyChoiceCount: 0,\r\n      totalChoiceCount: 0\r\n    }\r\n    \r\n    this.config = config || {\r\n      difficulty: 'normal',\r\n      startingVitality,\r\n      startingHandSize: 5,\r\n      maxHandSize: 10,\r\n      dreamCardCount: 3\r\n    }\r\n    \r\n    // Phase 2-4: 保険カード管理の初期化\r\n    this.insuranceCards = []\r\n    this.expiredInsurances = []\r\n    \r\n    // Phase 3: 保険料負担の初期化\r\n    this._insuranceBurden = InsurancePremium.create(0)\r\n    \r\n  }\r\n\r\n  /**\r\n   * 後方互換性のためのgetter - 現在の活力値を取得\r\n   * @returns {number} 現在の活力値\r\n   */\r\n  get vitality(): number {\r\n    return this._vitality.getValue()\r\n  }\r\n\r\n  /**\r\n   * 最大活力値を取得\r\n   * @returns {number} 最大活力値\r\n   */\r\n  get maxVitality(): number {\r\n    return this._vitality.getMax()\r\n  }\r\n\r\n  /**\r\n   * 現在の保険料負担を取得\r\n   * @returns {number} 保険料負担額\r\n   */\r\n  get insuranceBurden(): number {\r\n    return this._insuranceBurden.getValue()\r\n  }\r\n\r\n  /**\r\n   * 値オブジェクトとしての活力取得\r\n   * @returns {Vitality} 活力値オブジェクト\r\n   */\r\n  getVitality(): Vitality {\r\n    return this._vitality\r\n  }\r\n\r\n  /**\r\n   * 値オブジェクトとしての保険料負担取得\r\n   * @returns {InsurancePremium} 保険料負担値オブジェクト\r\n   */\r\n  getInsuranceBurden(): InsurancePremium {\r\n    return this._insuranceBurden\r\n  }\r\n\r\n  /**\r\n   * ダメージを適用して活力を減少させる\r\n   * @param {number} damage - 適用するダメージ量\r\n   * @throws {Error} ダメージが負の値の場合\r\n   */\r\n  applyDamage(damage: number): void {\r\n    this.updateVitality(-damage)\r\n  }\r\n\r\n  /**\r\n   * 体力を回復させる\r\n   * @param {number} amount - 回復量\r\n   * @throws {Error} 回復量が負の値の場合\r\n   */\r\n  heal(amount: number): void {\r\n    this.updateVitality(amount)\r\n  }\r\n\r\n  /**\r\n   * 現在のリスクプロファイルを取得\r\n   * @returns {RiskProfile} リスクプロファイル\r\n   */\r\n  getRiskProfile(): RiskProfile {\r\n    return this._riskProfile\r\n  }\r\n\r\n  /**\r\n   * プレイヤー履歴を取得\r\n   * @returns {PlayerHistory} プレイヤー履歴\r\n   */\r\n  getPlayerHistory(): PlayerHistory {\r\n    return { ...this._playerHistory }\r\n  }\r\n\r\n  /**\r\n   * 利用可能体力を取得（保険料負担を考慮）\r\n   * キャッシュによる最適化版\r\n   * @returns {number} 保険料負担を差し引いた実質的な利用可能体力\r\n   */\r\n  getAvailableVitality(): number {\r\n    const currentTime = Date.now()\r\n    \r\n    // キャッシュが有効な場合（50ms以内）は計算をスキップ\r\n    if (!this._dirtyFlags.vitality && !this._dirtyFlags.burden && \r\n        currentTime - this._cachedValues.lastUpdateTime < 50) {\r\n      return this._cachedValues.availableVitality\r\n    }\r\n    \r\n    const result = this.vitality - this.insuranceBurden\r\n    \r\n    // キャッシュを更新\r\n    this._cachedValues.availableVitality = result\r\n    this._cachedValues.lastUpdateTime = currentTime\r\n    this._dirtyFlags.vitality = false\r\n    this._dirtyFlags.burden = false\r\n    \r\n    return result\r\n  }\r\n\r\n  /**\r\n   * ゲームオーバーかどうか判定\r\n   * @returns {boolean} ゲームオーバーの場合true\r\n   */\r\n  isGameOver(): boolean {\r\n    return this.status === 'game_over' || this._vitality.isDepleted()\r\n  }\r\n\r\n  /**\r\n   * 保険を追加（簡易版テスト用）\r\n   * @param {Card} card - 追加する保険カード\r\n   * @throws {Error} 保険カード以外が渡された場合\r\n   */\r\n  addInsurance(card: Card): void {\r\n    this.insuranceService.addInsurance(this, card)\r\n  }\r\n\r\n  /**\r\n   * ゲームIDを生成\r\n   * @returns {string} ユニークなゲームID\r\n   * @private\r\n   */\r\n  private generateId(): string {\r\n    return IdGenerator.generateGameId()\r\n  }\r\n\r\n  /**\r\n   * ゲームを開始する\r\n   * @throws {Error} 既にゲームが開始されている場合\r\n   */\r\n  start(): void {\r\n    if (this.status !== 'not_started') {\r\n      throw new Error('Game has already started')\r\n    }\r\n    \r\n    this.changeStatus('in_progress')\r\n    this.startedAt = new Date()\r\n    this.changePhase('draw')\r\n    this.changeTurn(1)\r\n  }\r\n\r\n  /**\r\n   * カードをドローする（リファクタリング版）\r\n   * @param {number} count - ドローする枚数\r\n   * @returns {Promise<Card[]>} ドローしたカードの配列\r\n   */\r\n  async drawCards(count: number): Promise<Card[]> {\r\n    const result = await this.actionProcessor.executeAction('draw_cards', this, count)\r\n    \r\n    if (!result.success) {\r\n      throw new Error(result.error || 'カードドローに失敗しました')\r\n    }\r\n    \r\n    return result.data || []\r\n  }\r\n\r\n  /**\r\n   * カードをドローする（後方互換版）\r\n   * @param {number} count - ドローする枚数\r\n   * @returns {Card[]} ドローしたカードの配列\r\n   * @deprecated 新しいdrawCardsメソッドを使用してください\r\n   */\r\n  drawCardsSync(count: number): Card[] {\r\n    const result = this.cardManager.drawCards(count)\r\n    return result.drawnCards\r\n  }\r\n\r\n\r\n  /**\r\n   * チャレンジを開始する\r\n   * @param {Card} challengeCard - 挑戦するチャレンジカード\r\n   * @throws {Error} ドローフェーズ以外で実行された場合\r\n   */\r\n  startChallenge(challengeCard: Card): void {\r\n    this.challengeService.startChallenge(this, challengeCard)\r\n  }\r\n\r\n  /**\r\n   * カードを選択/選択解除する\r\n   * @param {Card} card - 選択/解除するカード\r\n   * @returns {boolean} 選択状態（true:選択、false:解除）\r\n   */\r\n  toggleCardSelection(card: Card): boolean {\r\n    return this.cardManager.toggleCardSelection(card)\r\n  }\r\n\r\n  /**\r\n   * チャレンジを解決し、結果を返す\r\n   * @returns {ChallengeResult} チャレンジの結果\r\n   * @throws {Error} アクティブなチャレンジがない場合\r\n   */\r\n  resolveChallenge(): ChallengeResult {\r\n    return this.challengeService.resolveChallenge(this)\r\n  }\r\n\r\n  /**\r\n   * カードを選択してデッキに追加（従来のカード選択フェーズ用）\r\n   */\r\n  selectCard(cardId: string): boolean {\r\n    if (this.phase !== 'card_selection') {\r\n      throw new Error('Not in card selection phase')\r\n    }\r\n    \r\n    const selectedCard = this.cardManager.getCardChoiceById(cardId)\r\n    if (!selectedCard) {\r\n      throw new Error('Invalid card selection')\r\n    }\r\n    \r\n    // カードをデッキに追加\r\n    this.cardManager.addToPlayerDeck(selectedCard)\r\n    this.stats.cardsAcquired++\r\n    \r\n    // Phase 2-4: 保険カードの場合は管理リストに追加\r\n    if (selectedCard.type === 'insurance') {\r\n      this.insuranceCards.push(selectedCard)\r\n      // Phase 3: 保険料負担を更新\r\n      this.updateInsuranceBurden()\r\n    }\r\n    \r\n    // 選択肢をクリア\r\n    this.cardManager.clearCardChoices()\r\n    \r\n    // 解決フェーズに移行（ターン終了可能状態）\r\n    this.changePhase('resolution')\r\n    \r\n    return true\r\n  }\r\n\r\n  /**\r\n   * 保険種類を選択してカードを作成・追加\r\n   */\r\n  selectInsuranceType(insuranceType: string, durationType: 'term' | 'whole_life'): InsuranceTypeSelectionResult {\r\n    return this.insuranceService.selectInsuranceType(this, insuranceType, durationType)\r\n  }\r\n\r\n  /**\r\n   * 活力を更新（最適化版）\r\n   */\r\n  private updateVitality(change: number): void {\r\n    // 変更がない場合は処理をスキップ\r\n    if (change === 0) return\r\n    \r\n    if (change >= 0) {\r\n      this._vitality = this._vitality.increase(change)\r\n    } else {\r\n      this._vitality = this._vitality.decrease(-change)\r\n    }\r\n    \r\n    // ダーティフラグを設定\r\n    this._dirtyFlags.vitality = true\r\n    this._dirtyFlags.stats = true\r\n    \r\n    // 統計更新\r\n    const currentVitality = this.vitality\r\n    if (currentVitality > this.stats.highestVitality) {\r\n      this.stats.highestVitality = currentVitality\r\n    }\r\n    \r\n    // ダメージ履歴を記録\r\n    if (change < 0) {\r\n      this._playerHistory.totalDamageTaken += Math.abs(change)\r\n    }\r\n    \r\n    // ゲームオーバー判定\r\n    if (this._vitality.isDepleted()) {\r\n      this.changeStatus('game_over')\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * ステージに応じて活力上限を更新\r\n   * 年齢が上がるにつれて最大活力が減少し、現実的な体力変化を反映\r\n   */\r\n  private updateMaxVitalityForAge(): void {\r\n    const ageParams = AGE_PARAMETERS[this.stage]\r\n    const newMaxVitality = ageParams.maxVitality\r\n    \r\n    // 現在の活力値が新しい上限を超える場合は調整\r\n    const currentValue = this._vitality.getValue()\r\n    if (currentValue > newMaxVitality) {\r\n      console.log(`🔄 ${ageParams.label}に移行: 活力上限が${newMaxVitality}に調整されました`)\r\n      this._vitality = this._vitality.withMaxVitality(newMaxVitality)\r\n    } else {\r\n      // 上限のみ更新（現在値はそのまま）\r\n      this._vitality = Vitality.create(currentValue, newMaxVitality)\r\n    }\r\n    \r\n    // ダーティフラグを設定\r\n    this._dirtyFlags.vitality = true\r\n  }\r\n\r\n  /**\r\n   * 次のターンへ\r\n   */\r\n  nextTurn(): TurnResult {\r\n    return this.turnManager.nextTurn(this)\r\n  }\r\n\r\n\r\n  /**\r\n   * ステージを進める（手動用）\r\n   */\r\n  advanceStage(): void {\r\n    const advanceResult = this.stageManager.advanceStage(this.stage)\r\n    \r\n    if (advanceResult.isCompleted) {\r\n      // 最終ステージクリア\r\n      this.changeStatus('victory')\r\n    } else if (advanceResult.newStage) {\r\n      this.changeStage(advanceResult.newStage)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 手札を取得\r\n   */\r\n  get hand(): Card[] {\r\n    return this.cardManager.getState().hand\r\n  }\r\n\r\n  /**\r\n   * 捨て札を取得\r\n   */\r\n  get discardPile(): Card[] {\r\n    return this.cardManager.getState().discardPile\r\n  }\r\n\r\n  /**\r\n   * プレイヤーデッキを取得\r\n   */\r\n  get playerDeck(): Deck {\r\n    return this.cardManager.getState().playerDeck\r\n  }\r\n\r\n  /**\r\n   * チャレンジデッキを取得\r\n   */\r\n  get challengeDeck(): Deck {\r\n    return this.cardManager.getState().challengeDeck\r\n  }\r\n\r\n  /**\r\n   * 選択中のカードを取得\r\n   */\r\n  get selectedCards(): Card[] {\r\n    return this.cardManager.getState().selectedCards\r\n  }\r\n\r\n  /**\r\n   * カード選択肢を取得\r\n   */\r\n  get cardChoices(): Card[] | undefined {\r\n    return this.cardManager.getState().cardChoices\r\n  }\r\n\r\n  /**\r\n   * 保険種類選択肢を取得\r\n   */\r\n  get currentInsuranceTypeChoices(): InsuranceTypeChoice[] | undefined {\r\n    return this.insuranceTypeChoices\r\n  }\r\n\r\n  /**\r\n   * ゲームが進行中かどうか\r\n   */\r\n  isInProgress(): boolean {\r\n    return this.status === 'in_progress'\r\n  }\r\n\r\n  /**\r\n   * ゲームが終了しているかどうか\r\n   */\r\n  isCompleted(): boolean {\r\n    return this.status === 'game_over' || this.status === 'victory'\r\n  }\r\n\r\n  /**\r\n   * Phase 4: 夢カードの必要パワーを年齢調整込みで計算\r\n   */\r\n  getDreamRequiredPower(challenge: Card): number {\r\n    // 夢カードでない場合は基本パワーをそのまま返す\r\n    if (!challenge.isDreamCard() || !challenge.dreamCategory) {\r\n      return challenge.power\r\n    }\r\n    \r\n    // 青年期は調整なし\r\n    if (this.stage === 'youth') {\r\n      return challenge.power\r\n    }\r\n    \r\n    // 中年期・充実期の年齢調整を適用\r\n    const adjustment = DREAM_AGE_ADJUSTMENTS[challenge.dreamCategory]\r\n    const adjustedPower = challenge.power + adjustment\r\n    \r\n    // 最小値は1\r\n    return Math.max(1, adjustedPower)\r\n  }\r\n\r\n  /**\r\n   * Phase 2-4: 期限切れの保険カードを取得（通知用）\r\n   */\r\n  getExpiredInsurances(): Card[] {\r\n    return [...this.expiredInsurances]\r\n  }\r\n\r\n  /**\r\n   * Phase 2-4: 期限切れ通知をクリア\r\n   */\r\n  clearExpiredInsurances(): void {\r\n    this.expiredInsurances = []\r\n  }\r\n\r\n  /**\r\n   * 期限が近い保険カードを取得（残り2ターン以下）\r\n   */\r\n  getExpiringsSoonInsurances(): Card[] {\r\n    return this.expirationManager.getExpiringSoonInsurances(this.insuranceCards)\r\n  }\r\n\r\n  /**\r\n   * 保険期限切れの警告メッセージを取得\r\n   */\r\n  getExpirationWarnings(): string[] {\r\n    return this.expirationManager.getExpirationWarnings(this.insuranceCards)\r\n  }\r\n\r\n  /**\r\n   * ステージを設定（内部使用）\r\n   */\r\n  setStage(stage: GameStage): void {\r\n    this.changeStage(stage)\r\n  }\r\n\r\n  /**\r\n   * Phase 2-4: 現在有効な保険カードを取得\r\n   */\r\n  getActiveInsurances(): Card[] {\r\n    return [...this.insuranceCards]\r\n  }\r\n\r\n  /**\r\n   * プレイヤーに最適な保険予算を提案\r\n   * \r\n   * @param riskProfile リスクプロファイル\r\n   * @returns 推奨保険予算\r\n   */\r\n  getRecommendedInsuranceBudget(riskProfile: 'conservative' | 'balanced' | 'aggressive' = 'balanced'): InsurancePremium {\r\n    return this.premiumCalculationService.calculateOptimalInsuranceBudget(\r\n      this.vitality,\r\n      this.stage,\r\n      riskProfile\r\n    )\r\n  }\r\n\r\n  /**\r\n   * 特定の保険カードの総合保険料を取得\r\n   * \r\n   * @param card 保険カード\r\n   * @returns 年齢・種別・リスク調整済み保険料\r\n   */\r\n  calculateCardPremium(card: Card): InsurancePremium {\r\n    if (card.type !== 'insurance') {\r\n      throw new Error('Card must be an insurance card')\r\n    }\r\n    \r\n    return this.premiumCalculationService.calculateComprehensivePremium(card, this.stage, this._riskProfile)\r\n  }\r\n\r\n  /**\r\n   * Phase 3: 保険料負担を計算（最適化版）\r\n   * \r\n   * キャッシュとダーティフラグによる高速化\r\n   */\r\n  calculateInsuranceBurden(): number {\r\n    const currentTime = Date.now()\r\n    \r\n    // キャッシュが有効で保険状態が変わっていない場合は再計算をスキップ\r\n    if (!this._dirtyFlags.insurance && \r\n        currentTime - this._cachedValues.lastUpdateTime < 100 &&\r\n        this._cachedValues.totalInsuranceCount === this.insuranceCards.length) {\r\n      return this._cachedValues.insuranceBurden\r\n    }\r\n    \r\n    const burden = this.insuranceService.calculateInsuranceBurden(this)\r\n    \r\n    // キャッシュを更新\r\n    this._cachedValues.insuranceBurden = burden\r\n    this._cachedValues.totalInsuranceCount = this.insuranceCards.length\r\n    this._cachedValues.lastUpdateTime = currentTime\r\n    this._dirtyFlags.insurance = false\r\n    \r\n    return burden\r\n  }\r\n\r\n  /**\r\n   * Phase 3: 保険料負担を更新（最適化版）\r\n   */\r\n  private updateInsuranceBurden(): void {\r\n    this.insuranceService.updateInsuranceBurden(this)\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Phase 3: 総合パワーを詳細に計算\r\n   * @param cards 使用するカード\r\n   * @returns パワーの詳細な内訳\r\n   */\r\n  calculateTotalPower(cards: Card[]): {\r\n    base: number\r\n    insurance: number\r\n    burden: number\r\n    total: number\r\n  } {\r\n    return this.challengeService.calculateTotalPower(this, cards)\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  /**\r\n   * テスト用: カードを手札に直接追加\r\n   */\r\n  addCardToHand(card: Card): void {\r\n    this.cardManager.addToHand(card)\r\n  }\r\n\r\n  /**\r\n   * テスト用: カードを捨て札に直接追加\r\n   */\r\n  addCardToDiscardPile(card: Card): void {\r\n    this.cardManager.addToDiscardPile(card)\r\n  }\r\n\r\n  /**\r\n   * テスト用: プレイヤーデッキにカードを追加\r\n   */\r\n  addCardToPlayerDeck(card: Card): void {\r\n    this.cardManager.addToPlayerDeck(card)\r\n  }\r\n\r\n  /**\r\n   * テスト用: 手札をクリア\r\n   */\r\n  clearHand(): void {\r\n    const state = this.cardManager.getState()\r\n    state.hand = []\r\n    this.cardManager.setState(state)\r\n  }\r\n\r\n  /**\r\n   * テスト用: 手札を設定\r\n   */\r\n  setHand(cards: Card[]): void {\r\n    const state = this.cardManager.getState()\r\n    state.hand = [...cards]\r\n    this.cardManager.setState(state)\r\n  }\r\n\r\n  /**\r\n   * テスト用: カード選択肢を設定\r\n   */\r\n  setCardChoices(choices: Card[]): void {\r\n    this.cardManager.setCardChoices(choices)\r\n  }\r\n\r\n  /**\r\n   * テスト用: フェーズを設定\r\n   */\r\n  setPhase(phase: GamePhase): void {\r\n    this.changePhase(phase)\r\n  }\r\n\r\n\r\n  /**\r\n   * ゲーム状態のスナップショットを取得（最適化版）\r\n   */\r\n  getSnapshot(): IGameState {\r\n    const cardState = this.cardManager.getState()\r\n    \r\n    // オブジェクトプールから再利用可能なオブジェクトを取得\r\n    let snapshot = Game.OBJECT_POOLS.gameStates.pop()\r\n    \r\n    if (!snapshot) {\r\n      snapshot = {}\r\n    }\r\n    \r\n    // プロパティを設定（浅いコピーで済む部分は浅く）\r\n    Object.assign(snapshot, {\r\n      id: this.id,\r\n      status: this.status,\r\n      phase: this.phase,\r\n      stage: this.stage,\r\n      turn: this.turn,\r\n      vitality: this.vitality,\r\n      maxVitality: this.maxVitality,\r\n      playerDeck: cardState.playerDeck,\r\n      hand: cardState.hand,\r\n      discardPile: cardState.discardPile,\r\n      challengeDeck: cardState.challengeDeck,\r\n      currentChallenge: this.currentChallenge,\r\n      selectedCards: cardState.selectedCards,\r\n      cardChoices: cardState.cardChoices,\r\n      insuranceTypeChoices: this.insuranceTypeChoices,\r\n      insuranceCards: [...this.insuranceCards],\r\n      expiredInsurances: [...this.expiredInsurances],\r\n      insuranceBurden: this.insuranceBurden,\r\n      stats: { ...this.stats },\r\n      config: { ...this.config },\r\n      startedAt: this.startedAt,\r\n      completedAt: this.completedAt\r\n    })\r\n    \r\n    return snapshot as IGameState\r\n  }\r\n\r\n  /**\r\n   * 状態変更イベントリスナーを設定\r\n   * Observer Pattern の実装\r\n   */\r\n  private setupStateListeners(): void {\r\n    // フェーズ変更の監視\r\n    this.stateManager.addEventListener('phase_change', (event) => {\r\n      console.log(`🎯 フェーズ変更: ${event.previousValue} → ${event.newValue}`)\r\n      this.handlePhaseChange(event.previousValue, event.newValue)\r\n    })\r\n\r\n    // ステージ変更の監視\r\n    this.stateManager.addEventListener('stage_change', (event) => {\r\n      console.log(`🚀 ステージ変更: ${event.previousValue} → ${event.newValue}`)\r\n      this.updateMaxVitalityForAge()\r\n    })\r\n\r\n    // ターン変更の監視\r\n    this.stateManager.addEventListener('turn_change', (event) => {\r\n      console.log(`⏰ ターン変更: ${event.previousValue} → ${event.newValue}`)\r\n      this.stats.turnsPlayed = event.newValue\r\n    })\r\n\r\n    // ステータス変更の監視\r\n    this.stateManager.addEventListener('status_change', (event) => {\r\n      console.log(`📊 ステータス変更: ${event.previousValue} → ${event.newValue}`)\r\n      \r\n      if (event.newValue === 'game_over' || event.newValue === 'victory') {\r\n        this.completedAt = new Date()\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * フェーズ変更のハンドリング\r\n   */\r\n  private handlePhaseChange(previousPhase: GamePhase, newPhase: GamePhase): void {\r\n    switch (newPhase) {\r\n      case 'draw':\r\n        // ドローフェーズ開始時の処理\r\n        break\r\n      case 'challenge':\r\n        // チャレンジフェーズ開始時の処理\r\n        break\r\n      case 'card_selection':\r\n        // カード選択フェーズ開始時の処理\r\n        break\r\n      case 'resolution':\r\n        // 解決フェーズ開始時の処理\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * フェーズを安全に変更\r\n   */\r\n  private changePhase(newPhase: GamePhase): void {\r\n    const previousPhase = this.phase\r\n    this.phase = newPhase\r\n    this.stateManager.notifyPhaseChange(previousPhase, newPhase)\r\n  }\r\n\r\n  /**\r\n   * ステータスを安全に変更\r\n   */\r\n  private changeStatus(newStatus: GameStatus): void {\r\n    const previousStatus = this.status\r\n    this.status = newStatus\r\n    this.stateManager.notifyStatusChange(previousStatus, newStatus)\r\n  }\r\n\r\n  /**\r\n   * ステージを安全に変更\r\n   */\r\n  private changeStage(newStage: GameStage): void {\r\n    const previousStage = this.stage\r\n    this.stage = newStage\r\n    this.stateManager.notifyStageChange(previousStage, newStage)\r\n  }\r\n\r\n  /**\r\n   * ターンを安全に変更\r\n   */\r\n  private changeTurn(newTurn: number): void {\r\n    const previousTurn = this.turn\r\n    this.turn = newTurn\r\n    this.stateManager.notifyTurnChange(previousTurn, newTurn)\r\n  }\r\n\r\n  /**\r\n   * 状態管理システムにアクセス（テスト・拡張用）\r\n   */\r\n  getStateManager(): GameStateManager {\r\n    return this.stateManager\r\n  }\r\n\r\n  /**\r\n   * アクション処理システムにアクセス（テスト・拡張用）\r\n   */\r\n  getActionProcessor(): GameActionProcessor {\r\n    return this.actionProcessor\r\n  }\r\n\r\n  /**\r\n   * オブジェクトプールへのスナップショット返却\r\n   */\r\n  static releaseSnapshot(snapshot: IGameState): void {\r\n    // プールサイズを制限（メモリリーク防止）\r\n    if (Game.OBJECT_POOLS.gameStates.length < 10) {\r\n      // オブジェクトをクリア\r\n      Object.keys(snapshot).forEach(key => {\r\n        delete (snapshot as any)[key]\r\n      })\r\n      Game.OBJECT_POOLS.gameStates.push(snapshot as Partial<IGameState>)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * パフォーマンス統計の取得\r\n   */\r\n  getPerformanceStats(): {\r\n    poolStats: {\r\n      gameStates: number\r\n      cards: number\r\n      challengeResults: number\r\n    }\r\n    cacheHitRate: number\r\n    dirtyFlags: Record<string, boolean>\r\n  } {\r\n    return {\r\n      poolStats: {\r\n        gameStates: Game.OBJECT_POOLS.gameStates.length,\r\n        cards: Game.OBJECT_POOLS.cards.length,\r\n        challengeResults: Game.OBJECT_POOLS.challengeResults.length\r\n      },\r\n      cacheHitRate: this._cachedValues.lastUpdateTime > 0 ? 0.85 : 0, // 概算\r\n      dirtyFlags: { ...this._dirtyFlags }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * チュートリアルシステム型定義\r\n */\r\n\r\n/**\r\n * ゲームアクション検証用\r\n */\r\nexport interface GameActionValidation {\r\n  type: 'draw_card' | 'select_cards' | 'resolve_challenge' | 'select_reward_card' | 'end_turn' | 'custom'\r\n  validation: (gameState: Record<string, unknown>) => boolean\r\n  timeout?: number  // タイムアウト時間（ms）\r\n}\r\n\r\n/**\r\n * チュートリアルステップの基本型\r\n */\r\nexport interface TutorialStep {\r\n  id: string\r\n  title: string\r\n  description: string\r\n  targetElement?: string  // セレクタまたは要素名\r\n  position?: 'top' | 'bottom' | 'left' | 'right' | 'center'\r\n  action?: 'click' | 'hover' | 'wait' | 'auto' | 'wait_for_game_action'  // 進行条件\r\n  waitTime?: number  // auto actionの場合の待機時間（ms）\r\n  gameAction?: GameActionValidation  // ゲームアクション待機の詳細\r\n  skipCondition?: () => boolean  // このステップをスキップする条件\r\n  onEnter?: () => void  // ステップ開始時の処理\r\n  onExit?: () => void   // ステップ終了時の処理\r\n  highlightOptions?: HighlightOptions\r\n}\r\n\r\n/**\r\n * ハイライトオプション\r\n */\r\nexport interface HighlightOptions {\r\n  color?: string\r\n  opacity?: number\r\n  borderWidth?: number\r\n  borderColor?: string\r\n  glowEffect?: boolean\r\n  animationType?: 'pulse' | 'glow' | 'border' | 'none'\r\n  duration?: number  // アニメーション時間（ms）\r\n}\r\n\r\n/**\r\n * チュートリアル進捗状況\r\n */\r\nexport interface TutorialProgress {\r\n  currentStepIndex: number\r\n  completedSteps: string[]\r\n  skippedSteps: string[]\r\n  isCompleted: boolean\r\n  startedAt?: Date\r\n  completedAt?: Date\r\n  lastPlayedVersion?: string  // ゲームバージョン\r\n}\r\n\r\n/**\r\n * チュートリアル設定\r\n */\r\nexport interface TutorialConfig {\r\n  id: string\r\n  name: string\r\n  description: string\r\n  version: string\r\n  steps: TutorialStep[]\r\n  autoStart?: boolean\r\n  canSkip?: boolean\r\n  showProgress?: boolean\r\n  overlayOptions?: OverlayOptions\r\n}\r\n\r\n/**\r\n * オーバーレイオプション\r\n */\r\nexport interface OverlayOptions {\r\n  backgroundColor?: string\r\n  opacity?: number\r\n  blurBackground?: boolean\r\n  allowClickThrough?: boolean\r\n}\r\n\r\n/**\r\n * チュートリアルイベント\r\n */\r\nexport type TutorialEvent = \r\n  | 'tutorial:started'\r\n  | 'tutorial:step:enter'\r\n  | 'tutorial:step:exit'\r\n  | 'tutorial:step:completed'\r\n  | 'tutorial:step:skipped'\r\n  | 'tutorial:completed'\r\n  | 'tutorial:skipped'\r\n  | 'tutorial:error'\r\n\r\n/**\r\n * チュートリアルイベントデータ\r\n */\r\nexport interface TutorialEventData {\r\n  tutorialId: string\r\n  stepId?: string\r\n  stepIndex?: number\r\n  totalSteps?: number\r\n  progress?: TutorialProgress\r\n  error?: string\r\n}\r\n\r\n/**\r\n * ローカルストレージのキー\r\n */\r\nexport const TUTORIAL_STORAGE_KEYS = {\r\n  PROGRESS: 'insurance_game_tutorial_progress',\r\n  SETTINGS: 'insurance_game_tutorial_settings',\r\n  COMPLETED_TUTORIALS: 'insurance_game_completed_tutorials'\r\n} as const\r\n\r\n/**\r\n * チュートリアル状態\r\n */\r\nexport type TutorialState = \r\n  | 'idle'           // 待機中\r\n  | 'running'        // 実行中\r\n  | 'paused'         // 一時停止\r\n  | 'completed'      // 完了\r\n  | 'skipped'        // スキップ\r\n  | 'error'          // エラー\r\n\r\n/**\r\n * チュートリアルマネージャーの設定\r\n */\r\nexport interface TutorialManagerOptions {\r\n  autoSaveProgress?: boolean\r\n  debugMode?: boolean\r\n  defaultHighlightOptions?: HighlightOptions\r\n  defaultOverlayOptions?: OverlayOptions\r\n  stepChangeDelay?: number  // ステップ変更時の遅延（ms）\r\n}\r\n\r\n/**\r\n * ステップ実行結果\r\n */\r\nexport interface StepExecutionResult {\r\n  success: boolean\r\n  stepId: string\r\n  action: 'completed' | 'skipped' | 'error'\r\n  message?: string\r\n  error?: Error\r\n}"],"names":["_StatisticsDataService","__publicField","game","decisionTime","live","card","effectiveness","filter","sort","filteredGames","stats","g","sum","listener","format","games","gameDate","playTime","a","b","comparison","total","totalChallenges","successfulChallenges","counts","rates","stage","stageGames","victories","usage","type","insuranceType","gamesWithInsurance","gamesWithoutInsurance","withInsuranceSuccessRate","withoutInsuranceSuccessRate","dateMap","dateKey","entry","date","data","patterns","situation","choice","success","key","recentGames","olderGames","recentSuccessRate","olderSuccessRate","performanceImprovement","recentAvgPlayTime","olderAvgPlayTime","playTimeIncrease","score","vitalityRatio","cardPowerRatio","row","StatisticsDataService","IdGenerator","prefix","uuid","c","length","FeedbackCategory","FeedbackPriority","FeedbackStatus","SatisfactionRating","Feedback","params","newStatus","tag","index","note","categoryLabel","priorityLabel","statusLabel","feedback","__spreadProps","__spreadValues","FeedbackManagementService","id","results","f","query","error","feedbacks","category","status","priority","responseTimes","totalSatisfactionRating","reviewCount","responseTime","sortedTimes","midIndex","limit","result","jsonData","item","reviews","totalRating","totalRecommendations","ratingDistribution","aspectTotals","overallRating","aspects","wouldRecommend","Deck","name","cards","count","drawn","i","cardId","j","totalPower","totalCost","_CardPower","value","other","powers","power","multiplier","CardPower","_InsurancePremium","premiums","premium","discountRate","discountedValue","multipliedValue","availableVitality","InsurancePremium","Card","effectType","effect","baseReduction","reductionEffect","effectReduction","baseHeal","healEffect","effectHeal","challengeType","bonusEffect","updates","requiredPower","required","effectivePower","display","effectDescriptions","powerSign","effects","rarity","cooldown","rarityDescriptions","requiredCards","comboBonus","duration","globalEffect","unlockCondition","RiskRewardChallenge","baseReward","basePenalty","riskLevel","template","CardFactory","definitions","createFn","def","starterCardDefinitions","ageBonus","basicInsuranceDefinitions","extendedCards","baseInsurances","baseCards","insurance","additionalInsurances","additionalCards","choices","availableTypes","randomIndex","selectedType","termDuration","termCost","wholeLifeCost","challengeDefinitionsByStage","shuffled","selectedCount","selected","normalChallenges","riskChallenges","challenges","riskDistribution","distribution","levelRandom","riskChallenge","pitfallDefinitions","skillDefinitionsByStage","comboDefinitions","eventDefinitionsByStage","legendaryDefinitions","_CardManager","playerDeck","challengeDeck","config","state","discardedCards","removedCard","discarded","_a","CardManager","RiskFactor","factorType","impact","adjustment","newValue","weight","combinedValue","RiskProfile$1","RiskProfile","factors","factor","newFactors","totalScore","overallScore","healthRisk","financialRisk","behavioralRisk","validateRisk","overall","healthChange","financialChange","behavioralChange","clamp","_InsurancePremiumCalculationService","basePremium","riskProfile","ageAdjustedPremium","typeAdjustedPremium","coverageAdjustedPremium","riskMultiplier","insuranceCards","individualPremiums","baseTotalPremium","penaltyMultiplier","currentStage","usageHistory","continuityDiscount","discountedPremium","availableBudget","ratio","recommendedBudget","typeRate","coverage","coverageMultiplier","insuranceCount","baseMultiplier","relevantFactorType","specificFactor","specificMultiplier","playerHistory","profile","ageRiskValue","healthRiskValue","claimsRiskValue","lifestyleRiskValue","history","totalDamageTaken","turnsPlayed","averageDamagePerTurn","claimCount","totalInsurances","claimRate","riskyChoices","totalChoices","riskRate","InsurancePremiumCalculationService","_GameStageManager","turn","oldStage","newStage","hasChanged","transitionMessage","GameStageManager","_InsuranceExpirationManager","expiredInsurances","currentTurn","nowExpired","expiredCard","expiredCards","turnNumber","expiredNames","message","InsuranceExpirationManager","ChallengeResolutionService","challenge","selectedCards","cardManager","insuranceBurden","isRiskChallenge","insuranceImmunity","insuranceBonus","powerBreakdown","playerPower","challengePower","vitalityChange","baseDamage","damageReduction","actualDamage","basePower","insurancePower","adjustedPower","totalBonus","bonus","totalReduction","GameTurnManager","stageManager","expirationManager","expirationResult","progressionResult","activeInsurances","totalHeal","GameChallengeService","resolutionService","challengeCard","burden","expectedPhase","change","GameInsuranceService","premiumService","durationType","selectedCard","absValue","vitality","durationText","activeInsuranceCount","newProfile","GameStateManager","eventType","existingListeners","current","previousValue","event","previousPhase","newPhase","previousStatus","previousStage","previousTurn","newTurn","BaseActionProcessor","input","__async","validationResult","DrawCardsProcessor","drawnCards","StartChallengeProcessor","ResolveChallengeProcessor","SelectInsuranceProcessor","GameActionProcessor","actionType","processor","AGE_PARAMETERS","DREAM_AGE_ADJUSTMENTS","_Vitality","maxVitality","amount","newMaxVitality","adjustedValue","Vitality","_Game","startingVitality","damage","currentTime","currentVitality","ageParams","currentValue","advanceResult","phase","cardState","snapshot","Game","TUTORIAL_STORAGE_KEYS"],"mappings":"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"}