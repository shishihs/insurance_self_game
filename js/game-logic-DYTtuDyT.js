var re=Object.defineProperty,ae=Object.defineProperties;var ie=Object.getOwnPropertyDescriptors;var Q=Object.getOwnPropertySymbols;var ne=Object.prototype.hasOwnProperty,ce=Object.prototype.propertyIsEnumerable;var W=(l,e,t)=>e in l?re(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,v=(l,e)=>{for(var t in e||(e={}))ne.call(e,t)&&W(l,t,e[t]);if(Q)for(var t of Q(e))ce.call(e,t)&&W(l,t,e[t]);return l},x=(l,e)=>ae(l,ie(e));var i=(l,e,t)=>W(l,typeof e!="symbol"?e+"":e,t);var f=(l,e,t)=>new Promise((s,r)=>{var a=o=>{try{c(t.next(o))}catch(d){r(d)}},n=o=>{try{c(t.throw(o))}catch(d){r(d)}},c=o=>o.done?s(o.value):Promise.resolve(o.value).then(a,n);c((t=t.apply(l,e)).next())});const P=class P{constructor(){i(this,"gameHistory",[]);i(this,"currentGameData",null);i(this,"listeners",new Set)}static getInstance(){return P.instance||(P.instance=new P),P.instance}startGameTracking(e){this.currentGameData={currentSession:{startTime:new Date,gamesPlayed:0,currentStreak:0,sessionScore:0},live:{vitalityOverTime:[{turn:0,vitality:e.vitality}],challengeDifficulty:[],decisionTimes:[],cardUsagePatterns:[]}}}updateTurnData(e,t){if(!this.currentGameData)return;const{live:s}=this.currentGameData;s.vitalityOverTime.push({turn:e.turn,vitality:e.vitality}),t!==void 0&&s.decisionTimes.push({turn:e.turn,decisionTime:t}),e.currentChallenge&&s.challengeDifficulty.push({turn:e.turn,difficulty:e.currentChallenge.power}),e.selectedCards.forEach(a=>{const n=this.calculateCardEffectiveness(a,e);s.cardUsagePatterns.push({cardType:a.type,turn:e.turn,effectiveness:n})})}finishGameTracking(e){this.currentGameData&&(this.currentGameData.currentSession.gamesPlayed++,e.status==="victory"?(this.currentGameData.currentSession.currentStreak++,this.currentGameData.currentSession.sessionScore+=this.calculateGameScore(e)):this.currentGameData.currentSession.currentStreak=0),this.gameHistory.push(e),this.notifyListeners()}generateStatistics(e,t){const s=this.applyFilter(this.gameHistory,e),r={totalGames:s.length,completedGames:s.filter(a=>a.isCompleted()).length,victoryGames:s.filter(a=>a.status==="victory").length,gameOverCount:s.filter(a=>a.status==="game_over").length,totalPlayTime:this.calculateTotalPlayTime(s),averageGameDuration:this.calculateAverageGameDuration(s),totalChallenges:s.reduce((a,n)=>a+n.stats.totalChallenges,0),successfulChallenges:s.reduce((a,n)=>a+n.stats.successfulChallenges,0),challengeSuccessRate:this.calculateOverallSuccessRate(s),averageVitality:this.calculateAverageVitality(s),highestVitality:Math.max(...s.map(a=>a.stats.highestVitality)),lowestVitality:Math.min(...s.map(a=>a.vitality)),averageTurnsPerGame:s.reduce((a,n)=>a+n.turn,0)/Math.max(s.length,1),stageReachCounts:this.calculateStageReachCounts(s),stageSuccessRates:this.calculateStageSuccessRates(s),cardsAcquiredTotal:s.reduce((a,n)=>a+n.stats.cardsAcquired,0),averageCardsPerGame:this.calculateAverageCardsPerGame(s),cardTypeUsage:this.calculateCardTypeUsage(s),favoriteCardTypes:this.calculateFavoriteCardTypes(s),totalInsurancePurchases:this.calculateTotalInsurancePurchases(s),insuranceTypeUsage:this.calculateInsuranceTypeUsage(s),averageInsuranceBurden:this.calculateAverageInsuranceBurden(s),insuranceEffectiveness:this.calculateInsuranceEffectiveness(s),gameHistoryByDate:this.generateGameHistoryByDate(s),decisionPatterns:this.analyzeDecisionPatterns(s),recentTrends:this.analyzeRecentTrends(s)};return this.applySorting(r,t)}getRealtimeStatistics(){return this.currentGameData}subscribe(e){return this.listeners.add(e),()=>this.listeners.delete(e)}exportData(e="json"){const t=this.generateStatistics();return e==="json"?JSON.stringify(t,null,2):this.convertToCSV(t)}applyFilter(e,t){return t?e.filter(s=>{if(t.dateRange&&s.startedAt){const a=s.startedAt;if(a<t.dateRange.start||a>t.dateRange.end)return!1}if(t.gameStatus&&!t.gameStatus.includes(s.status)||t.stages&&!t.stages.includes(s.stage))return!1;const r=this.calculateGamePlayTime(s);return!(t.minPlayTime&&r<t.minPlayTime||t.maxPlayTime&&r>t.maxPlayTime)}):e}applySorting(e,t){return t&&(t.field==="gameHistoryByDate"&&e.gameHistoryByDate.sort((s,r)=>{const a=s.date.localeCompare(r.date);return t.direction==="asc"?a:-a}),t.field==="decisionPatterns"&&e.decisionPatterns.sort((s,r)=>{const a=s.frequency-r.frequency;return t.direction==="asc"?a:-a})),e}calculateTotalPlayTime(e){return e.reduce((t,s)=>t+this.calculateGamePlayTime(s),0)}calculateGamePlayTime(e){return e.startedAt?(e.completedAt||new Date).getTime()-e.startedAt.getTime():0}calculateAverageGameDuration(e){return e.length===0?0:this.calculateTotalPlayTime(e)/e.length}calculateOverallSuccessRate(e){const t=e.reduce((r,a)=>r+a.stats.totalChallenges,0),s=e.reduce((r,a)=>r+a.stats.successfulChallenges,0);return t>0?s/t*100:0}calculateAverageVitality(e){return e.length===0?0:e.reduce((t,s)=>t+s.vitality,0)/e.length}calculateStageReachCounts(e){const t={youth:0,middle:0,fulfillment:0};return e.forEach(s=>{t[s.stage]++}),t}calculateStageSuccessRates(e){const t={youth:0,middle:0,fulfillment:0};return this.calculateStageReachCounts(e),Object.keys(t).forEach(s=>{const r=e.filter(n=>n.stage===s),a=r.filter(n=>n.status==="victory");t[s]=r.length>0?a.length/r.length:0}),t}calculateAverageCardsPerGame(e){return e.length===0?0:e.reduce((t,s)=>t+s.stats.cardsAcquired,0)/e.length}calculateCardTypeUsage(e){const t={};return e.forEach(s=>{[...s.playerDeck.cards,...s.hand,...s.discardPile].forEach(a=>{t[a.type]=(t[a.type]||0)+1})}),t}calculateFavoriteCardTypes(e){const t=this.calculateCardTypeUsage(e);return Object.entries(t).sort(([,s],[,r])=>r-s).slice(0,5).map(([s])=>s)}calculateTotalInsurancePurchases(e){return e.reduce((t,s)=>t+s.insuranceCards.length,0)}calculateInsuranceTypeUsage(e){const t={};return e.forEach(s=>{s.insuranceCards.forEach(r=>{const a=r.name||"unknown";t[a]=(t[a]||0)+1})}),t}calculateAverageInsuranceBurden(e){return e.length===0?0:e.reduce((t,s)=>t+s.insuranceBurden,0)/e.length}calculateInsuranceEffectiveness(e){const t=e.filter(n=>n.insuranceCards.length>0),s=e.filter(n=>n.insuranceCards.length===0);if(t.length===0)return 0;const r=t.filter(n=>n.status==="victory").length/t.length,a=s.length>0?s.filter(n=>n.status==="victory").length/s.length:0;return(r-a)*100}generateGameHistoryByDate(e){const t=new Map;return e.forEach(s=>{if(!s.startedAt)return;const r=s.startedAt.toISOString().split("T")[0];t.has(r)||t.set(r,{games:[],totalScore:0,totalPlayTime:0});const a=t.get(r);a.games.push(s),a.totalScore+=this.calculateGameScore(s),a.totalPlayTime+=this.calculateGamePlayTime(s)}),Array.from(t.entries()).map(([s,r])=>({date:s,gamesPlayed:r.games.length,averageScore:r.totalScore/r.games.length,totalPlayTime:r.totalPlayTime})).sort((s,r)=>s.date.localeCompare(r.date))}analyzeDecisionPatterns(e){const t={};return e.forEach(s=>{const r=`${s.stage}_${s.vitality>50?"high":"low"}_vitality`,n=s.insuranceCards.length>0?"with_insurance":"no_insurance",c=s.status==="victory",o=`${r}_${n}`;t[o]||(t[o]={count:0,successes:0}),t[o].count++,c&&t[o].successes++}),Object.entries(t).map(([s,r])=>{const[a,n]=s.split("_with_insurance").length>1?[s.replace("_with_insurance",""),"with_insurance"]:[s.replace("_no_insurance",""),"no_insurance"];return{situation:a,choice:n,frequency:r.count,successRate:r.count>0?r.successes/r.count:0}})}analyzeRecentTrends(e){const t=e.slice(-10),s=e.slice(-20,-10),r=t.filter(y=>y.status==="victory").length/Math.max(t.length,1),a=s.filter(y=>y.status==="victory").length/Math.max(s.length,1),n=(r-a)/Math.max(a,.01)*100,c=this.calculateAverageGameDuration(t),o=this.calculateAverageGameDuration(s),d=c-o;return{performanceImprovement:Math.round(n*10)/10,playTimeIncrease:Math.round(d/1e3),difficultyPreference:"normal",mostActiveTimeSlots:["20:00-22:00"]}}calculateGameScore(e){let t=0;return t+=e.vitality*10,e.status==="victory"&&(t+=1e3),t+=e.stats.successfulChallenges*50,t+=e.stats.cardsAcquired*25,t*={youth:1,middle:1.5,fulfillment:2}[e.stage],Math.round(t)}calculateCardEffectiveness(e,t){const s=t.vitality/t.maxVitality,r=e.power/10;return Math.min(100,(r+s)*50)}convertToCSV(e){return[["統計項目","値"],["総ゲーム数",e.totalGames.toString()],["完了ゲーム数",e.completedGames.toString()],["勝利ゲーム数",e.victoryGames.toString()],["総チャレンジ数",e.totalChallenges.toString()],["成功チャレンジ数",e.successfulChallenges.toString()],["チャレンジ成功率",`${e.challengeSuccessRate.toFixed(1)}%`],["平均活力",e.averageVitality.toFixed(1)],["最高活力",e.highestVitality.toString()],["平均ターン数",e.averageTurnsPerGame.toFixed(1)]].map(s=>s.join(",")).join(`
`)}notifyListeners(){const e=this.generateStatistics();this.listeners.forEach(t=>t(e))}};i(P,"instance");let Z=P;class h{static generate(e="id"){return`${e}_${Date.now()}_${this.getRandomString()}`}static generateCardId(){return this.generate("card")}static generateGameId(){return this.generate("game")}static generateCommandId(){return this.generate("cmd")}static generateNotificationId(){return this.generate("notification")}static generateFeedbackId(){return this.generate("feedback")}static generateSequential(e="seq"){return`${e}_${++this.counter}`}static generateUUID(e){const t="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,s=>{const r=Math.random()*16|0;return(s==="x"?r:r&3|8).toString(16)});return e?`${e}_${t}`:t}static getRandomString(e=9){return Math.random().toString(36).substr(2,e)}static resetCounter(){this.counter=0}static getCurrentCounter(){return this.counter}}i(h,"counter",0);var M=(l=>(l.BUG_REPORT="bug_report",l.FEATURE_REQUEST="feature_request",l.UI_UX="ui_ux",l.GAMEPLAY="gameplay",l.PERFORMANCE="performance",l.ACCESSIBILITY="accessibility",l.GENERAL="general",l))(M||{}),$=(l=>(l.LOW="low",l.MEDIUM="medium",l.HIGH="high",l.CRITICAL="critical",l))($||{}),C=(l=>(l.SUBMITTED="submitted",l.UNDER_REVIEW="under_review",l.IN_PROGRESS="in_progress",l.RESOLVED="resolved",l.CLOSED="closed",l))(C||{}),_=(l=>(l[l.VERY_UNSATISFIED=1]="VERY_UNSATISFIED",l[l.UNSATISFIED=2]="UNSATISFIED",l[l.NEUTRAL=3]="NEUTRAL",l[l.SATISFIED=4]="SATISFIED",l[l.VERY_SATISFIED=5]="VERY_SATISFIED",l))(_||{});class O{constructor(e){i(this,"id");i(this,"category");i(this,"title");i(this,"description");i(this,"priority");i(this,"submitter");i(this,"systemInfo");i(this,"createdAt");i(this,"_status");i(this,"_updatedAt");i(this,"_tags");i(this,"_adminNotes");i(this,"bugReportData");i(this,"reviewData");this.id=h.generateFeedbackId(),this.category=e.category,this.title=e.title,this.description=e.description,this.priority=e.priority||this.calculateAutoPriority(e),this.submitter=e.submitter,this.systemInfo=e.systemInfo,this.bugReportData=e.bugReportData,this.reviewData=e.reviewData,this.createdAt=new Date,this._status="submitted",this._updatedAt=new Date,this._tags=e.tags||[],this._adminNotes=[]}get status(){return this._status}get updatedAt(){return this._updatedAt}get tags(){return[...this._tags]}get adminNotes(){return[...this._adminNotes]}updateStatus(e){if(this.isValidStatusTransition(e))this._status=e,this._updatedAt=new Date;else throw new Error(`Invalid status transition: ${this._status} -> ${e}`)}addTag(e){this._tags.includes(e)||(this._tags.push(e),this._updatedAt=new Date)}removeTag(e){const t=this._tags.indexOf(e);t>-1&&(this._tags.splice(t,1),this._updatedAt=new Date)}addAdminNote(e){this._adminNotes.push(`${new Date().toISOString()}: ${e}`),this._updatedAt=new Date}calculateAutoPriority(e){if(e.category==="bug_report"&&e.bugReportData)switch(e.bugReportData.severity){case"critical":return"critical";case"high":return"high";case"medium":return"medium";case"low":return"low"}if(e.category==="general"&&e.reviewData){if(e.reviewData.overallRating<=2)return"high";if(e.reviewData.overallRating>=4)return"medium"}return e.category==="accessibility"?"high":"medium"}isValidStatusTransition(e){return{submitted:["under_review","closed"],under_review:["in_progress","closed","submitted"],in_progress:["resolved","under_review","closed"],resolved:["closed","in_progress"],closed:[]}[this._status].includes(e)}isBugReport(){return this.category==="bug_report"&&!!this.bugReportData}isReview(){return!!this.reviewData}isAnonymous(){return this.submitter.isAnonymous}isHighPriority(){return this.priority==="high"||this.priority==="critical"}getSummary(){const e=this.getCategoryLabel(),t=this.getPriorityLabel(),s=this.getStatusLabel();return`[${e}] ${this.title} (${t}) - ${s}`}getCategoryLabel(){return{bug_report:"バグ報告",feature_request:"機能要望",ui_ux:"UI/UX",gameplay:"ゲームプレイ",performance:"パフォーマンス",accessibility:"アクセシビリティ",general:"一般"}[this.category]}getPriorityLabel(){return{low:"低",medium:"中",high:"高",critical:"緊急"}[this.priority]}getStatusLabel(){return{submitted:"提出済み",under_review:"確認中",in_progress:"対応中",resolved:"解決済み",closed:"完了"}[this.status]}toJSON(){return{id:this.id,category:this.category,title:this.title,description:this.description,priority:this.priority,status:this._status,submitter:this.submitter,systemInfo:this.systemInfo,bugReportData:this.bugReportData,reviewData:this.reviewData,tags:this._tags,adminNotes:this._adminNotes,createdAt:this.createdAt.toISOString(),updatedAt:this._updatedAt.toISOString()}}static fromJSON(e){const t=new O({category:e.category,title:e.title,description:e.description,priority:e.priority,submitter:e.submitter,systemInfo:x(v({},e.systemInfo),{timestamp:new Date(e.systemInfo.timestamp)}),bugReportData:e.bugReportData,reviewData:e.reviewData,tags:e.tags});return t._status=e.status,t._updatedAt=new Date(e.updatedAt),t._adminNotes=e.adminNotes||[],t}}class Se{constructor(){i(this,"feedbacks",new Map);i(this,"STORAGE_KEY","game_feedback_data");this.loadFromStorage()}createFeedback(e){const t=new O(e);return this.feedbacks.set(t.id,t),this.saveToStorage(),t.isHighPriority()&&this.notifyHighPriorityFeedback(t),t}createBugReport(e){return this.createFeedback({category:M.BUG_REPORT,title:e.title,description:e.description,submitter:e.submitter,systemInfo:e.systemInfo,bugReportData:e.bugReportData,tags:e.tags})}createReview(e){return this.createFeedback({category:M.GENERAL,title:e.title,description:e.description,submitter:e.submitter,systemInfo:e.systemInfo,reviewData:e.reviewData,tags:e.tags})}getFeedbackById(e){return this.feedbacks.get(e)}searchFeedbacks(e={}){let t=Array.from(this.feedbacks.values());if(e.categories&&e.categories.length>0&&(t=t.filter(s=>e.categories.includes(s.category))),e.statuses&&e.statuses.length>0&&(t=t.filter(s=>e.statuses.includes(s.status))),e.priorities&&e.priorities.length>0&&(t=t.filter(s=>e.priorities.includes(s.priority))),e.dateRange&&(t=t.filter(s=>s.createdAt>=e.dateRange.start&&s.createdAt<=e.dateRange.end)),e.isAnonymous!==void 0&&(t=t.filter(s=>s.isAnonymous()===e.isAnonymous)),e.tags&&e.tags.length>0&&(t=t.filter(s=>e.tags.some(r=>s.tags.includes(r)))),e.searchQuery){const s=e.searchQuery.toLowerCase();t=t.filter(r=>r.title.toLowerCase().includes(s)||r.description.toLowerCase().includes(s)||r.tags.some(a=>a.toLowerCase().includes(s)))}return t.sort((s,r)=>r.createdAt.getTime()-s.createdAt.getTime())}updateFeedbackStatus(e,t){const s=this.feedbacks.get(e);if(!s)return!1;try{return s.updateStatus(t),this.saveToStorage(),!0}catch(r){return console.error("Failed to update feedback status:",r),!1}}addTagToFeedback(e,t){const s=this.feedbacks.get(e);return s?(s.addTag(t),this.saveToStorage(),!0):!1}addAdminNote(e,t){const s=this.feedbacks.get(e);return s?(s.addAdminNote(t),this.saveToStorage(),!0):!1}getStatistics(e={}){const t=this.searchFeedbacks(e),s={total:t.length,byCategory:{},byStatus:{},byPriority:{},resolvedCount:0,pendingCount:0,responseTime:{average:0,median:0},trends:{daily:{},weekly:{},monthly:{}}};Object.values(M).forEach(c=>{s.byCategory[c]=0}),Object.values(C).forEach(c=>{s.byStatus[c]=0}),Object.values($).forEach(c=>{s.byPriority[c]=0});const r=[];let a=0,n=0;if(t.forEach(c=>{if(s.byCategory[c.category]++,s.byStatus[c.status]++,s.byPriority[c.priority]++,c.status===C.RESOLVED||c.status===C.CLOSED?s.resolvedCount++:s.pendingCount++,c.status!==C.SUBMITTED){const d=(c.updatedAt.getTime()-c.createdAt.getTime())/36e5;r.push(d)}c.reviewData&&(a+=c.reviewData.overallRating,n++);const o=c.createdAt.toISOString().split("T")[0];s.trends.daily[o]=(s.trends.daily[o]||0)+1}),n>0&&(s.averageSatisfactionRating=a/n),r.length>0){s.responseTime.average=r.reduce((d,y)=>d+y,0)/r.length;const c=r.sort((d,y)=>d-y),o=Math.floor(c.length/2);s.responseTime.median=c.length%2===0?(c[o-1]+c[o])/2:c[o]}return s}getHighPriorityFeedbacks(){return this.searchFeedbacks({priorities:[$.HIGH,$.CRITICAL],statuses:[C.SUBMITTED,C.UNDER_REVIEW,C.IN_PROGRESS]})}getUnresolvedBugReports(){return this.searchFeedbacks({categories:[M.BUG_REPORT],statuses:[C.SUBMITTED,C.UNDER_REVIEW,C.IN_PROGRESS]})}getRecentReviews(e=10){return this.searchFeedbacks({categories:[M.GENERAL]}).filter(s=>s.isReview()).slice(0,e)}deleteFeedback(e){const t=this.feedbacks.delete(e);return t&&this.saveToStorage(),t}getAllFeedbacks(){return Array.from(this.feedbacks.values()).sort((e,t)=>t.createdAt.getTime()-e.createdAt.getTime())}exportFeedbacks(){const e=Array.from(this.feedbacks.values()).map(t=>t.toJSON());return JSON.stringify(e,null,2)}importFeedbacks(e){try{const t=JSON.parse(e);if(!Array.isArray(t))throw new Error("Invalid data format");return t.forEach(s=>{const r=O.fromJSON(s);this.feedbacks.set(r.id,r)}),this.saveToStorage(),!0}catch(t){return console.error("Failed to import feedbacks:",t),!1}}getSatisfactionSurveyResults(){const e=this.getAllFeedbacks().filter(n=>n.isReview());if(e.length===0)return{averageRating:0,totalResponses:0,ratingDistribution:{},aspectRatings:{gameplay:0,ui:0,performance:0,accessibility:0},recommendationRate:0};let t=0,s=0;const r={[_.VERY_UNSATISFIED]:0,[_.UNSATISFIED]:0,[_.NEUTRAL]:0,[_.SATISFIED]:0,[_.VERY_SATISFIED]:0},a={gameplay:0,ui:0,performance:0,accessibility:0};return e.forEach(n=>{if(n.reviewData){const{overallRating:c,aspects:o,wouldRecommend:d}=n.reviewData;t+=c,r[c]++,d&&s++,a.gameplay+=o.gameplay,a.ui+=o.ui,a.performance+=o.performance,a.accessibility+=o.accessibility}}),{averageRating:t/e.length,totalResponses:e.length,ratingDistribution:r,aspectRatings:{gameplay:a.gameplay/e.length,ui:a.ui/e.length,performance:a.performance/e.length,accessibility:a.accessibility/e.length},recommendationRate:s/e.length*100}}loadFromStorage(){try{const e=localStorage.getItem(this.STORAGE_KEY);e&&JSON.parse(e).forEach(s=>{const r=O.fromJSON(s);this.feedbacks.set(r.id,r)})}catch(e){console.error("Failed to load feedback data from storage:",e)}}saveToStorage(){try{const e=Array.from(this.feedbacks.values()).map(t=>t.toJSON());localStorage.setItem(this.STORAGE_KEY,JSON.stringify(e))}catch(e){console.error("Failed to save feedback data to storage:",e)}}notifyHighPriorityFeedback(e){console.warn(`🚨 高優先度フィードバック: ${e.getSummary()}`)}}class k{constructor(e,t=[]){i(this,"cards");i(this,"name");this.name=e,this.cards=[...t]}getName(){return this.name}size(){return this.cards.length}isEmpty(){return this.cards.length===0}addCard(e){this.cards.push(e)}addCards(e){this.cards.push(...e)}drawCard(){return this.cards.pop()||null}drawCards(e){const t=[];for(let s=0;s<e&&!this.isEmpty();s++){const r=this.drawCard();r&&t.push(r)}return t}removeCard(e){const t=this.cards.findIndex(s=>s.id===e);return t!==-1?(this.cards.splice(t,1),!0):!1}shuffle(){for(let e=this.cards.length-1;e>0;e--){const t=Math.floor(Math.random()*(e+1));[this.cards[e],this.cards[t]]=[this.cards[t],this.cards[e]]}}getCards(){return[...this.cards]}countCardsByType(e){return this.cards.filter(t=>t.type===e).length}clear(){this.cards=[]}clone(){return new k(this.name,this.cards.map(e=>e.clone()))}getStats(){const e={total:this.cards.length,byType:{life:0,insurance:0,pitfall:0},averagePower:0,averageCost:0};let t=0,s=0;return this.cards.forEach(r=>{e.byType[r.type]++,t+=r.power,s+=r.cost}),e.averagePower=e.total>0?t/e.total:0,e.averageCost=e.total>0?s/e.total:0,e}}const g=class g{constructor(e){this.value=e,this.validate()}static create(e){return new g(e)}validate(){if(this.value<g.MIN_POWER)throw new Error("CardPower must be non-negative");if(this.value>g.MAX_POWER)throw new Error("CardPower cannot exceed maximum")}getValue(){return this.value}add(e){const t=this.value+e.value;return new g(Math.min(t,g.MAX_POWER))}static sum(e){const t=e.reduce((s,r)=>s+r.value,0);return new g(Math.min(t,g.MAX_POWER))}multiply(e){if(e<0)throw new Error("Multiplier cannot be negative");const t=Math.floor(this.value*e);return new g(Math.min(t,g.MAX_POWER))}isGreaterThan(e){return this.value>e.value}isGreaterThanOrEqual(e){return this.value>=e.value}equals(e){return this.value===e.value}toString(){return`Power: ${this.value}`}static get ZERO(){return new g(0)}static get MAX(){return new g(g.MAX_POWER)}};i(g,"MIN_POWER",0),i(g,"MAX_POWER",999);let G=g;const p=class p{constructor(e){this.value=e,this.validate()}static create(e){return new p(Math.floor(e))}validate(){if(this.value<p.MIN_PREMIUM)throw new Error("InsurancePremium must be non-negative");if(this.value>p.MAX_PREMIUM)throw new Error("InsurancePremium cannot exceed maximum")}getValue(){return this.value}static sum(e){const t=e.reduce((s,r)=>s+r.value,0);return new p(Math.min(t,p.MAX_PREMIUM))}applyDiscount(e){if(e<0)throw new Error("Discount rate cannot be negative");if(e>1)throw new Error("Discount rate cannot exceed 100%");const t=Math.floor(this.value*(1-e));return new p(t)}applyMultiplier(e){if(e<0)throw new Error("Multiplier cannot be negative");const t=Math.floor(this.value*e);return new p(Math.min(t,p.MAX_PREMIUM))}isFree(){return this.value===0}isExpensive(){return this.value>=p.EXPENSIVE_THRESHOLD}isHigherThan(e){return this.value>e.value}isAffordableWith(e){return e>=this.value}equals(e){return this.value===e.value}toString(){return this.isFree()?"保険料: 無料":`保険料: ${this.value}`}static get FREE(){return new p(0)}};i(p,"MIN_PREMIUM",0),i(p,"MAX_PREMIUM",99),i(p,"EXPENSIVE_THRESHOLD",20);let R=p;class u{constructor(e){i(this,"id");i(this,"name");i(this,"description");i(this,"type");i(this,"_power");i(this,"_cost");i(this,"effects");i(this,"imageUrl");i(this,"category");i(this,"insuranceType");i(this,"coverage");i(this,"penalty");i(this,"ageBonus");i(this,"durationType");i(this,"remainingTurns");i(this,"insuranceEffectType");i(this,"dreamCategory");i(this,"skillProperties");i(this,"comboProperties");i(this,"eventProperties");i(this,"isUnlockable");i(this,"unlockCondition");this.id=e.id,this.name=e.name,this.description=e.description,this.type=e.type,this._power=G.create(e.power),this._cost=R.create(e.cost),this.effects=e.effects,this.imageUrl=e.imageUrl,this.category=e.category,this.insuranceType=e.insuranceType,this.coverage=e.coverage,this.penalty=e.penalty,"ageBonus"in e&&(this.ageBonus=e.ageBonus),"durationType"in e&&(this.durationType=e.durationType),"remainingTurns"in e&&(this.remainingTurns=e.remainingTurns),"insuranceEffectType"in e&&(this.insuranceEffectType=e.insuranceEffectType),"dreamCategory"in e&&(this.dreamCategory=e.dreamCategory),"skillProperties"in e&&(this.skillProperties=e.skillProperties),"comboProperties"in e&&(this.comboProperties=e.comboProperties),"eventProperties"in e&&(this.eventProperties=e.eventProperties),"isUnlockable"in e&&(this.isUnlockable=e.isUnlockable),"unlockCondition"in e&&(this.unlockCondition=e.unlockCondition)}get power(){return this._power.getValue()}get cost(){return this._cost.getValue()}getPower(){return this._power}getCost(){return this._cost}hasEffect(e){return this.effects.some(t=>t.type===e)}getEffect(e){return this.effects.find(t=>t.type===e)}isInsurance(){return this.type==="insurance"}isTermInsurance(){return this.isInsurance()&&this.durationType==="term"}isWholeLifeInsurance(){return this.isInsurance()&&this.durationType==="whole_life"}getInsuranceEffectType(){if(this.isInsurance())return this.insuranceEffectType||"offensive"}isDefensiveInsurance(){return this.isInsurance()&&this.getInsuranceEffectType()==="defensive"}isRecoveryInsurance(){return this.isInsurance()&&this.getInsuranceEffectType()==="recovery"}isSpecializedInsurance(){return this.isInsurance()&&this.getInsuranceEffectType()==="specialized"}calculateDamageReduction(){if(!this.isDefensiveInsurance())return 0;const e=Math.floor((this.coverage||0)/10),t=this.getEffect("damage_reduction"),s=t?t.value:0;return e+s}calculateTurnHeal(){if(!this.isRecoveryInsurance())return 0;const e=Math.floor((this.coverage||0)/20),t=this.getEffect("turn_heal"),s=t?t.value:0;return e+s}calculateChallengeBonus(e){if(!this.isSpecializedInsurance())return 0;const t=this.getEffect("challenge_bonus");return t!=null&&t.condition&&t.condition.includes(e)?t.value:0}isDreamCard(){return this.type==="dream"}copy(e){return new u(v(x(v({},this),{power:this.power,cost:this.cost,effects:[...this.effects]}),e))}clone(){return this.copy()}decrementRemainingTurns(){return!this.isTermInsurance()||!this.remainingTurns?this:this.copy({remainingTurns:Math.max(0,this.remainingTurns-1)})}isExpired(){return this.isTermInsurance()?this.remainingTurns===0:!1}hasPowerAtLeast(e){const t=G.create(e);return this._power.isGreaterThanOrEqual(t)}isAffordableWith(e){return this._cost.isAffordableWith(e)}calculateEffectivePower(){let e=this.power;return this.isInsurance()&&this.ageBonus&&(e+=this.ageBonus),this.isInsurance()&&this.getInsuranceEffectType()!=="offensive"?0:Math.max(0,e)}isLifeCard(){return this.type==="life"}isInsuranceCard(){return this.isInsurance()}isPitfallCard(){return this.type==="pitfall"}isSkillCard(){return this.type==="skill"}isComboCard(){return this.type==="combo"}isEventCard(){return this.type==="event"}isLegendaryCard(){return this.type==="legendary"}isChallengeCard(){return this.type==="challenge"}toDisplayString(){let e=`${this.name} (${this.power})`;if(this.effects.length>0){const t=this.effects.map(s=>s.description).join(", ");e+=` - ${t}`}return e}decrementTurn(){this.remainingTurns!==void 0&&this.remainingTurns>0&&this.remainingTurns--}static createLifeCard(e,t){const s=t>0?"+":"";return new u({id:h.generate("life"),name:e,description:`パワー: ${s}${t}`,type:"life",power:t,cost:0,effects:[]})}static createChallengeCard(e,t){return new u({id:h.generate("challenge"),name:e,description:`必要パワー: ${t}`,type:"challenge",power:t,cost:0,effects:[]})}static createInsuranceCard(e,t,...s){return new u({id:h.generate("insurance"),name:e,description:`保険カード - パワー: +${t}`,type:"insurance",power:t,cost:1,effects:s})}static createSkillCard(e,t,s,r){const a={common:"コモン",rare:"レア",epic:"エピック",legendary:"レジェンダリー"};return new u({id:h.generate("skill"),name:e,description:`${a[t]}スキル - パワー: +${s}`,type:"skill",power:s,cost:0,effects:[],skillProperties:{rarity:t,cooldown:r,remainingCooldown:0,masteryLevel:1}})}static createComboCard(e,t,s,r){return new u({id:h.generate("combo"),name:e,description:`コンボカード - パワー: +${t} (コンボ時: +${r})`,type:"combo",power:t,cost:0,effects:[],comboProperties:{requiredCards:s,comboBonus:r}})}static createEventCard(e,t,s,r=!1){return new u({id:h.generate("event"),name:e,description:`イベントカード - ${s}ターン継続`,type:"event",power:t,cost:0,effects:[],eventProperties:{duration:s,globalEffect:r}})}static createLegendaryCard(e,t,s){return new u({id:h.generate("legendary"),name:e,description:`レジェンダリーカード - パワー: +${t}`,type:"legendary",power:t,cost:0,effects:[],isUnlockable:!0,unlockCondition:s})}}class H extends u{constructor(t){const s=[];t.riskLevel==="extreme"&&s.push({type:"special_action",value:0,description:"保険効果無効化",condition:"このチャレンジでは保険カードのパワーが無効"});super({id:h.generateCardId(),type:"challenge",name:t.name,description:t.description,power:t.power,cost:0,effects:s,dreamCategory:t.dreamCategory});i(this,"riskLevel");i(this,"successBonus");i(this,"failurePenalty");i(this,"insuranceImmunity");this.riskLevel=t.riskLevel,this.successBonus=t.successBonus,this.failurePenalty=t.failurePenalty,this.insuranceImmunity=t.insuranceImmunity||t.riskLevel==="extreme"}getRiskMultiplier(){return{low:1.2,medium:1.5,high:2,extreme:3}[this.riskLevel]}calculateActualReward(t){return Math.floor(t*this.getRiskMultiplier())+this.successBonus}calculateActualPenalty(t){return Math.floor(t*this.getRiskMultiplier())+this.failurePenalty}getRiskDescription(){return{low:"低リスク: 少し危険だが、失敗してもダメージは軽い",medium:"中リスク: 成功と失敗のバランスが取れている",high:"高リスク: 失敗時のダメージが大きいが、報酬も魅力的",extreme:"極限リスク: 保険も効かない危険な挑戦。成功すれば大きな報酬"}[this.riskLevel]}getChallengeDetails(){return[`必要パワー: ${this.power}`,`リスクレベル: ${this.riskLevel.toUpperCase()}`,`成功ボーナス: +${this.successBonus} 活力`,`失敗ペナルティ: -${this.failurePenalty} 活力`,this.insuranceImmunity?"⚠️ 保険無効":""].filter(Boolean).join(`
`)}static createRiskChallenge(t,s){const a={youth:{low:{name:"新しいスポーツへの挑戦",description:"未経験の分野に挑戦する勇気",power:5,successBonus:2,failurePenalty:1},medium:{name:"起業への第一歩",description:"安定を捨てて夢を追う決断",power:7,successBonus:5,failurePenalty:3},high:{name:"海外留学",description:"未知の世界への大きな飛躍",power:9,successBonus:8,failurePenalty:5},extreme:{name:"人生を賭けた大勝負",description:"全てを投げ打って挑む最大の挑戦",power:12,successBonus:15,failurePenalty:10}},middle:{low:{name:"副業の開始",description:"新たな収入源への挑戦",power:6,successBonus:3,failurePenalty:2},medium:{name:"独立開業",description:"会社を辞めて独立する決断",power:9,successBonus:7,failurePenalty:5},high:{name:"大型投資",description:"将来を見据えた大胆な投資",power:11,successBonus:10,failurePenalty:7},extreme:{name:"人生の大転換",description:"全てをリセットして新しい道へ",power:15,successBonus:20,failurePenalty:15}},fulfillment:{low:{name:"新しい趣味への挑戦",description:"年齢に関係なく新しいことを始める",power:7,successBonus:4,failurePenalty:2},medium:{name:"ボランティア活動",description:"社会貢献への新たな一歩",power:10,successBonus:8,failurePenalty:4},high:{name:"遺産の活用",description:"次世代への大きな投資",power:13,successBonus:12,failurePenalty:8},extreme:{name:"人生最後の大冒険",description:"残された時間での究極の挑戦",power:18,successBonus:25,failurePenalty:20}}}[t][s];return new H(x(v({},a),{riskLevel:s,dreamCategory:s==="extreme"?"mixed":"physical"}))}}class I{static calculateAgeBonus(e){switch(e){case"middle":return .5;case"fulfillment":return 1;default:return 0}}static createCardsFromDefinitions(e,t){return e.map(s=>t(s))}static createStarterLifeCards(){const e=[{name:"朝のジョギング",description:"健康的な一日の始まり",category:"health",power:2,cost:1},{name:"栄養バランスの良い食事",description:"体調管理の基本",category:"health",power:3,cost:2},{name:"新しいスキルの習得",description:"成長への投資",category:"career",power:3,cost:2},{name:"チームワーク",description:"仲間との協力",category:"career",power:2,cost:1},{name:"家族との団らん",description:"心の充電",category:"family",power:2,cost:1},{name:"趣味の時間",description:"リフレッシュタイム",category:"hobby",power:2,cost:1},{name:"計画的な貯蓄",description:"将来への備え",category:"finance",power:3,cost:2}];return this.createCardsFromDefinitions(e,t=>this.createLifeCard(t))}static createBasicInsuranceCards(e="youth"){const t=this.calculateAgeBonus(e),s=[{name:"医療保険",description:"病気やケガに備える永続保障",insuranceType:"medical",power:4,cost:3,coverage:100},{name:"生命保険",description:"家族を守る永続保障",insuranceType:"life",power:5,cost:4,coverage:200},{name:"収入保障保険",description:"働けなくなった時の永続保障",insuranceType:"income",power:4,cost:3,coverage:150}];return this.createCardsFromDefinitions(s,r=>this.createInsuranceCard(x(v({},r),{ageBonus:t})))}static createExtendedInsuranceCards(e="youth"){const t=[],s=this.calculateAgeBonus(e),r=[{name:"医療保険",insuranceType:"medical",power:5,cost:4,coverage:100},{name:"生命保険",insuranceType:"life",power:6,cost:5,coverage:200},{name:"収入保障保険",insuranceType:"income",power:5,cost:4,coverage:150}],a=this.createCardsFromDefinitions(r,o=>this.createInsuranceCard({name:o.name,description:`${o.name}の永続保障`,insuranceType:o.insuranceType,power:o.power,cost:o.cost,coverage:o.coverage,ageBonus:s}));t.push(...a);const n=[{name:"傷害保険",insuranceType:"medical",power:4,cost:3,coverage:80},{name:"就業不能保険",insuranceType:"income",power:7,cost:6,coverage:250},{name:"介護保険",insuranceType:"medical",power:6,cost:5,coverage:180},{name:"がん保険",insuranceType:"medical",power:5,cost:4,coverage:120},{name:"個人年金保険",insuranceType:"income",power:4,cost:4,coverage:100},{name:"学資保険",insuranceType:"life",power:4,cost:3,coverage:90}],c=this.createCardsFromDefinitions(n,o=>this.createInsuranceCard({name:o.name,description:`${o.name}の永続保障`,insuranceType:o.insuranceType,power:o.power,cost:o.cost,coverage:o.coverage,ageBonus:s}));return t.push(...c),t}static createDiverseInsuranceCards(e="youth"){const t=[],s=this.calculateAgeBonus(e);return t.push(new u({id:h.generateCardId(),type:"insurance",name:"攻撃特化生命保険",description:"チャレンジ時に大きなパワーを提供",power:8,cost:5,insuranceType:"life",insuranceEffectType:"offensive",coverage:150,effects:[],ageBonus:s,durationType:"whole_life"})),t.push(new u({id:h.generateCardId(),type:"insurance",name:"防御特化医療保険",description:"ダメージを軽減する防御的保障",power:0,cost:4,insuranceType:"medical",insuranceEffectType:"defensive",coverage:100,effects:[{type:"damage_reduction",value:3,description:"ダメージを3ポイント軽減"}],ageBonus:0,durationType:"whole_life"})),t.push(new u({id:h.generateCardId(),type:"insurance",name:"回復特化健康保険",description:"毎ターン活力を回復",power:0,cost:3,insuranceType:"health",insuranceEffectType:"recovery",coverage:80,effects:[{type:"turn_heal",value:2,description:"毎ターン終了時に2点回復"}],ageBonus:0,durationType:"whole_life"})),t.push(new u({id:h.generateCardId(),type:"insurance",name:"仕事特化収入保障保険",description:"仕事関連のチャレンジに特化",power:3,cost:4,insuranceType:"income",insuranceEffectType:"specialized",coverage:120,effects:[{type:"challenge_bonus",value:5,description:"「就職」「明進」チャレンジ時+5パワー",condition:"就職,明進,転職,仕事"}],ageBonus:s,durationType:"whole_life"})),t.push(new u({id:h.generateCardId(),type:"insurance",name:"オールインワン総合保険",description:"複数の効果を持つ高コスト保障",power:3,cost:7,insuranceType:"life",insuranceEffectType:"comprehensive",coverage:200,effects:[{type:"power_boost",value:3,description:"パワー+3"},{type:"damage_reduction",value:2,description:"ダメージ-2"},{type:"turn_heal",value:1,description:"毎ターン+1回復"}],ageBonus:s,durationType:"whole_life"})),t}static createInsuranceTypeChoices(e="youth"){const t=[],s=this.calculateAgeBonus(e),a=[...[{type:"medical",name:"医療保険",description:"病気やケガに備える保障",power:5,baseCost:4,coverage:100,effectType:"offensive"},{type:"life",name:"生命保険",description:"家族を守る保障",power:6,baseCost:5,coverage:200,effectType:"offensive"},{type:"income",name:"収入保障保険",description:"働けなくなった時の保障",power:5,baseCost:4,coverage:150,effectType:"offensive"},{type:"health",name:"防御型健康保険",description:"ダメージを軽減する防御的保障",power:0,baseCost:3,coverage:80,effectType:"defensive"},{type:"disability",name:"回復型障害保険",description:"定期的に活力を回復",power:0,baseCost:3,coverage:60,effectType:"recovery"}]];for(let n=0;n<3&&a.length>0;n++){const c=Math.floor(Math.random()*a.length),o=a.splice(c,1)[0],d=10,y=Math.ceil(o.baseCost*.7),b=o.baseCost,D={insuranceType:o.type,name:o.name,description:o.description,baseCard:{name:o.name,description:o.description,type:"insurance",power:o.power,cost:o.baseCost,insuranceType:o.type,coverage:o.coverage,insuranceEffectType:o.effectType,effects:[{type:"shield",value:o.coverage,description:`${o.coverage}ポイントの保障`}],ageBonus:s},termOption:{cost:y,duration:d,description:`${d}ターン限定の保障（低コスト）`},wholeLifeOption:{cost:b,description:"生涯にわたる永続保障（高コスト）"}};t.push(D)}return t}static createTermInsuranceCard(e){return new u({id:h.generateCardId(),type:"insurance",name:`定期${e.name}`,description:`${e.baseCard.description}（${e.termOption.duration}ターン限定）`,power:e.baseCard.power,cost:e.termOption.cost,insuranceType:e.insuranceType,coverage:e.baseCard.coverage,effects:e.baseCard.effects,ageBonus:e.baseCard.ageBonus,insuranceEffectType:e.baseCard.insuranceEffectType,durationType:"term",remainingTurns:e.termOption.duration})}static createWholeLifeInsuranceCard(e){return new u({id:h.generateCardId(),type:"insurance",name:`終身${e.name}`,description:`${e.baseCard.description}（永続保障）`,power:e.baseCard.power,cost:e.wholeLifeOption.cost,insuranceType:e.insuranceType,coverage:e.baseCard.coverage,effects:e.baseCard.effects,ageBonus:e.baseCard.ageBonus,insuranceEffectType:e.baseCard.insuranceEffectType,durationType:"whole_life"})}static createChallengeCards(e){const t={youth:[{name:"アルバイト探し",description:"初めての収入を得る",power:3,dreamCategory:"physical"},{name:"一人暮らし",description:"独立への第一歩",power:4,dreamCategory:"physical"},{name:"資格試験",description:"スキルアップのチャンス",power:5,dreamCategory:"intellectual"},{name:"就職活動",description:"新たなキャリアの始まり",power:6,dreamCategory:"physical"},{name:"恋人との別れ",description:"初めての大きな失意",power:5,dreamCategory:"mixed"},{name:"転職活動",description:"キャリアの分岐点",power:6,dreamCategory:"intellectual"}],middle:[{name:"結婚資金",description:"新しい家族のスタート",power:6,dreamCategory:"mixed"},{name:"子育て",description:"家族の成長",power:7,dreamCategory:"physical"},{name:"両親の健康",description:"家族の支え合い",power:8,dreamCategory:"mixed"},{name:"住宅購入",description:"大きな決断",power:9,dreamCategory:"physical"},{name:"親の介護",description:"家族の責任",power:10,dreamCategory:"mixed"},{name:"教育資金",description:"子供の将来への投資",power:8,dreamCategory:"intellectual"}],fulfillment:[{name:"健康管理",description:"健やかな老後のために",power:8,dreamCategory:"mixed"},{name:"趣味の充実",description:"人生の新たな楽しみ",power:9,dreamCategory:"intellectual"},{name:"社会貢献",description:"経験を活かした活動",power:10,dreamCategory:"mixed"},{name:"定年退職",description:"新しい人生のスタート",power:11,dreamCategory:"intellectual"},{name:"遺産相続",description:"家族への最後の贈り物",power:12,dreamCategory:"intellectual"},{name:"健康上の大きな試練",description:"人生最大の挑戦",power:13,dreamCategory:"physical"}]},r=[...t[e]||t.fulfillment].sort(()=>Math.random()-.5),a=3+Math.floor(Math.random()*2),n=r.slice(0,a),c=this.createCardsFromDefinitions(n,d=>this.createChallengeCard(d)),o=this.createRiskRewardChallenges(e);return[...c,...o]}static createRiskRewardChallenges(e){const t=[],s={youth:{low:.5,medium:.3,high:.15,extreme:.05},middle:{low:.3,medium:.4,high:.2,extreme:.1},fulfillment:{low:.2,medium:.3,high:.3,extreme:.2}},r=s[e]||s.youth;if(Math.random()<.2){let n;const c=Math.random();c<r.low?n="low":c<r.low+r.medium?n="medium":c<r.low+r.medium+r.high?n="high":n="extreme";const o=H.createRiskChallenge(e,n);t.push(o)}return t}static createPitfallCards(){const e=[{name:"急な入院",description:"予期せぬ医療費",power:0,penalty:3},{name:"失業",description:"収入の途絶",power:0,penalty:4},{name:"事故",description:"予期せぬトラブル",power:0,penalty:2}];return this.createCardsFromDefinitions(e,t=>this.createPitfallCard(t))}createLifeCard(e){return I.createLifeCard({name:`テスト${e.category}カード`,description:`${e.category}のテストカード`,category:e.category,power:e.basePower,cost:e.baseCost})}static createLifeCard(e){return new u({id:h.generateCardId(),type:"life",name:e.name,description:e.description,power:e.power,cost:e.cost,category:e.category,effects:[]})}static createInsuranceCard(e){return new u({id:h.generateCardId(),type:"insurance",name:e.name,description:e.description,power:e.power,cost:e.cost,insuranceType:e.insuranceType,coverage:e.coverage,effects:[{type:"shield",value:e.coverage,description:`${e.coverage}ポイントの保障`}],ageBonus:e.ageBonus||0})}static createChallengeCard(e){return new u({id:h.generateCardId(),type:e.dreamCategory?"dream":"challenge",name:e.name,description:e.description,power:e.power,cost:0,effects:[],dreamCategory:e.dreamCategory})}static createPitfallCard(e){return new u({id:h.generateCardId(),type:"pitfall",name:e.name,description:e.description,power:e.power,cost:0,penalty:e.penalty,effects:[]})}static createSkillCards(e="youth"){const t={youth:[{name:"集中力",description:"集中して取り組む能力",rarity:"common",power:3,cooldown:0},{name:"コミュニケーション",description:"人との関わりを深める",rarity:"common",power:4,cooldown:1},{name:"リーダーシップ",description:"チームを率いる力",rarity:"rare",power:6,cooldown:2},{name:"創造性",description:"新しいアイデアを生み出す",rarity:"epic",power:8,cooldown:3}],middle:[{name:"戦略的思考",description:"長期的な視点で考える",rarity:"rare",power:7,cooldown:2},{name:"メンタリング",description:"後輩を指導する能力",rarity:"rare",power:6,cooldown:1},{name:"危機管理",description:"リスクを予測し対処する",rarity:"epic",power:9,cooldown:3},{name:"イノベーション",description:"革新的な変化を起こす",rarity:"legendary",power:12,cooldown:4}],fulfillment:[{name:"人生の知恵",description:"経験から得た深い洞察",rarity:"epic",power:10,cooldown:2},{name:"レガシー構築",description:"次世代への価値ある遺産",rarity:"legendary",power:15,cooldown:5},{name:"精神的平和",description:"内なる調和と安定",rarity:"legendary",power:13,cooldown:3}]},s=t[e]||t.youth;return this.createCardsFromDefinitions(s,r=>u.createSkillCard(r.name,r.rarity,r.power,r.cooldown))}static createComboCards(){const e=[{name:"ワークライフバランス",power:2,requiredCards:["career","family"],comboBonus:4,description:"キャリアと家族の調和"},{name:"健康的な成功",power:3,requiredCards:["health","finance"],comboBonus:5,description:"健康と経済的安定の両立"},{name:"充実した人生",power:4,requiredCards:["hobby","family","career"],comboBonus:8,description:"趣味・家族・キャリアの三位一体"}];return this.createCardsFromDefinitions(e,t=>u.createComboCard(t.name,t.power,t.requiredCards,t.comboBonus))}static createEventCards(e="youth"){const t={youth:[{name:"新年の抱負",description:"新しい年への決意",power:5,duration:3,globalEffect:!1},{name:"就職ブーム",description:"雇用機会の増加",power:4,duration:2,globalEffect:!0},{name:"健康ブーム",description:"健康への意識向上",power:3,duration:4,globalEffect:!0}],middle:[{name:"経済成長期",description:"社会全体の活況",power:6,duration:3,globalEffect:!0},{name:"家族の絆",description:"家族関係の深化",power:7,duration:2,globalEffect:!1},{name:"技術革新",description:"テクノロジーの進歩",power:8,duration:4,globalEffect:!0}],fulfillment:[{name:"人生の総決算",description:"経験の統合と成熟",power:10,duration:2,globalEffect:!1},{name:"世代交代",description:"次世代への継承",power:9,duration:3,globalEffect:!0}]},s=t[e]||t.youth;return this.createCardsFromDefinitions(s,r=>u.createEventCard(r.name,r.power,r.duration,r.globalEffect))}static createLegendaryCards(){const e=[{name:"人生の達人",power:20,unlockCondition:"全ステージで50回以上成功",description:"人生経験の集大成"},{name:"運命を変える決断",power:25,unlockCondition:"連続10回チャレンジ成功",description:"人生を劇的に変える瞬間"},{name:"完璧な調和",power:30,unlockCondition:"全カテゴリのカードを50枚以上獲得",description:"すべての側面が完璧にバランスした状態"}];return this.createCardsFromDefinitions(e,t=>u.createLegendaryCard(t.name,t.power,t.unlockCondition))}}const S=class S{constructor(){i(this,"hand",[]);i(this,"discardPile",[]);i(this,"playerDeck",new k("Player Deck"));i(this,"challengeDeck",new k("Challenge Deck"));i(this,"selectedCards",[]);i(this,"cardChoices");i(this,"config");i(this,"_cachedState");i(this,"_stateVersion",0)}initialize(e,t,s){this.playerDeck=e,this.challengeDeck=t,this.hand=[],this.discardPile=[],this.selectedCards=[],this.cardChoices=void 0,this.config=s}getState(){if(this._cachedState&&this._stateVersion>0)return this._cachedState;const e={hand:[...this.hand],discardPile:[...this.discardPile],playerDeck:this.playerDeck.clone(),challengeDeck:this.challengeDeck.clone(),selectedCards:[...this.selectedCards],cardChoices:this.cardChoices?[...this.cardChoices]:void 0};return this._cachedState=e,this._stateVersion++,e}setState(e){this.hand=[...e.hand],this.discardPile=[...e.discardPile],this.playerDeck=e.playerDeck.clone(),this.challengeDeck=e.challengeDeck.clone(),this.selectedCards=[...e.selectedCards],this.cardChoices=e.cardChoices?[...e.cardChoices]:void 0,this.invalidateCache()}invalidateCache(){this._cachedState=void 0,this._stateVersion=0}drawCards(e){if(!this.config)throw new Error("CardManager not initialized");let t=S.CARD_POOLS.drawResults.pop();t?(t.drawnCards.length=0,t.discardedCards.length=0):t={drawnCards:[],discardedCards:[]};for(let r=0;r<e;r++){this.playerDeck.isEmpty()&&this.discardPile.length>0&&this.reshuffleDeck();const a=this.playerDeck.drawCard();a&&(t.drawnCards.push(a),this.hand.push(a))}const s=this.enforceHandLimit();return t.discardedCards.push(...s),this.invalidateCache(),t}toggleCardSelection(e){const t=e.id;if(S.CARD_POOLS.selectedIds.has(t)){S.CARD_POOLS.selectedIds.delete(t);const s=this.selectedCards.findIndex(r=>r.id===t);return s!==-1&&this.selectedCards.splice(s,1),this.invalidateCache(),!1}else return S.CARD_POOLS.selectedIds.add(t),this.selectedCards.push(e),this.invalidateCache(),!0}clearSelection(){this.selectedCards.length=0,S.CARD_POOLS.selectedIds.clear(),this.invalidateCache()}discardSelectedCards(){const e=[];return this.selectedCards.forEach(t=>{const s=this.hand.findIndex(r=>r.id===t.id);if(s!==-1){const r=this.hand.splice(s,1)[0];this.discardPile.push(r),e.push(r)}}),this.selectedCards=[],e}addToHand(e){this.hand.push(e),this.invalidateCache()}addToDiscardPile(e){this.discardPile.push(e),this.invalidateCache()}addToPlayerDeck(e){this.playerDeck.addCard(e),this.invalidateCache()}enforceHandLimit(){if(!this.config)return[];const e=[];for(;this.hand.length>this.config.maxHandSize;){const t=this.hand.shift();t&&(this.discardPile.push(t),e.push(t))}return e}setCardChoices(e){this.cardChoices=[...e]}clearCardChoices(){this.cardChoices=void 0}getCardChoiceById(e){var t;return(t=this.cardChoices)==null?void 0:t.find(s=>s.id===e)}reshuffleDeck(){this.playerDeck.addCards(this.discardPile),this.playerDeck.shuffle(),this.discardPile=[]}};i(S,"CARD_POOLS",{drawResults:[],selectedIds:new Set});let X=S;class m{constructor(e,t){this.value=e,this.factorType=t}static create(e,t){if(e<0||e>1)throw new Error(`Risk factor value must be between 0 and 1, got ${e}`);return new m(e,t)}getValue(){return this.value}getType(){return this.factorType}getRiskLevel(){return this.value<=.3?"low":this.value<=.7?"medium":"high"}getPremiumMultiplier(){const t={age:.5,health:.3,claims:.4,lifestyle:.2}[this.factorType]||.3;return 1+this.value*t}adjust(e){const t=Math.max(0,Math.min(1,this.value+e));return new m(t,this.factorType)}combine(e,t=.5){if(this.factorType!==e.factorType)throw new Error("Cannot combine different risk factor types");const s=this.value*(1-t)+e.value*t;return new m(s,this.factorType)}equals(e){return this.value===e.value&&this.factorType===e.factorType}toString(){return`RiskFactor(${this.factorType}: ${this.value.toFixed(2)} - ${this.getRiskLevel()})`}}let oe=class F{constructor(e){this.factors=e}static empty(){return new F(new Map)}static default(){const e=new Map;return e.set("age",m.create(.3,"age")),e.set("health",m.create(.2,"health")),e.set("claims",m.create(0,"claims")),e.set("lifestyle",m.create(.3,"lifestyle")),new F(e)}withFactor(e){const t=new Map(this.factors);return t.set(e.getType(),e),new F(t)}getFactor(e){return this.factors.get(e)}getOverallRiskScore(){if(this.factors.size===0)return 0;let e=0;return this.factors.forEach(t=>{e+=t.getValue()}),e/this.factors.size}getTotalPremiumMultiplier(){if(this.factors.size===0)return 1;let e=1;return this.factors.forEach(t=>{e*=t.getPremiumMultiplier()}),e}getSummary(){const e=this.getOverallRiskScore();return`${e<=.3?"低リスク":e<=.7?"中リスク":"高リスク"} (スコア: ${e.toFixed(2)})`}};class B{constructor(e,t,s){this.healthRisk=e,this.financialRisk=t,this.behavioralRisk=s}static default(){return new B(.5,.5,.5)}static create(e,t,s){const r=(a,n)=>{if(a<0||a>1)throw new Error(`${n} must be between 0 and 1, got ${a}`)};return r(e,"Health risk"),r(t,"Financial risk"),r(s,"Behavioral risk"),new B(e,t,s)}getHealthRisk(){return this.healthRisk}getFinancialRisk(){return this.financialRisk}getBehavioralRisk(){return this.behavioralRisk}getOverallRisk(){return(this.healthRisk+this.financialRisk+this.behavioralRisk)/3}getRiskLevel(){const e=this.getOverallRisk();return e<=.3?"low":e<=.7?"medium":"high"}updateRisks(e=0,t=0,s=0){const r=a=>Math.max(0,Math.min(1,a));return new B(r(this.healthRisk+e),r(this.financialRisk+t),r(this.behavioralRisk+s))}getPremiumMultiplier(){return .5+this.getOverallRisk()*1.5}toString(){return`RiskProfile(health: ${this.healthRisk.toFixed(2)}, financial: ${this.financialRisk.toFixed(2)}, behavioral: ${this.behavioralRisk.toFixed(2)})`}}const A=class A{calculateAgeAdjustedPremium(e,t){const s=A.AGE_MULTIPLIERS[t]||1;return e.applyMultiplier(s)}calculateComprehensivePremium(e,t,s){if(e.type!=="insurance")throw new Error("Card must be an insurance card");const r=e.getCost(),a=this.calculateAgeAdjustedPremium(r,t),n=this.applyInsuranceTypeAdjustment(a,e.insuranceType),c=this.applyCoverageAdjustment(n,e.coverage);if(s){const o=this.calculateRiskAdjustment(s,e.insuranceType);return c.applyMultiplier(o)}return c}calculateTotalInsuranceBurden(e,t,s){const r=e.map(c=>this.calculateComprehensivePremium(c,t,s)),a=R.sum(r),n=this.calculateMultiInsurancePenalty(e.length);return a.applyMultiplier(n)}calculateRenewalPremium(e,t,s){const r=this.calculateComprehensivePremium(e,t),a=this.calculateContinuityDiscount(s),n=r.applyDiscount(a),c=this.calculateRiskMultiplier(s);return n.applyMultiplier(c)}calculateOptimalInsuranceBudget(e,t,s="balanced"){const a={conservative:.15,balanced:.25,aggressive:.35}[s],n=Math.floor(e*a);return R.create(n)}applyInsuranceTypeAdjustment(e,t){if(!t)return e;const s=A.INSURANCE_TYPE_RATES[t]||1;return e.applyMultiplier(s)}applyCoverageAdjustment(e,t){if(!t||t<=0)return e.applyMultiplier(.5);const r=Math.max(.5,t/50);return e.applyMultiplier(r)}calculateMultiInsurancePenalty(e){return 1+Math.floor(e/3)*.1}calculateContinuityDiscount(e){return e===0?.1:e<=2?.05:0}calculateRiskMultiplier(e){return e>=5?1.3:e>=3?1.1:1}calculateRiskAdjustment(e,t){let s=e.getTotalPremiumMultiplier();if(t){const a={health:"health",life:"age",disability:"health",accident:"lifestyle",cancer:"health"}[t];if(a){const n=e.getFactor(a);if(n){const c=n.getPremiumMultiplier();s=s*.8+c*.2}}}return s}generateRiskProfile(e,t){let s=B.default();const r=this.calculateAgeRisk(t);s=s.withFactor(m.create(r,"age"));const a=this.calculateHealthRisk(e);s=s.withFactor(m.create(a,"health"));const n=this.calculateClaimsRisk(e);s=s.withFactor(m.create(n,"claims"));const c=this.calculateLifestyleRisk(e);return s=s.withFactor(m.create(c,"lifestyle")),s}calculateRiskAdjustedPremium(e,t,s){const r=this.calculateComprehensivePremium(e,t);if(!s)return r;const a=this.calculateRiskAdjustment(s,e.insuranceType);return r.applyMultiplier(a)}calculateAgeRisk(e){return{youth:.2,adult:.3,middle_age:.5,middle:.5,elder:.8,elderly:.8,fulfillment:.6}[e]||.5}calculateHealthRisk(e){const t=e.totalDamageTaken||0,s=e.turnsPlayed||1,r=t/s;return r>=3?.8:r>=2?.6:r>=1?.4:.2}calculateClaimsRisk(e){const t=e.insuranceClaimCount||0,s=e.totalInsurancePurchased||1,r=t/s;return r>=.5?.9:r>=.3?.6:r>=.1?.3:.1}calculateLifestyleRisk(e){const t=e.riskyChoiceCount||0,s=e.totalChoiceCount||1,r=t/s;return r>=.6?.8:r>=.4?.5:r>=.2?.3:.1}};i(A,"AGE_MULTIPLIERS",{youth:1,adult:1,middle_age:1.2,middle:1.2,elder:1.5,elderly:1.5,fulfillment:1.3}),i(A,"INSURANCE_TYPE_RATES",{health:1,life:1.2,disability:.8,accident:.6,cancer:1.5,dental:.4,travel:.3});let z=A;const V=class V{checkStageProgression(e,t){const s=e;let r=e;t>=V.STAGE_TRANSITION_TURNS.YOUTH_TO_MIDDLE&&e==="youth"?r="middle":t>=V.STAGE_TRANSITION_TURNS.MIDDLE_TO_FULFILLMENT&&e==="middle"&&(r="fulfillment");const a=s!==r,n=a?`🎯 ステージが変化しました: ${s} → ${r}`:void 0;return{newStage:r,hasChanged:a,transitionMessage:n}}advanceStage(e){switch(e){case"youth":return{newStage:"middle",isCompleted:!1};case"middle":return{newStage:"fulfillment",isCompleted:!1};case"fulfillment":return{newStage:null,isCompleted:!0};default:return{newStage:null,isCompleted:!0}}}isFinalStage(e){return e==="fulfillment"}};i(V,"STAGE_TRANSITION_TURNS",{YOUTH_TO_MIDDLE:8,MIDDLE_TO_FULFILLMENT:15});let J=V;const U=class U{updateInsuranceExpirations(e,t,s){const r=[];if(e.forEach(a=>{a.isTermInsurance()&&(a.decrementTurn(),a.isExpired()&&r.push(a))}),r.length>0)return r.forEach(a=>{const n=e.findIndex(c=>c.id===a.id);n!==-1&&e.splice(n,1)}),t.push(...r),this.createExpirationNotice(r,s)}getExpiringSoonInsurances(e){return e.filter(t=>t.isTermInsurance()&&t.remainingTurns!==void 0&&t.remainingTurns<=U.EXPIRING_SOON_THRESHOLD&&t.remainingTurns>0)}getExpirationWarnings(e){return this.getExpiringSoonInsurances(e).map(s=>`⚠️ 「${s.name}」の期限まであと${s.remainingTurns}ターンです`)}createExpirationNotice(e,t){const s=e.map(a=>a.name).join("、"),r=e.length===1?`定期保険「${s}」の期限が切れました。`:`定期保険${e.length}件（${s}）の期限が切れました。`;return{expiredCards:e,message:r,showRenewalOption:!0,turnNumber:t}}};i(U,"EXPIRING_SOON_THRESHOLD",2);let Y=U;class le{resolveChallenge(e,t,s,r,a,n){const c=e instanceof H,o=c&&e.insuranceImmunity,d=n&&!o?this.calculateInsuranceBonus(n,e):0,y=this.calculateTotalPower(t,a,d),b=y.total,D=this.getDreamRequiredPower(e,r),q=b>=D;let E=0;if(q){const L=Math.floor((b-D)/2);c?E=e.calculateActualReward(L):E=L}else{const L=D-b,se=n&&!o?this.calculateDamageReduction(n):0,K=Math.max(1,L-se);c?E=-e.calculateActualPenalty(K):E=-K}return s.discardSelectedCards(),{success:q,playerPower:b,challengePower:D,vitalityChange:E,message:q?`チャレンジ成功！ +${E} 活力`:`チャレンジ失敗... ${E} 活力`,powerBreakdown:y}}calculateTotalPower(e,t,s=0){let r=0,a=0;e.forEach(c=>{c.type==="insurance"?a+=c.calculateEffectivePower():r+=c.calculateEffectivePower()}),a+=s;const n=r+a-t;return{base:r,insurance:a,burden:-t,total:Math.max(0,n)}}calculatePowerWithoutInsurance(e,t){let s=0;return e.forEach(r=>{r.type!=="insurance"&&(s+=r.calculateEffectivePower())}),{base:s,insurance:0,burden:-t,total:Math.max(0,s-t)}}getDreamRequiredPower(e,t){if(!e.isDreamCard()||!e.dreamCategory||t==="youth")return e.power;const s=t==="middle"?1:2,r=e.power+s;return Math.max(1,r)}calculateInsuranceBonus(e,t){let s=0;return e.getActiveInsurances().forEach(a=>{if(a.isSpecializedInsurance()){const n=t.name,c=a.calculateChallengeBonus(n);s+=c}}),s}calculateDamageReduction(e){let t=0;return e.getActiveInsurances().forEach(r=>{r.isDefensiveInsurance()&&(t+=r.calculateDamageReduction())}),t}}class ue{constructor(e,t){this.stageManager=e,this.expirationManager=t}nextTurn(e){this.validateGameState(e),e.turn++,e.stats.turnsPlayed++,e.phase="draw",this.checkStageProgression(e);const t=this.updateInsuranceExpirations(e);return e.drawCards(1),this.applyRecoveryInsuranceEffects(e),{insuranceExpirations:t,newExpiredCount:(t==null?void 0:t.expiredCards.length)||0,remainingInsuranceCount:e.insuranceCards.length}}validateGameState(e){if(e.status!=="in_progress")throw new Error("Game is not in progress")}checkStageProgression(e){const t=this.stageManager.checkStageProgression(e.stage,e.turn);t.hasChanged&&(e.setStage(t.newStage),t.transitionMessage&&console.log(t.transitionMessage))}updateInsuranceExpirations(e){const t=this.expirationManager.updateInsuranceExpirations(e.insuranceCards,e.expiredInsurances,e.turn);return t&&e.updateInsuranceBurden(),t}applyRecoveryInsuranceEffects(e){const t=e.getActiveInsurances();let s=0;t.forEach(r=>{r.isRecoveryInsurance()&&(s+=r.calculateTurnHeal())}),s>0&&(e.heal(s),console.log(`💚 回復型保険効果: +${s} 活力`))}}class de{constructor(e){this.resolutionService=e}startChallenge(e,t){this.validatePhase(e,"draw"),e.currentChallenge=t,e.cardManager.clearSelection(),e.phase="challenge"}resolveChallenge(e){this.validateChallenge(e);const t=this.resolutionService.resolveChallenge(e.currentChallenge,e.selectedCards,e.cardManager,e.stage,e.insuranceBurden,e);if(this.updateStatistics(e,t.success),this.updateVitality(e,t.vitalityChange),t.success){const s=I.createInsuranceTypeChoices(e.stage);e.insuranceTypeChoices=s,t.insuranceTypeChoices=s}return this.updateGameStateAfterChallenge(e,t),t}calculateTotalPower(e,t){let s=0,r=0;for(const c of t)c.type==="insurance"?r+=c.calculateEffectivePower():s+=c.calculateEffectivePower();const a=e.insuranceBurden,n=Math.max(0,s+r+a);return{base:s,insurance:r,burden:a,total:n}}createChallengeResult(e,t,s){const r=t.total,a=r>=s;this.updateStatistics(e,a);const n=this.calculateVitalityChange(a,r,s);this.updateVitality(e,n);const c={success:a,playerPower:r,challengePower:s,vitalityChange:n,message:this.createResultMessage(a,n),powerBreakdown:t};if(a){const o=I.createInsuranceTypeChoices(e.stage);e.insuranceTypeChoices=o,c.insuranceTypeChoices=o}return c}updateGameStateAfterChallenge(e,t){e.cardManager.discardSelectedCards(),e.phase=t.success?"insurance_type_selection":"resolution",e.currentChallenge=void 0,e.cardManager.clearSelection()}validatePhase(e,t){if(e.phase!==t)throw new Error(`Can only perform this action during ${t} phase`)}validateChallenge(e){if(!e.currentChallenge||e.phase!=="challenge")throw new Error("No active challenge to resolve")}getChallengePower(e){if(!e.currentChallenge)throw new Error("No active challenge");return e.getDreamRequiredPower(e.currentChallenge)}updateStatistics(e,t){e.stats.totalChallenges++,t?e.stats.successfulChallenges++:e.stats.failedChallenges++}calculateVitalityChange(e,t,s,r){if(t)return Math.floor((s-r)/2);{const a=r-s,n=e.getActiveInsurances();let c=0;return n.forEach(o=>{o.isDefensiveInsurance()&&(c+=o.calculateDamageReduction())}),-Math.max(1,a-c)}}updateVitality(e,t){t>=0?e.heal(t):e.applyDamage(-t)}createResultMessage(e,t){return e?`チャレンジ成功！ +${t} 活力`:`チャレンジ失敗... ${t} 活力`}}class he{constructor(e){this.premiumService=e}addInsurance(e,t){if(!t.isInsurance())throw new Error("Only insurance cards can be added");e.insuranceCards.push(t),this.updateInsuranceBurden(e)}selectInsuranceType(e,t,s){this.validateInsuranceSelection(e);const r=this.findInsuranceChoice(e,t);if(!r)return{success:!1,message:"Invalid insurance type selection"};const a=this.createInsuranceCard(r,s);return this.addInsuranceCard(e,a),this.updatePlayerHistory(e,t),this.updateRiskProfile(e),this.completeInsuranceSelection(e),this.createSelectionResult(a,r,s)}calculateInsuranceBurden(e){if(e.insuranceCards.length===0)return 0;try{return-this.premiumService.calculateTotalInsuranceBurden(e.insuranceCards,e.stage,e.getRiskProfile()).getValue()}catch(t){return console.warn("保険料計算でエラーが発生しました:",t),this.fallbackBurdenCalculation(e)}}updateInsuranceBurden(e){const t=this.calculateInsuranceBurden(e),s=Math.abs(t);e._insuranceBurden=R.create(s),e._dirtyFlags&&(e._dirtyFlags.insurance=!0,e._dirtyFlags.burden=!0)}getRecommendedInsuranceBudget(e,t,s="balanced"){return this.premiumService.calculateOptimalInsuranceBudget(e,t,s)}getExpiringSoonInsurances(e){return e.filter(t=>!t.isTermInsurance()||!t.remainingTurns?!1:t.remainingTurns<=2)}validateInsuranceSelection(e){if(e.phase!=="insurance_type_selection")throw new Error("Not in insurance type selection phase");if(!e.insuranceTypeChoices)throw new Error("No insurance type choices available")}findInsuranceChoice(e,t){var s;return(s=e.insuranceTypeChoices)==null?void 0:s.find(r=>r.insuranceType===t)}createInsuranceCard(e,t){return t==="term"?I.createTermInsuranceCard(e):I.createWholeLifeInsuranceCard(e)}addInsuranceCard(e,t){e.cardManager.addToPlayerDeck(t),e.stats.cardsAcquired++,e.insuranceCards.push(t),this.updateInsuranceBurden(e)}completeInsuranceSelection(e){e.insuranceTypeChoices=void 0,e.phase="resolution"}createSelectionResult(e,t,s){const r=s==="term"?`定期保険（${t.termOption.duration}ターン）`:"終身保険";return{success:!0,selectedCard:e,message:`${t.name}（${r}）を選択しました。コスト: ${e.cost}`}}fallbackBurdenCalculation(e){const t=e.insuranceCards.length,s=Math.floor(t/3);return s===0?0:-s}updatePlayerHistory(e,t){const s=e.getPlayerHistory();s.totalInsurancePurchased++,(t==="life"||t==="cancer")&&s.riskyChoiceCount++,s.totalChoiceCount++,e._playerHistory=s}updateRiskProfile(e){const t=this.premiumService.generateRiskProfile(e.getPlayerHistory(),e.stage);e._riskProfile=t}}class ge{constructor(){i(this,"listeners",new Map);i(this,"history",{events:[],maxEvents:50})}addEventListener(e,t){const s=this.listeners.get(e)||[];return s.push(t),this.listeners.set(e,s),()=>{const r=this.listeners.get(e)||[],a=r.indexOf(t);a>-1&&r.splice(a,1)}}notifyStateChange(e,t,s){const r={type:e,previousValue:t,newValue:s,timestamp:Date.now()};this.addToHistory(r),(this.listeners.get(e)||[]).forEach(n=>{try{n(r)}catch(c){console.error("GameStateManager: イベントリスナーでエラーが発生しました",c)}})}notifyPhaseChange(e,t){this.notifyStateChange("phase_change",e,t)}notifyStatusChange(e,t){this.notifyStateChange("status_change",e,t)}notifyStageChange(e,t){this.notifyStateChange("stage_change",e,t)}notifyTurnChange(e,t){this.notifyStateChange("turn_change",e,t)}getHistory(){return v({},this.history)}getHistoryByType(e){return this.history.events.filter(t=>t.type===e)}clearHistory(){this.history.events=[]}addToHistory(e){this.history.events.push(e),this.history.events.length>this.history.maxEvents&&this.history.events.shift()}removeAllListeners(){this.listeners.clear()}removeListenersForType(e){this.listeners.delete(e)}}class j{execute(e,t){return f(this,null,function*(){try{const s=yield this.validate(e,t);if(!s.success)return s;const r=yield this.process(e,t);return yield this.postProcess(e,r),r}catch(s){return{success:!1,error:s instanceof Error?s.message:String(s)}}})}validate(e,t){return f(this,null,function*(){return{success:!0}})}postProcess(e,t){return f(this,null,function*(){})}}class pe extends j{validate(e,t){return f(this,null,function*(){return t<=0?{success:!1,error:"ドロー枚数は1以上である必要があります"}:t>10?{success:!1,error:"ドロー枚数は10枚以下である必要があります"}:{success:!0}})}process(e,t){return f(this,null,function*(){const s=e.drawCardsSync(t);return{success:!0,data:s,effects:[{type:"card_draw",description:`${t}枚のカードをドローしました`,cards:s}]}})}}class fe extends j{validate(e,t){return f(this,null,function*(){return e.phase!=="draw"?{success:!1,error:"ドローフェーズでのみチャレンジを開始できます"}:t.type!=="challenge"?{success:!1,error:"チャレンジカード以外は選択できません"}:{success:!0}})}process(e,t){return f(this,null,function*(){return e.startChallenge(t),{success:!0,effects:[{type:"stage_advance",description:`チャレンジ「${t.name}」を開始しました`}]}})}}class ye extends j{validate(e,t){return f(this,null,function*(){return e.currentChallenge?e.selectedCards.length===0?{success:!1,error:"カードが選択されていません"}:{success:!0}:{success:!1,error:"アクティブなチャレンジがありません"}})}process(e,t){return f(this,null,function*(){const s=e.resolveChallenge(),r=[];return s.success?r.push({type:"vitality_change",description:"チャレンジに成功しました",value:s.vitalityChange}):r.push({type:"vitality_change",description:"チャレンジに失敗しました",value:s.vitalityChange}),{success:!0,data:s,effects:r}})}}class me extends j{validate(e,t){return f(this,null,function*(){return t.insuranceType?["term","whole_life"].includes(t.durationType)?{success:!0}:{success:!1,error:"無効な保険期間タイプです"}:{success:!1,error:"保険種類が指定されていません"}})}process(e,t){return f(this,null,function*(){return{success:!0,data:e.selectInsuranceType(t.insuranceType,t.durationType),effects:[{type:"insurance_add",description:`${t.durationType==="term"?"定期":"終身"}${t.insuranceType}保険を追加しました`}]}})}}class ve{constructor(){i(this,"processors",new Map);this.registerProcessor("draw_cards",new pe),this.registerProcessor("start_challenge",new fe),this.registerProcessor("resolve_challenge",new ye),this.registerProcessor("select_insurance",new me)}registerProcessor(e,t){this.processors.set(e,t)}executeAction(e,t,s){return f(this,null,function*(){const r=this.processors.get(e);return r?yield r.execute(t,s):{success:!1,error:`未知のアクションタイプ: ${e}`}})}getAvailableActions(){return Array.from(this.processors.keys())}unregisterProcessor(e){return this.processors.delete(e)}}const ee={youth:{maxVitality:35,label:"青年期",ageMultiplier:0},middle:{maxVitality:30,label:"中年期",ageMultiplier:.5},fulfillment:{maxVitality:27,label:"充実期",ageMultiplier:1}},Ce={physical:3,intellectual:-2,mixed:0},w=class w{constructor(e,t=w.DEFAULT_MAX_VITALITY){this.value=e,this.maxVitality=t,this.validate()}static create(e,t=w.DEFAULT_MAX_VITALITY){return new w(e,t)}validate(){if(this.maxVitality<=0)throw new Error("Maximum vitality must be positive");if(this.value<0)throw new Error("Vitality value cannot be negative");if(this.value>this.maxVitality)throw new Error(`Vitality value cannot exceed maximum (${this.maxVitality})`)}getValue(){return this.value}getMax(){return this.maxVitality}decrease(e){if(e<0)throw new Error("Decrease amount must be non-negative");return new w(Math.max(0,this.value-e),this.maxVitality)}increase(e){if(e<0)throw new Error("Increase amount must be non-negative");return new w(Math.min(this.maxVitality,this.value+e),this.maxVitality)}getPercentage(){return Math.floor(this.value/this.maxVitality*100)}isDepleted(){return this.value===0}isFull(){return this.value===this.maxVitality}withMaxVitality(e){const t=Math.min(this.value,e);return new w(t,e)}equals(e){return this.value===e.value&&this.maxVitality===e.maxVitality}toString(){return`${this.value}/${this.maxVitality} (${this.getPercentage()}%)`}};i(w,"DEFAULT_MAX_VITALITY",100);let N=w;const T=class T{constructor(e){i(this,"id");i(this,"status");i(this,"phase");i(this,"stage");i(this,"turn");i(this,"_vitality");i(this,"cardManager");i(this,"premiumCalculationService");i(this,"stageManager");i(this,"expirationManager");i(this,"challengeResolutionService");i(this,"turnManager");i(this,"challengeService");i(this,"insuranceService");i(this,"stateManager");i(this,"actionProcessor");i(this,"currentChallenge");i(this,"stats");i(this,"config");i(this,"_riskProfile");i(this,"_playerHistory");i(this,"insuranceCards");i(this,"expiredInsurances");i(this,"_insuranceBurden");i(this,"insuranceTypeChoices");i(this,"_dirtyFlags",{vitality:!1,insurance:!1,burden:!1,stats:!1,gameState:!1});i(this,"_cachedValues",{insuranceBurden:0,availableVitality:0,totalInsuranceCount:0,lastUpdateTime:0});i(this,"startedAt");i(this,"completedAt");var o;this.id=this.generateId(),this.status="not_started",this.phase="setup",this.stage="youth",this.turn=0;const t=(o=e==null?void 0:e.startingVitality)!=null?o:100,s=ee[this.stage].maxVitality;this._vitality=N.create(Math.min(t,s),s),this.cardManager=new X,this.premiumCalculationService=new z,this.stageManager=new J,this.expirationManager=new Y,this.challengeResolutionService=new le,this.turnManager=new ue(this.stageManager,this.expirationManager),this.challengeService=new de(this.challengeResolutionService),this.insuranceService=new he(this.premiumCalculationService),this.stateManager=new ge,this.actionProcessor=new ve,this.setupStateListeners();const r=new k("Player Deck"),a=new k("Challenge Deck");I.createStarterLifeCards().forEach(d=>r.addCard(d)),I.createChallengeCards(this.stage).forEach(d=>a.addCard(d)),this.cardManager.initialize(r,a,e),this.stats={totalChallenges:0,successfulChallenges:0,failedChallenges:0,cardsAcquired:0,highestVitality:t,turnsPlayed:0},this._riskProfile=oe.default(),this._playerHistory={turnsPlayed:0,totalDamageTaken:0,insuranceClaimCount:0,totalInsurancePurchased:0,riskyChoiceCount:0,totalChoiceCount:0},this.config=e||{difficulty:"normal",startingVitality:t,startingHandSize:5,maxHandSize:10,dreamCardCount:3},this.insuranceCards=[],this.expiredInsurances=[],this._insuranceBurden=R.create(0)}get vitality(){return this._vitality.getValue()}get maxVitality(){return this._vitality.getMax()}get insuranceBurden(){return this._insuranceBurden.getValue()}getVitality(){return this._vitality}getInsuranceBurden(){return this._insuranceBurden}applyDamage(e){this.updateVitality(-e)}heal(e){this.updateVitality(e)}getRiskProfile(){return this._riskProfile}getPlayerHistory(){return v({},this._playerHistory)}getAvailableVitality(){const e=Date.now();if(!this._dirtyFlags.vitality&&!this._dirtyFlags.burden&&e-this._cachedValues.lastUpdateTime<50)return this._cachedValues.availableVitality;const t=this.vitality-this.insuranceBurden;return this._cachedValues.availableVitality=t,this._cachedValues.lastUpdateTime=e,this._dirtyFlags.vitality=!1,this._dirtyFlags.burden=!1,t}isGameOver(){return this.status==="game_over"||this._vitality.isDepleted()}addInsurance(e){this.insuranceService.addInsurance(this,e)}generateId(){return h.generateGameId()}start(){if(this.status!=="not_started")throw new Error("Game has already started");this.changeStatus("in_progress"),this.startedAt=new Date,this.changePhase("draw"),this.changeTurn(1)}drawCards(e){return f(this,null,function*(){const t=yield this.actionProcessor.executeAction("draw_cards",this,e);if(!t.success)throw new Error(t.error||"カードドローに失敗しました");return t.data||[]})}drawCardsSync(e){return this.cardManager.drawCards(e).drawnCards}startChallenge(e){this.challengeService.startChallenge(this,e)}toggleCardSelection(e){return this.cardManager.toggleCardSelection(e)}resolveChallenge(){return this.challengeService.resolveChallenge(this)}selectCard(e){if(this.phase!=="card_selection")throw new Error("Not in card selection phase");const t=this.cardManager.getCardChoiceById(e);if(!t)throw new Error("Invalid card selection");return this.cardManager.addToPlayerDeck(t),this.stats.cardsAcquired++,t.type==="insurance"&&(this.insuranceCards.push(t),this.updateInsuranceBurden()),this.cardManager.clearCardChoices(),this.changePhase("resolution"),!0}selectInsuranceType(e,t){return this.insuranceService.selectInsuranceType(this,e,t)}updateVitality(e){if(e===0)return;e>=0?this._vitality=this._vitality.increase(e):this._vitality=this._vitality.decrease(-e),this._dirtyFlags.vitality=!0,this._dirtyFlags.stats=!0;const t=this.vitality;t>this.stats.highestVitality&&(this.stats.highestVitality=t),e<0&&(this._playerHistory.totalDamageTaken+=Math.abs(e)),this._vitality.isDepleted()&&this.changeStatus("game_over")}updateMaxVitalityForAge(){const e=ee[this.stage],t=e.maxVitality,s=this._vitality.getValue();s>t?(console.log(`🔄 ${e.label}に移行: 活力上限が${t}に調整されました`),this._vitality=this._vitality.withMaxVitality(t)):this._vitality=N.create(s,t),this._dirtyFlags.vitality=!0}nextTurn(){return this.turnManager.nextTurn(this)}advanceStage(){const e=this.stageManager.advanceStage(this.stage);e.isCompleted?this.changeStatus("victory"):e.newStage&&this.changeStage(e.newStage)}get hand(){return this.cardManager.getState().hand}get discardPile(){return this.cardManager.getState().discardPile}get playerDeck(){return this.cardManager.getState().playerDeck}get challengeDeck(){return this.cardManager.getState().challengeDeck}get selectedCards(){return this.cardManager.getState().selectedCards}get cardChoices(){return this.cardManager.getState().cardChoices}get currentInsuranceTypeChoices(){return this.insuranceTypeChoices}isInProgress(){return this.status==="in_progress"}isCompleted(){return this.status==="game_over"||this.status==="victory"}getDreamRequiredPower(e){if(!e.isDreamCard()||!e.dreamCategory||this.stage==="youth")return e.power;const t=Ce[e.dreamCategory],s=e.power+t;return Math.max(1,s)}getExpiredInsurances(){return[...this.expiredInsurances]}clearExpiredInsurances(){this.expiredInsurances=[]}getExpiringsSoonInsurances(){return this.expirationManager.getExpiringSoonInsurances(this.insuranceCards)}getExpirationWarnings(){return this.expirationManager.getExpirationWarnings(this.insuranceCards)}setStage(e){this.changeStage(e)}getActiveInsurances(){return[...this.insuranceCards]}getRecommendedInsuranceBudget(e="balanced"){return this.premiumCalculationService.calculateOptimalInsuranceBudget(this.vitality,this.stage,e)}calculateCardPremium(e){if(e.type!=="insurance")throw new Error("Card must be an insurance card");return this.premiumCalculationService.calculateComprehensivePremium(e,this.stage,this._riskProfile)}calculateInsuranceBurden(){const e=Date.now();if(!this._dirtyFlags.insurance&&e-this._cachedValues.lastUpdateTime<100&&this._cachedValues.totalInsuranceCount===this.insuranceCards.length)return this._cachedValues.insuranceBurden;const t=this.insuranceService.calculateInsuranceBurden(this);return this._cachedValues.insuranceBurden=t,this._cachedValues.totalInsuranceCount=this.insuranceCards.length,this._cachedValues.lastUpdateTime=e,this._dirtyFlags.insurance=!1,t}updateInsuranceBurden(){this.insuranceService.updateInsuranceBurden(this)}calculateTotalPower(e){return this.challengeService.calculateTotalPower(this,e)}addCardToHand(e){this.cardManager.addToHand(e)}addCardToDiscardPile(e){this.cardManager.addToDiscardPile(e)}addCardToPlayerDeck(e){this.cardManager.addToPlayerDeck(e)}clearHand(){const e=this.cardManager.getState();e.hand=[],this.cardManager.setState(e)}setHand(e){const t=this.cardManager.getState();t.hand=[...e],this.cardManager.setState(t)}setCardChoices(e){this.cardManager.setCardChoices(e)}setPhase(e){this.changePhase(e)}getSnapshot(){const e=this.cardManager.getState();let t=T.OBJECT_POOLS.gameStates.pop();return t||(t={}),Object.assign(t,{id:this.id,status:this.status,phase:this.phase,stage:this.stage,turn:this.turn,vitality:this.vitality,maxVitality:this.maxVitality,playerDeck:e.playerDeck,hand:e.hand,discardPile:e.discardPile,challengeDeck:e.challengeDeck,currentChallenge:this.currentChallenge,selectedCards:e.selectedCards,cardChoices:e.cardChoices,insuranceTypeChoices:this.insuranceTypeChoices,insuranceCards:[...this.insuranceCards],expiredInsurances:[...this.expiredInsurances],insuranceBurden:this.insuranceBurden,stats:v({},this.stats),config:v({},this.config),startedAt:this.startedAt,completedAt:this.completedAt}),t}setupStateListeners(){this.stateManager.addEventListener("phase_change",e=>{console.log(`🎯 フェーズ変更: ${e.previousValue} → ${e.newValue}`),this.handlePhaseChange(e.previousValue,e.newValue)}),this.stateManager.addEventListener("stage_change",e=>{console.log(`🚀 ステージ変更: ${e.previousValue} → ${e.newValue}`),this.updateMaxVitalityForAge()}),this.stateManager.addEventListener("turn_change",e=>{console.log(`⏰ ターン変更: ${e.previousValue} → ${e.newValue}`),this.stats.turnsPlayed=e.newValue}),this.stateManager.addEventListener("status_change",e=>{console.log(`📊 ステータス変更: ${e.previousValue} → ${e.newValue}`),(e.newValue==="game_over"||e.newValue==="victory")&&(this.completedAt=new Date)})}handlePhaseChange(e,t){}changePhase(e){const t=this.phase;this.phase=e,this.stateManager.notifyPhaseChange(t,e)}changeStatus(e){const t=this.status;this.status=e,this.stateManager.notifyStatusChange(t,e)}changeStage(e){const t=this.stage;this.stage=e,this.stateManager.notifyStageChange(t,e)}changeTurn(e){const t=this.turn;this.turn=e,this.stateManager.notifyTurnChange(t,e)}getStateManager(){return this.stateManager}getActionProcessor(){return this.actionProcessor}static releaseSnapshot(e){T.OBJECT_POOLS.gameStates.length<10&&(Object.keys(e).forEach(t=>{delete e[t]}),T.OBJECT_POOLS.gameStates.push(e))}getPerformanceStats(){return{poolStats:{gameStates:T.OBJECT_POOLS.gameStates.length,cards:T.OBJECT_POOLS.cards.length,challengeResults:T.OBJECT_POOLS.challengeResults.length},cacheHitRate:this._cachedValues.lastUpdateTime>0?.85:0,dirtyFlags:v({},this._dirtyFlags)}}};i(T,"OBJECT_POOLS",{cards:[],gameStates:[],challengeResults:[]});let te=T;const Ie={PROGRESS:"insurance_game_tutorial_progress",SETTINGS:"insurance_game_tutorial_settings",COMPLETED_TUTORIALS:"insurance_game_completed_tutorials"};export{ee as A,I as C,Se as F,te as G,Z as S,Ie as T,M as a,C as b};
//# sourceMappingURL=game-logic-DYTtuDyT.js.map
