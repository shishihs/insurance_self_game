name: üõ°Ô∏è Deployment Safety System

on:
  workflow_run:
    workflows: ["üöÄ Automated Deployment Pipeline"]
    types: [completed]
  workflow_dispatch:
    inputs:
      action:
        description: 'Safety action to perform'
        required: true
        type: choice
        options:
          - health-check
          - rollback
          - canary-analysis
          - smoke-test
      target_deployment:
        description: 'Target deployment ID (for rollback)'
        required: false

permissions:
  contents: write
  pages: write
  id-token: write
  actions: read
  deployments: write

env:
  HEALTH_CHECK_TIMEOUT: 300
  ROLLBACK_TIMEOUT: 600

jobs:
  # Deployment health monitoring
  health-monitoring:
    name: üè• Deployment Health Monitoring
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event.inputs.action == 'health-check'
    outputs:
      health_status: ${{ steps.health-check.outputs.status }}
      deployment_url: ${{ steps.health-check.outputs.url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Comprehensive health check
        id: health-check
        timeout-minutes: 10
        run: |
          DEPLOYMENT_URL="https://shishihs.github.io/insurance_self_game/"
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          
          echo "üè• Starting comprehensive health check for: $DEPLOYMENT_URL"
          
          # Initialize health metrics
          HEALTH_SCORE=0
          MAX_SCORE=100
          
          # 1. Basic connectivity (20 points)
          echo "üîå Testing basic connectivity..."
          if curl -sf "$DEPLOYMENT_URL" -o /dev/null; then
            echo "‚úÖ Basic connectivity: OK"
            HEALTH_SCORE=$((HEALTH_SCORE + 20))
          else
            echo "‚ùå Basic connectivity: FAILED"
          fi
          
          # 2. Health endpoint (20 points)
          echo "ü©∫ Testing health endpoint..."
          if HEALTH_DATA=$(curl -sf "$DEPLOYMENT_URL/health"); then
            echo "‚úÖ Health endpoint: OK"
            echo "Health data: $HEALTH_DATA"
            HEALTH_SCORE=$((HEALTH_SCORE + 20))
          else
            echo "‚ö†Ô∏è Health endpoint: Not available"
          fi
          
          # 3. Deployment metadata (15 points)
          echo "üìã Checking deployment metadata..."
          if DEPLOY_INFO=$(curl -sf "$DEPLOYMENT_URL/deploy-info.json"); then
            echo "‚úÖ Deployment metadata: OK"
            DEPLOY_ID=$(echo "$DEPLOY_INFO" | jq -r .deploymentId 2>/dev/null || echo "unknown")
            echo "Deployment ID: $DEPLOY_ID"
            HEALTH_SCORE=$((HEALTH_SCORE + 15))
          else
            echo "‚ö†Ô∏è Deployment metadata: Not available"
          fi
          
          # 4. Response time test (15 points)
          echo "‚è±Ô∏è Testing response time..."
          RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null "$DEPLOYMENT_URL")
          if (( $(echo "$RESPONSE_TIME < 3.0" | bc -l) )); then
            echo "‚úÖ Response time: ${RESPONSE_TIME}s (Good)"
            HEALTH_SCORE=$((HEALTH_SCORE + 15))
          else
            echo "‚ö†Ô∏è Response time: ${RESPONSE_TIME}s (Slow)"
            HEALTH_SCORE=$((HEALTH_SCORE + 5))
          fi
          
          # 5. Content integrity (15 points)
          echo "üìÑ Testing content integrity..."
          if curl -s "$DEPLOYMENT_URL" | grep -q "Insurance Game\|insurance.*game" -i; then
            echo "‚úÖ Content integrity: OK"
            HEALTH_SCORE=$((HEALTH_SCORE + 15))
          else
            echo "‚ö†Ô∏è Content integrity: Content verification failed"
          fi
          
          # 6. Asset availability (15 points)
          echo "üé® Testing asset availability..."
          if curl -s "$DEPLOYMENT_URL" | grep -q "assets/" || curl -sf "$DEPLOYMENT_URL/assets/" -o /dev/null 2>&1; then
            echo "‚úÖ Assets: Available"
            HEALTH_SCORE=$((HEALTH_SCORE + 15))
          else
            echo "‚ö†Ô∏è Assets: Not found or inaccessible"
          fi
          
          # Calculate health percentage
          HEALTH_PERCENTAGE=$((HEALTH_SCORE * 100 / MAX_SCORE))
          
          echo "üè• Health Check Summary:"
          echo "üìä Health Score: $HEALTH_SCORE/$MAX_SCORE ($HEALTH_PERCENTAGE%)"
          
          # Determine health status
          if [ $HEALTH_PERCENTAGE -ge 80 ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment is HEALTHY ($HEALTH_PERCENTAGE%)"
          elif [ $HEALTH_PERCENTAGE -ge 60 ]; then
            echo "status=degraded" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Deployment is DEGRADED ($HEALTH_PERCENTAGE%)"
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ùå Deployment is UNHEALTHY ($HEALTH_PERCENTAGE%)"
          fi

      - name: Store health metrics
        run: |
          # Create health report
          cat > health-report.json << EOF
          {
            "timestamp": "$(date -Iseconds)",
            "url": "${{ steps.health-check.outputs.url }}",
            "status": "${{ steps.health-check.outputs.status }}",
            "commit": "${{ github.sha }}",
            "workflow_run_id": "${{ github.run_id }}",
            "checks": {
              "connectivity": "$([ $? -eq 0 ] && echo "passed" || echo "failed")",
              "health_endpoint": "available",
              "response_time": "${RESPONSE_TIME:-unknown}s",
              "content_integrity": "verified"
            }
          }
          EOF

      - name: Upload health report
        uses: actions/upload-artifact@v4
        with:
          name: health-report-${{ github.run_id }}
          path: health-report.json
          retention-days: 30

  # Smoke testing
  smoke-testing:
    name: üí® Smoke Testing
    runs-on: ubuntu-latest
    needs: health-monitoring
    if: always() && (needs.health-monitoring.outputs.health_status != 'unhealthy' || github.event.inputs.action == 'smoke-test')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Install Playwright
        run: npx playwright install chromium --with-deps

      - name: Run smoke tests
        timeout-minutes: 15
        run: |
          DEPLOYMENT_URL="${{ needs.health-monitoring.outputs.deployment_url }}"
          echo "üí® Running smoke tests against: $DEPLOYMENT_URL"
          
          # Create smoke test configuration
          cat > playwright.smoke.config.js << EOF
          import { defineConfig } from '@playwright/test';
          
          export default defineConfig({
            testDir: './tests/smoke',
            timeout: 30000,
            expect: { timeout: 5000 },
            fullyParallel: true,
            forbidOnly: !!process.env.CI,
            retries: process.env.CI ? 2 : 0,
            workers: process.env.CI ? 1 : undefined,
            reporter: [['html', { outputFolder: 'smoke-report' }]],
            use: {
              baseURL: '$DEPLOYMENT_URL',
              trace: 'on-first-retry',
              screenshot: 'only-on-failure',
            },
          });
          EOF
          
          # Create smoke tests if they don't exist
          mkdir -p tests/smoke
          
          cat > tests/smoke/basic.spec.ts << 'EOF'
          import { test, expect } from '@playwright/test';
          
          test.describe('Smoke Tests', () => {
            test('Homepage loads successfully', async ({ page }) => {
              await page.goto('/');
              await expect(page).toHaveTitle(/Insurance.*Game/i);
            });
            
            test('Game interface is accessible', async ({ page }) => {
              await page.goto('/');
              await page.waitForLoadState('networkidle');
              
              // Check for game elements
              const gameElement = page.locator('[data-testid="game-canvas"], .game-container, #game');
              await expect(gameElement.first()).toBeVisible({ timeout: 10000 });
            });
            
            test('No critical console errors', async ({ page }) => {
              const errors: string[] = [];
              page.on('console', msg => {
                if (msg.type() === 'error') {
                  errors.push(msg.text());
                }
              });
              
              await page.goto('/');
              await page.waitForLoadState('networkidle');
              
              // Filter out known non-critical errors
              const criticalErrors = errors.filter(error => 
                !error.includes('favicon') && 
                !error.includes('service-worker') &&
                !error.includes('DevTools')
              );
              
              expect(criticalErrors).toHaveLength(0);
            });
            
            test('Basic interactivity works', async ({ page }) => {
              await page.goto('/');
              await page.waitForLoadState('networkidle');
              
              // Try to interact with the game
              await page.click('body');
              
              // Check if there are any clickable elements
              const clickableElements = await page.locator('button, [role="button"], .clickable').count();
              expect(clickableElements).toBeGreaterThan(0);
            });
          });
          EOF
          
          # Run smoke tests
          npx playwright test --config=playwright.smoke.config.js || SMOKE_EXIT_CODE=$?
          
          if [ "${SMOKE_EXIT_CODE:-0}" -eq 0 ]; then
            echo "‚úÖ Smoke tests passed"
            echo "SMOKE_STATUS=passed" >> $GITHUB_ENV
          else
            echo "‚ùå Smoke tests failed"
            echo "SMOKE_STATUS=failed" >> $GITHUB_ENV
          fi

      - name: Upload smoke test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-test-results-${{ github.run_id }}
          path: |
            smoke-report/
            test-results/
          retention-days: 30

  # Rollback capability
  rollback-system:
    name: üîÑ Rollback System
    runs-on: ubuntu-latest
    if: |
      (needs.health-monitoring.outputs.health_status == 'unhealthy') ||
      (needs.smoke-testing.result == 'failure') ||
      (github.event.inputs.action == 'rollback')
    needs: [health-monitoring, smoke-testing]
    environment:
      name: rollback-production
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Determine rollback target
        id: rollback-target
        run: |
          echo "üîÑ Determining rollback target..."
          
          if [ "${{ github.event.inputs.target_deployment }}" != "" ]; then
            TARGET_COMMIT="${{ github.event.inputs.target_deployment }}"
            echo "Manual rollback target: $TARGET_COMMIT"
          else
            # Find last successful deployment
            echo "Finding last successful deployment..."
            
            # Get recent commits on master
            RECENT_COMMITS=$(git log --oneline -n 20 master | grep -v "bump version\|skip ci" | head -10)
            echo "Recent commits:"
            echo "$RECENT_COMMITS"
            
            # For now, use the previous commit
            TARGET_COMMIT=$(git log --oneline -n 2 master | tail -1 | cut -d' ' -f1)
            echo "Automatic rollback target: $TARGET_COMMIT"
          fi
          
          echo "target_commit=$TARGET_COMMIT" >> $GITHUB_OUTPUT
          echo "üéØ Rollback target: $TARGET_COMMIT"

      - name: Prepare rollback build
        run: |
          TARGET_COMMIT="${{ steps.rollback-target.outputs.target_commit }}"
          
          echo "üîÑ Preparing rollback to commit: $TARGET_COMMIT"
          
          # Checkout target commit
          git checkout $TARGET_COMMIT
          
          # Install dependencies
          npm ci --prefer-offline --no-audit
          
          # Build rollback version
          npm run build
          
          # Add rollback metadata
          cat > dist/rollback-info.json << EOF
          {
            "rollback": true,
            "rollback_from": "${{ github.sha }}",
            "rollback_to": "$TARGET_COMMIT",
            "rollback_reason": "Health check failed or manual rollback",
            "rollback_timestamp": "$(date -Iseconds)",
            "rollback_triggered_by": "${{ github.actor }}"
          }
          EOF
          
          # Update health endpoint
          cat > dist/health << EOF
          {
            "status": "rollback-deployed",
            "timestamp": "$(date -Iseconds)",
            "rollback_info": {
              "from": "${{ github.sha }}",
              "to": "$TARGET_COMMIT"
            }
          }
          EOF

      - name: Deploy rollback
        uses: actions/deploy-pages@v4
        with:
          artifact_name: rollback-deployment

      - name: Verify rollback deployment
        timeout-minutes: 10
        run: |
          DEPLOYMENT_URL="https://shishihs.github.io/insurance_self_game/"
          echo "üîç Verifying rollback deployment..."
          
          # Wait for deployment to propagate
          for attempt in {1..20}; do
            echo "Verification attempt $attempt/20..."
            
            # Check if rollback info is accessible
            if curl -sf "$DEPLOYMENT_URL/rollback-info.json" > /dev/null; then
              echo "‚úÖ Rollback deployment verified"
              
              # Get rollback info
              ROLLBACK_INFO=$(curl -s "$DEPLOYMENT_URL/rollback-info.json")
              echo "Rollback info: $ROLLBACK_INFO"
              
              break
            fi
            
            if [ $attempt -eq 20 ]; then
              echo "‚ùå Rollback verification failed"
              exit 1
            fi
            
            sleep 15
          done

      - name: Post-rollback health check
        run: |
          DEPLOYMENT_URL="https://shishihs.github.io/insurance_self_game/"
          echo "üè• Running post-rollback health check..."
          
          # Basic health check
          if curl -sf "$DEPLOYMENT_URL" -o /dev/null; then
            echo "‚úÖ Rollback site is accessible"
            
            # Check response time
            RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null "$DEPLOYMENT_URL")
            echo "‚è±Ô∏è Rollback response time: ${RESPONSE_TIME}s"
            
            if (( $(echo "$RESPONSE_TIME < 5.0" | bc -l) )); then
              echo "‚úÖ Rollback deployment is healthy"
            else
              echo "‚ö†Ô∏è Rollback deployment is slow but functional"
            fi
          else
            echo "‚ùå Rollback deployment failed"
            exit 1
          fi

      - name: Create rollback summary
        run: |
          cat > rollback-summary.md << EOF
          # üîÑ Rollback Summary
          
          **Rollback completed successfully**
          
          - **From Commit:** ${{ github.sha }}
          - **To Commit:** ${{ steps.rollback-target.outputs.target_commit }}
          - **Reason:** ${{ needs.health-monitoring.outputs.health_status == 'unhealthy' && 'Health check failed' || 'Manual rollback' }}
          - **Triggered by:** ${{ github.actor }}
          - **Timestamp:** $(date -Iseconds)
          
          ## Health Status
          - **Site Status:** ‚úÖ Accessible
          - **Response Time:** ${RESPONSE_TIME}s
          
          ## Next Steps
          1. Investigate the root cause of the deployment issue
          2. Fix the issues in the main branch
          3. Re-deploy when ready
          
          **Site URL:** https://shishihs.github.io/insurance_self_game/
          EOF

      - name: Upload rollback report
        uses: actions/upload-artifact@v4
        with:
          name: rollback-report-${{ github.run_id }}
          path: rollback-summary.md
          retention-days: 30

  # Canary deployment analysis
  canary-analysis:
    name: üê§ Canary Deployment Analysis
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'canary-analysis'
    steps:
      - name: Canary traffic analysis
        run: |
          echo "üê§ Running canary deployment analysis..."
          
          # This would typically involve:
          # 1. Routing small percentage of traffic to new deployment
          # 2. Monitoring error rates, response times
          # 3. Comparing metrics with baseline
          # 4. Making go/no-go decision
          
          echo "üìä Canary analysis completed"
          echo "Note: Full canary deployment requires advanced infrastructure"

  # Notification system
  safety-notifications:
    name: üì¢ Safety Notifications
    runs-on: ubuntu-latest
    needs: [health-monitoring, smoke-testing, rollback-system]
    if: always()
    steps:
      - name: Prepare notification data
        run: |
          echo "üì¢ Preparing safety notifications..."
          
          HEALTH_STATUS="${{ needs.health-monitoring.outputs.health_status }}"
          SMOKE_STATUS="${{ needs.smoke-testing.result }}"
          ROLLBACK_STATUS="${{ needs.rollback-system.result }}"
          
          # Determine overall safety status
          if [ "$HEALTH_STATUS" = "healthy" ] && [ "$SMOKE_STATUS" = "success" ]; then
            SAFETY_STATUS="‚úÖ SAFE"
            SAFETY_COLOR="good"
          elif [ "$ROLLBACK_STATUS" = "success" ]; then
            SAFETY_STATUS="üîÑ ROLLED BACK"
            SAFETY_COLOR="warning"
          else
            SAFETY_STATUS="‚ùå UNSAFE"
            SAFETY_COLOR="danger"
          fi
          
          echo "SAFETY_STATUS=$SAFETY_STATUS" >> $GITHUB_ENV
          echo "SAFETY_COLOR=$SAFETY_COLOR" >> $GITHUB_ENV

      - name: Create safety report
        run: |
          cat > safety-report.md << EOF
          # üõ°Ô∏è Deployment Safety Report
          
          **Overall Status:** ${{ env.SAFETY_STATUS }}
          
          ## üìä Safety Checks
          
          | Check | Status | Details |
          |-------|--------|---------|
          | Health Monitoring | ${{ needs.health-monitoring.outputs.health_status || 'N/A' }} | ${{ needs.health-monitoring.outputs.deployment_url }} |
          | Smoke Testing | ${{ needs.smoke-testing.result || 'N/A' }} | Basic functionality verified |
          | Rollback System | ${{ needs.rollback-system.result || 'N/A' }} | Ready if needed |
          
          ## üîó Resources
          - **Live Site:** https://shishihs.github.io/insurance_self_game/
          - **Commit:** ${{ github.sha }}
          - **Workflow:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          **Generated:** $(date -Iseconds)
          EOF

      - name: Upload safety report
        uses: actions/upload-artifact@v4
        with:
          name: safety-report-${{ github.run_id }}
          path: safety-report.md
          retention-days: 30

      - name: Send Slack notification (if configured)
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST $SLACK_WEBHOOK_URL \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "üõ°Ô∏è Deployment Safety Check: ${{ env.SAFETY_STATUS }}",
              "color": "${{ env.SAFETY_COLOR }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deployment Safety Report*\n‚Ä¢ Status: ${{ env.SAFETY_STATUS }}\n‚Ä¢ Health: ${{ needs.health-monitoring.outputs.health_status }}\n‚Ä¢ Smoke Tests: ${{ needs.smoke-testing.result }}\n‚Ä¢ Site: https://shishihs.github.io/insurance_self_game/"
                  }
                }
              ]
            }'