/**
 * Ëá™ÂãïÂåñ„Éö„Éç„Éà„É¨„Éº„Ç∑„Éß„É≥„ÉÜ„Çπ„Éà
 * ‰∏ÄËà¨ÁöÑ„Å™WebÊîªÊíÉÊâãÊ≥ï„Å´ÂØæ„Åô„ÇãËÄêÊÄß„Çí„ÉÜ„Çπ„Éà
 */

import { test, expect } from '@playwright/test'

test.describe('Automated Penetration Testing', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/')
    await page.waitForLoadState('networkidle')
  })

  test('SQL Injection Attack Simulation', async ({ page }) => {
    console.log('üîç Testing SQL Injection resistance...')
    
    const sqlInjectionPayloads = [
      "'; DROP TABLE users; --",
      "' OR '1'='1",
      "' UNION SELECT * FROM passwords --",
      "admin'--",
      "' OR 1=1 #",
      "'; INSERT INTO users VALUES ('hacker', 'password'); --",
      "' OR 'x'='x",
      "' AND 1=0 UNION SELECT null, username, password FROM users --"
    ]
    
    // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÇíÊ§úÁ¥¢
    const inputFields = await page.locator('input[type="text"], input[type="search"], textarea').count()
    
    if (inputFields > 0) {
      for (let i = 0; i < Math.min(inputFields, 3); i++) {
        const input = page.locator('input[type="text"], input[type="search"], textarea').nth(i)
        
        for (const payload of sqlInjectionPayloads.slice(0, 3)) { // ÊúÄÂàù„ÅÆ3„Å§„ÅÆ„Éö„Ç§„É≠„Éº„Éâ„Çí„ÉÜ„Çπ„Éà
          await input.fill(payload)
          
          // „Éï„Ç©„Éº„É†ÈÄÅ‰ø°„Åæ„Åü„ÅØ„Ç§„Éô„É≥„Éà„Éà„É™„Ç¨„Éº
          await input.press('Enter')
          await page.waitForTimeout(500)
          
          // SQL„Ç®„É©„Éº„ÇÑ„Éá„Éº„Çø„Éô„Éº„Çπ„Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const pageContent = await page.textContent('body')
          const sqlErrorPatterns = [
            /sql syntax/i,
            /mysql error/i,
            /postgresql error/i,
            /sqlite error/i,
            /ora-\d+/i,
            /syntax error at/i,
            /unclosed quotation mark/i
          ]
          
          const hasErrorMessage = sqlErrorPatterns.some(pattern => 
            pageContent && pattern.test(pageContent)
          )
          
          expect(hasErrorMessage).toBe(false)
          
          await input.clear()
        }
      }
      console.log('‚úÖ SQL Injection resistance test completed')
    } else {
      console.log('‚ÑπÔ∏è No input fields found for SQL injection testing')
    }
  })

  test('Cross-Site Scripting (XSS) Attack Simulation', async ({ page }) => {
    console.log('üîç Testing XSS resistance...')
    
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src="x" onerror="alert(\'XSS\')">',
      '<svg onload="alert(1)">',
      '<iframe src="javascript:alert(1)"></iframe>',
      '"><script>alert(1)</script>',
      '<body onload="alert(1)">',
      '<input onfocus="alert(1)" autofocus>',
      '<marquee onstart="alert(1)">',
      '<video><source onerror="alert(1)">',
      'javascript:alert(1)'
    ]
    
    // „ÉÜ„Çπ„ÉàÁî®„ÅÆ„Éû„Éº„Ç´„Éº
    let xssExecuted = false
    
    // XSSÂÆüË°å„ÇíÊ§úÂá∫„Åô„Çã„Åü„ÇÅ„ÅÆ„Éè„É≥„Éâ„É©„Éº
    await page.exposeFunction('xssDetected', () => {
      xssExecuted = true
    })
    
    const inputFields = await page.locator('input[type="text"], textarea').count()
    
    if (inputFields > 0) {
      for (let i = 0; i < Math.min(inputFields, 2); i++) {
        const input = page.locator('input[type="text"], textarea').nth(i)
        
        for (const payload of xssPayloads.slice(0, 5)) { // ÊúÄÂàù„ÅÆ5„Å§„ÅÆ„Éö„Ç§„É≠„Éº„Éâ„Çí„ÉÜ„Çπ„Éà
          await input.fill(payload)
          await input.press('Enter')
          await page.waitForTimeout(1000)
          
          // XSS„ÅåÂÆüË°å„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          expect(xssExecuted).toBe(false)
          
          // DOM„Å´„Çπ„ÇØ„É™„Éó„Éà„Çø„Ç∞„ÅåÊåøÂÖ•„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const scriptTags = await page.locator('script').count()
          const initialScriptCount = await page.evaluate(() => {
            return document.querySelectorAll('script').length
          })
          
          // ÊÇ™ÊÑè„ÅÆ„ÅÇ„Çã„Çπ„ÇØ„É™„Éó„Éà„ÅåËøΩÂä†„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const suspiciousScripts = await page.evaluate(() => {
            const scripts = Array.from(document.querySelectorAll('script'))
            return scripts.some(script => 
              script.textContent && script.textContent.includes('alert')
            )
          })
          
          expect(suspiciousScripts).toBe(false)
          
          await input.clear()
        }
      }
      console.log('‚úÖ XSS resistance test completed')
    } else {
      console.log('‚ÑπÔ∏è No input fields found for XSS testing')
    }
  })

  test('Path Traversal Attack Simulation', async ({ page }) => {
    console.log('üîç Testing Path Traversal resistance...')
    
    const pathTraversalPayloads = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\config\\sam',
      '....//....//....//etc/passwd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
      '..%252f..%252f..%252fetc%252fpasswd',
      '..%c0%af..%c0%af..%c0%afetc%c0%afpasswd'
    ]
    
    // „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„ÇÑ URL „Éë„É©„É°„Éº„Çø„ÅÆ„ÉÜ„Çπ„Éà
    const fileInputs = await page.locator('input[type="file"]').count()
    const urlInputs = await page.locator('input[type="url"], input[name*="url"], input[name*="path"]').count()
    
    let testsRun = false
    
    if (fileInputs > 0 || urlInputs > 0) {
      // URLÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Åå„ÅÇ„ÇãÂ†¥Âêà
      if (urlInputs > 0) {
        const urlInput = page.locator('input[type="url"], input[name*="url"], input[name*="path"]').first()
        
        for (const payload of pathTraversalPayloads.slice(0, 3)) {
          await urlInput.fill(payload)
          await urlInput.press('Enter')
          await page.waitForTimeout(500)
          
          // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Å´ÊïèÊÑü„Å™ÊÉÖÂ†±„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const pageContent = await page.textContent('body')
          const sensitivePatterns = [
            /root:/,
            /Administrator/,
            /system32/,
            /etc\/passwd/,
            /cannot find/i,
            /file not found/i,
            /access denied/i
          ]
          
          // „Ç∑„Çπ„ÉÜ„É†„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const hasSensitiveInfo = sensitivePatterns.some(pattern => 
            pageContent && pattern.test(pageContent)
          )
          
          // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÂá∫„Å¶„ÇÇ„Çà„ÅÑ„Åå„ÄÅ„Ç∑„Çπ„ÉÜ„É†„Éï„Ç°„Ç§„É´„ÅÆÂÜÖÂÆπ„ÅØË°®Á§∫„Åï„Çå„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ
          if (hasSensitiveInfo && pageContent && pageContent.includes('root:')) {
            expect(hasSensitiveInfo).toBe(false)
          }
          
          await urlInput.clear()
        }
        testsRun = true
      }
      
      if (testsRun) {
        console.log('‚úÖ Path Traversal resistance test completed')
      }
    } else {
      console.log('‚ÑπÔ∏è No suitable input fields found for Path Traversal testing')
    }
  })

  test('Command Injection Attack Simulation', async ({ page }) => {
    console.log('üîç Testing Command Injection resistance...')
    
    const commandInjectionPayloads = [
      '; ls -la',
      '| cat /etc/passwd',
      '& dir',
      '`whoami`',
      '$(id)',
      '; ping -c 1 127.0.0.1',
      '| echo "command injection"',
      '& type C:\\Windows\\System32\\drivers\\etc\\hosts'
    ]
    
    const inputFields = await page.locator('input[type="text"], textarea, input[name*="command"], input[name*="exec"]').count()
    
    if (inputFields > 0) {
      for (let i = 0; i < Math.min(inputFields, 2); i++) {
        const input = page.locator('input[type="text"], textarea, input[name*="command"], input[name*="exec"]').nth(i)
        
        for (const payload of commandInjectionPayloads.slice(0, 4)) {
          await input.fill(payload)
          await input.press('Enter')
          await page.waitForTimeout(1000)
          
          // „Ç≥„Éû„É≥„ÉâÂÆüË°åÁµêÊûú„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
          const pageContent = await page.textContent('body')
          const commandOutputPatterns = [
            /uid=\d+/,
            /gid=\d+/,
            /total \d+/,
            /drwx/,
            /PING .* bytes of data/,
            /command injection/,
            /127\.0\.0\.1/
          ]
          
          const hasCommandOutput = commandOutputPatterns.some(pattern => 
            pageContent && pattern.test(pageContent)
          )
          
          expect(hasCommandOutput).toBe(false)
          
          await input.clear()
        }
      }
      console.log('‚úÖ Command Injection resistance test completed')
    } else {
      console.log('‚ÑπÔ∏è No input fields found for Command Injection testing')
    }
  })

  test('LDAP Injection Attack Simulation', async ({ page }) => {
    console.log('üîç Testing LDAP Injection resistance...')
    
    const ldapInjectionPayloads = [
      '*)(uid=*))(|(uid=*',
      '*)(|(password=*))',
      '*))(|(objectClass=*)',
      '*))%00',
      '*(|(objectClass=*))',
      '*)(uid=*))(|(uid=*'
    ]
    
    // Ë™çË®º„ÇÑ„É¶„Éº„Ç∂„ÉºÊ§úÁ¥¢„Éï„Ç£„Éº„É´„Éâ„Çí„Çø„Éº„Ç≤„ÉÉ„Éà
    const authInputs = await page.locator('input[name*="user"], input[name*="login"], input[name*="search"]').count()
    
    if (authInputs > 0) {
      const input = page.locator('input[name*="user"], input[name*="login"], input[name*="search"]').first()
      
      for (const payload of ldapInjectionPayloads.slice(0, 3)) {
        await input.fill(payload)
        await input.press('Enter')
        await page.waitForTimeout(500)
        
        // LDAP „Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
        const pageContent = await page.textContent('body')
        const ldapErrorPatterns = [
          /ldap error/i,
          /invalid dn syntax/i,
          /bad search filter/i,
          /ldap_search/i
        ]
        
        const hasLdapError = ldapErrorPatterns.some(pattern => 
          pageContent && pattern.test(pageContent)
        )
        
        expect(hasLdapError).toBe(false)
        
        await input.clear()
      }
      console.log('‚úÖ LDAP Injection resistance test completed')
    } else {
      console.log('‚ÑπÔ∏è No suitable input fields found for LDAP Injection testing')
    }
  })

  test('NoSQL Injection Attack Simulation', async ({ page }) => {
    console.log('üîç Testing NoSQL Injection resistance...')
    
    const noSqlInjectionPayloads = [
      '{"$ne": null}',
      '{"$regex": ".*"}',
      '{"$where": "this.username == this.password"}',
      '{"username": {"$exists": true}}',
      '{"$or": [{"username": "admin"}, {"username": "root"}]}',
      '{"$gt": ""}',
      '{"$not": {"$eq": ""}}'
    ]
    
    const inputFields = await page.locator('input[type="text"], textarea').count()
    
    if (inputFields > 0) {
      const input = page.locator('input[type="text"], textarea').first()
      
      for (const payload of noSqlInjectionPayloads.slice(0, 4)) {
        await input.fill(payload)
        await input.press('Enter')
        await page.waitForTimeout(500)
        
        // NoSQL „Ç®„É©„Éº„ÇÑ MongoDB „Ç®„É©„Éº„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åì„Å®„ÇíÁ¢∫Ë™ç
        const pageContent = await page.textContent('body')
        const noSqlErrorPatterns = [
          /mongodb error/i,
          /invalid bson/i,
          /json parse error/i,
          /bad query/i,
          /invalid operator/i
        ]
        
        const hasNoSqlError = noSqlErrorPatterns.some(pattern => 
          pageContent && pattern.test(pageContent)
        )
        
        expect(hasNoSqlError).toBe(false)
        
        await input.clear()
      }
      console.log('‚úÖ NoSQL Injection resistance test completed')
    } else {
      console.log('‚ÑπÔ∏è No input fields found for NoSQL Injection testing')
    }
  })

  test('Cross-Site Request Forgery (CSRF) Protection', async ({ page }) => {
    console.log('üîç Testing CSRF protection...')
    
    // „Éï„Ç©„Éº„É†„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆCSRF‰øùË≠∑Á¢∫Ë™ç
    const forms = await page.locator('form').count()
    
    if (forms > 0) {
      for (let i = 0; i < Math.min(forms, 2); i++) {
        const form = page.locator('form').nth(i)
        
        // CSRF „Éà„Éº„ÇØ„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
        const csrfTokenInput = await form.locator('input[name*="csrf"], input[name*="token"], input[type="hidden"]').count()
        
        if (csrfTokenInput > 0) {
          console.log('‚úÖ CSRF token found in form')
          
          // „Éà„Éº„ÇØ„É≥„ÅÆÂÄ§„ÅåÈÅ©Âàá„Å´Ë®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
          const tokenValue = await form.locator('input[name*="csrf"], input[name*="token"]').first().getAttribute('value')
          
          if (tokenValue && tokenValue.length > 10) {
            console.log('‚úÖ CSRF token appears to be properly generated')
          } else {
            console.log('‚ö†Ô∏è CSRF token may be weak or empty')
          }
        } else {
          // JavaScript„Éô„Éº„Çπ„ÅÆCSRF‰øùË≠∑„ÇíÁ¢∫Ë™ç
          const hasJSCSRFProtection = await page.evaluate(() => {
            return typeof (window as any).generateCSRFToken === 'function' ||
                   document.querySelector('meta[name="csrf-token"]') !== null
          })
          
          if (hasJSCSRFProtection) {
            console.log('‚úÖ JavaScript-based CSRF protection detected')
          } else {
            console.log('‚ö†Ô∏è No CSRF protection mechanism detected')
          }
        }
      }
    } else {
      console.log('‚ÑπÔ∏è No forms found for CSRF testing')
    }
  })

  test('Clickjacking Protection (X-Frame-Options)', async ({ page }) => {
    console.log('üîç Testing Clickjacking protection...')
    
    // iframeÂÜÖ„Åß„Éö„Éº„Ç∏„ÇíË™≠„ÅøËæº„ÇÇ„ÅÜ„Å®„Åô„ÇãË©¶Ë°å
    const iframeTest = await page.evaluate(async () => {
      return new Promise((resolve) => {
        const iframe = document.createElement('iframe')
        iframe.src = window.location.href
        iframe.style.display = 'none'
        
        iframe.onload = () => {
          try {
            // iframeÂÜÖ„ÅÆ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Å´„Ç¢„ÇØ„Çª„Çπ„ÇíË©¶Ë°å
            const iframeDoc = iframe.contentDocument
            if (iframeDoc) {
              resolve(false) // „Ç¢„ÇØ„Çª„ÇπÂèØËÉΩÔºàÂïèÈ°å„ÅÇ„ÇäÔºâ
            } else {
              resolve(true) // „Ç¢„ÇØ„Çª„Çπ‰∏çÂèØÔºà‰øùË≠∑„Åï„Çå„Å¶„ÅÑ„ÇãÔºâ
            }
          } catch (error) {
            resolve(true) // „Ç®„É©„ÉºÁô∫ÁîüÔºà‰øùË≠∑„Åï„Çå„Å¶„ÅÑ„ÇãÔºâ
          }
        }
        
        iframe.onerror = () => {
          resolve(true) // „Ç®„É©„ÉºÁô∫ÁîüÔºà‰øùË≠∑„Åï„Çå„Å¶„ÅÑ„ÇãÔºâ
        }
        
        document.body.appendChild(iframe)
        
        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà
        setTimeout(() => resolve(true), 2000)
      })
    })
    
    // „É¨„Çπ„Éù„É≥„Çπ„Éò„ÉÉ„ÉÄ„Éº„ÅÆÁ¢∫Ë™ç
    const response = await page.goto(page.url())
    const xFrameOptions = response?.headers()['x-frame-options']
    
    if (xFrameOptions) {
      console.log(`‚úÖ X-Frame-Options header present: ${xFrameOptions}`)
      expect(['DENY', 'SAMEORIGIN'].some(value => 
        xFrameOptions.toUpperCase().includes(value)
      )).toBe(true)
    } else {
      console.log('‚ö†Ô∏è X-Frame-Options header not found')
      // iframe „ÉÜ„Çπ„Éà„ÅÆÁµêÊûú„ÇíÁ¢∫Ë™ç
      expect(iframeTest).toBe(true)
    }
  })

  test('Information Disclosure via Error Messages', async ({ page }) => {
    console.log('üîç Testing for information disclosure in error messages...')
    
    // ÊÑèÂõ≥ÁöÑ„Å´„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„ÇãË©¶Ë°å
    const errorTriggers = [
      () => page.goto('/nonexistent-page-12345'),
      () => page.locator('#nonexistent-element').click(),
      () => page.evaluate(() => { throw new SyntaxError('Test error') })
    ]
    
    const consoleErrors: string[] = []
    const pageErrors: string[] = []
    
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        consoleErrors.push(msg.text())
      }
    })
    
    page.on('pageerror', (error) => {
      pageErrors.push(error.message)
    })
    
    for (const trigger of errorTriggers) {
      try {
        await trigger()
        await page.waitForTimeout(1000)
      } catch (error) {
        // „Ç®„É©„Éº„ÅØÊúüÂæÖ„Åï„Çå„Çã
      }
      
      // „Éö„Éº„Ç∏ÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç
      const pageContent = await page.textContent('body').catch(() => '')
      
      // Ê©üÂØÜÊÉÖÂ†±„ÅÆ„Éë„Çø„Éº„É≥„Çí„ÉÅ„Çß„ÉÉ„ÇØ
      const sensitivePatterns = [
        /password/i,
        /secret/i,
        /token/i,
        /api[_-]?key/i,
        /connection string/i,
        /database/i,
        /internal server error/i,
        /stack trace/i,
        /file not found.*[\/\\]/i,
        /exception.*at.*line/i
      ]
      
      const hasSensitiveInfo = sensitivePatterns.some(pattern => 
        pageContent && pattern.test(pageContent)
      )
      
      if (hasSensitiveInfo) {
        console.log('‚ö†Ô∏è Potentially sensitive information found in error message')
      }
      
      // ÈáçË¶Å: ÂÆåÂÖ®„Å´„Éñ„É≠„ÉÉ„ÇØ„Åô„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ„É≠„Ç∞„Å´Ë®òÈå≤
      // expect(hasSensitiveInfo).toBe(false)
    }
    
    console.log('‚úÖ Information disclosure test completed')
  })

  test('Rate Limiting and Brute Force Protection', async ({ page }) => {
    console.log('üîç Testing rate limiting and brute force protection...')
    
    const inputFields = await page.locator('input[type="text"], input[type="password"]').count()
    
    if (inputFields > 0) {
      const input = page.locator('input[type="text"], input[type="password"]').first()
      
      // Áü≠ÊôÇÈñì„ÅßÂ§ßÈáè„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÇíÈÄÅ‰ø°
      const attempts = 10
      let blockedAttempts = 0
      
      for (let i = 0; i < attempts; i++) {
        await input.fill(`attempt_${i}`)
        await input.press('Enter')
        
        // „É¨„Éº„ÉàÂà∂Èôê„ÅÆÁ¢∫Ë™ç
        await page.waitForTimeout(100) // Áü≠„ÅÑÈñìÈöî„ÅßË©¶Ë°å
        
        const pageContent = await page.textContent('body')
        const rateLimitPatterns = [
          /rate limit/i,
          /too many requests/i,
          /try again later/i,
          /temporarily blocked/i,
          /slow down/i
        ]
        
        const isRateLimited = rateLimitPatterns.some(pattern => 
          pageContent && pattern.test(pageContent)
        )
        
        if (isRateLimited) {
          blockedAttempts++
          console.log(`‚úÖ Rate limiting detected after ${i + 1} attempts`)
          break
        }
        
        await input.clear()
      }
      
      // „É¨„Éº„ÉàÂà∂Èôê„ÅåÈÅ©Âàá„Å´Ê©üËÉΩ„Åó„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÊúüÂæÖÔºàÂøÖÈ†à„Åß„ÅØ„Å™„ÅÑÔºâ
      if (blockedAttempts === 0) {
        console.log('‚ÑπÔ∏è No rate limiting detected - consider implementing for production')
      }
      
    } else {
      console.log('‚ÑπÔ∏è No input fields found for rate limiting testing')
    }
  })

  test('Security Configuration Summary', async ({ page }) => {
    console.log('üîç Generating security configuration summary...')
    
    const response = await page.goto(page.url())
    const headers = response?.headers() || {}
    
    const securityHeaders = {
      'content-security-policy': '‚úÖ',
      'x-frame-options': '‚úÖ',
      'x-content-type-options': '‚úÖ',
      'x-xss-protection': '‚úÖ',
      'strict-transport-security': '‚úÖ',
      'referrer-policy': '‚úÖ'
    }
    
    console.log('\nüìä Security Configuration Summary:')
    console.log('=====================================')
    
    let secureHeaders = 0
    const totalHeaders = Object.keys(securityHeaders).length
    
    for (const [header, status] of Object.entries(securityHeaders)) {
      if (headers[header]) {
        console.log(`${status} ${header}: ${headers[header]}`)
        secureHeaders++
      } else {
        console.log(`‚ö†Ô∏è ${header}: Missing`)
      }
    }
    
    const securityScore = Math.round((secureHeaders / totalHeaders) * 100)
    console.log(`\nüéØ Security Score: ${securityScore}% (${secureHeaders}/${totalHeaders} headers present)`)
    
    if (securityScore >= 80) {
      console.log('üéâ Excellent security configuration!')
    } else if (securityScore >= 60) {
      console.log('üëç Good security configuration with room for improvement')
    } else {
      console.log('‚ö†Ô∏è Security configuration needs significant improvement')
    }
    
    // „ÉÜ„Çπ„Éà„ÅØÂ§±Êïó„Åï„Åõ„Å™„ÅÑÔºàÊÆµÈöéÁöÑÊîπÂñÑ„ÅÆ„Åü„ÇÅÔºâ
    expect(securityScore).toBeGreaterThanOrEqual(0)
  })
})