# 一人用ボードゲームプロジェクト企画書
**孤独な時間を豊かな体験へ - インタラクティブゲーム開発戦略**

## ⚠️ 重要：テスト駆動開発の原則

### テスト成功率100%の厳守
```
開発時の絶対ルール:
「すべてのテストが成功するまで、作業は完了していない」
```

**テスト失敗時の対応:**
1. **部分的な成功に満足しない** - 99%の成功も失敗と同じ
2. **根本原因を特定する** - エラーメッセージを正確に読み取る
3. **影響範囲を確認する** - 一つの修正が他のテストを壊していないか
4. **完全な成功を確認する** - npm run test:run で全テスト成功を確認

### テスト実行コマンド
```bash
# 全テスト実行
npm run test:run

# 特定のテストファイル実行
npm run test:run src/__tests__/path/to/test.ts

# 型チェック
npm run type-check

# Lint実行
npm run lint
```

### テスト失敗時のデバッグ手順
1. **エラーの正確な把握**
   ```bash
   npm run test:run -- --reporter=verbose
   ```

2. **型エラーの確認**
   ```bash
   npm run type-check
   ```

3. **個別テストの実行**
   ```bash
   npm run test:run <specific-test-file>
   ```

4. **修正と再実行**
   - 修正は一つずつ行う
   - 各修正後にテストを実行
   - 全テスト成功まで繰り返す

## 📚 関連ドキュメント
- **[🚨 開発原則](./docs/development/PRINCIPLES.md)** - **プロジェクトの核となる開発思想（必読）**
- **[📦 パッケージマネージャー選択](./docs/development/PACKAGE_MANAGER_CHOICE.md)** - **npmを使用する理由（Claude Code互換性）**
- **[🔄 ゲーム改善プロセス](./docs/planning/GAME_IMPROVEMENT_PROCESS.md)** - **テストプレイ時は必ず参照**
- **[🎮 GUI/CUI使い分けガイド](./docs/development/GUI_AND_CUI_USAGE_GUIDE.md)** - **本番用GUIと開発用CUIの使い分け**
- **[📝 意思決定記録](./docs/planning/DECISION_RECORD.md)** - **実装しない機能とその理由**
- [技術仕様書](./docs/design/TECH_SPEC.md) - 使用技術とアーキテクチャ
- [ゲームデザイン](./docs/design/GAME_DESIGN.md) - ゲームルールと拡張計画
- [開発ガイド](./docs/development/DEVELOPMENT.md) - Claude Codeでの開発手順

## SubAgent の仲間たち
SubAgent に依頼した方が良さそうなことがあればどんどん依頼しましょう。

### ゲームロジックの実装
/agents use game-logic

### UIの実装
/agents use ui-designer

### データ管理
/agents use data-manager

### テスト作成
/agents use test-specialist

### パフォーマンス最適化
/agents use performance-optimizer

### 🚀 デプロイ実行
/agents use deploy-specialist

#### deploy-specialist 改良版指示書 v3.0

**重要**: 正確なデプロイ確認ができなかった教訓については[DEPLOYMENT_VERIFICATION_LESSONS.md](./docs/development/DEPLOYMENT_VERIFICATION_LESSONS.md)を参照

**🚨 総合禁止事項**: 本番サイト https://shishihs.github.io/insurance_self_game/ には直接アクセスしないこと。エラーが発生している可能性があります。詳細は[PRODUCTION_SITE_VERIFICATION_FAILURE.md](./docs/development/PRODUCTION_SITE_VERIFICATION_FAILURE.md)を参照。

```
【🔍 技術的制約と回避策】
1. WebFetchの制約
   - ❌ GitHub Actionsのアイコン（✅/❌）は取得できない
   - ✅ 代替策: ワークフローURLで"failed"や"success"のテキストを探す
   - ✅ 代替策: 実行時間が異常に短い場合は失敗の可能性

2. HTTPステータスコードの誤解
   - ❌ curlで200が返っても、古いデプロイ内容の可能性
   - ✅ 代替策: deploy-info.jsonを生成してコミットハッシュを確認

3. GitHub CLIが使えない
   - ❌ ghコマンドでAPIレベルの確認ができない
   - ✅ 代替策: 具体的なワークフローURLを直接確認

【デプロイ前必須確認事項】
1. ローカルでのテスト実行と成功確認
   - npm run test:run が全て成功すること（1つでも失敗したらデプロイ禁止）
   - npm run lint が成功すること（警告は許容）
   - npm run type-check が成功すること（エラーが1つでもあればデプロイ禁止）

2. ビルドの確認
   - npm run build が成功すること
   - distディレクトリが正しく生成されること

【デプロイ実行手順】
1. git status で変更内容を確認
2. 必要に応じてコミット（テスト成功後のみ）
3. git push でリモートにプッシュ
4. GitHub Actions の全ワークフローの状態を具体的に確認

【🔍 GitHub Actions確認手順（必須）】
1. https://github.com/shishihs/insurance_self_game/actions にアクセス
2. 各ワークフローのステータスを確認：
   - ✅ 緑色チェックマーク = 成功
   - ❌ 赤色Xマーク = 失敗
   - 🟡 黄色 = 実行中
   - ⏸️ グレー = キュー待機中

3. 失敗したワークフローがある場合：
   a. ワークフロー名をクリックして詳細ページへ
   b. 失敗したジョブをクリック
   c. 失敗したステップを特定
   d. エラーログをコピーして報告

4. 全ワークフローの状態を報告：
   ```
   ワークフロー状態：
   - Deploy to GitHub Pages: ✅ 成功
   - Comprehensive Test Pipeline: ❌ 失敗 (Unit Testsでエラー)
   - Production Deploy Pipeline: 🟡 実行中
   等
   ```

【📄 失敗ワークフローの詳細確認】
1. 失敗したワークフローのURLを取得
   例: https://github.com/shishihs/insurance_self_game/actions/runs/[RUN_ID]

2. 以下の情報を収集：
   - 失敗したジョブ名
   - 失敗したステップ名
   - エラーメッセージ（最初の10行と最後の10行）
   - exit code

3. エラーパターンの分類：
   - テスト失敗: 失敗したテスト名とエラー内容
   - ビルド失敗: コンパイルエラーの詳細
   - 依存関係エラー: npm installの失敗原因
   - 設定エラー: 環境変数や設定ファイルの問題

【📊 デプロイ完了の定義】
以下の全てが満たされた時のみ「デプロイ完了」と報告すること：

1. 必須ワークフローの成功：
   ✅ Deploy to GitHub Pages: 以下のいずれかで確認
      - WebFetchで"success"テキストを確認
      - ワークフローURLでエラーがないことを確認
      - 最新コミットのワークフローが実行完了
   ✅ 本番URLの検証:
      - https://shishihs.github.io/insurance_self_game/ が200を返す
      - 可能であればdeploy-info.jsonでコミットハッシュを確認

2. その他のワークフローの状態を明記：
   - 成功/失敗/実行中の状態を全て報告
   - 失敗がある場合は、その原因と影響を説明

3. 確認できない場合の報告:
   - 「確認できませんでした」と正直に報告
   - 推測ではなく、確認できた事実のみを報告

【🔧 失敗時の対応フロー】
1. 失敗ワークフローのログURLを取得
2. WebFetchで詳細ログを取得
3. エラー内容を分析し、修正方法を特定
4. ローカルで同じエラーを再現し、修正
5. 修正後、ローカルでテスト→ビルド→デプロイ

【🚨 重要な注意事項】
❌ 「実行された」だけで「成功」と判断しない
❌ ステータスアイコンを確認せずに推測しない
❌ 失敗ログを読まずに修正を試みない
❌ HTTP 200だけでデプロイ成功と判断しない
❌「errorsが見えない」だけで成功と判断しない
✅ 必ず具体的なエラー内容を含めて報告
✅ 不明な点はワークフローURLを提供して確認依頼
✅ 確認できない場合は「確認できません」と正直に報告

【📦 デプロイ検証のベストプラクティス】
1. ビルド時にバージョン情報を埋め込む
   ```javascript
   // vite.config.ts
   define: {
     '__BUILD_TIME__': JSON.stringify(new Date().toISOString()),
     '__COMMIT_HASH__': JSON.stringify(process.env.GITHUB_SHA || 'local')
   }
   ```

2. デプロイ確認用エンドポイントを設置
   ```json
   // public/deploy-info.json
   {
     "deployedAt": "2025-01-30T12:00:00Z",
     "commitHash": "abc123",
     "workflowRunId": "12345678"
   }
   ```

3. 「推測」ではなく「確実な証拠」に基づいた判断
```

## 🔗 MCP (Model Context Protocol) 統合

### 🧠 Gemini MCP 必須利用ルール
```
不安になったとき・最新情報が必要なときの復唱:
「わからないことがあったら、まずGemini MCPに相談しよう」
```
- **技術的不安や疑問**: 実装方法に不安を感じたら即座にGemini MCPで相談
- **最新情報の取得**: WEB上の最新情報、フレームワークの仕様変更、ベストプラクティスの確認
- **実装順序の判断**: 複数のタスクがある時の優先度決定
- **技術選択の検証**: ライブラリ選択、アーキテクチャ決定時の情報収集
- **トラブルシューティング**: エラーや問題の解決方法の検索

**🚨 重要**: 推測や古い知識で判断せず、常に最新かつ正確な情報をGemini MCPで確認すること

### 利用可能なツール
**[🛠️ MCP セットアップガイド](./docs/development/MCP_SETUP.md)** - **初回設定方法とトラブルシューティング**

- **Gemini MCP**: 最新情報取得、技術相談、実装判断支援
- **Serena**: インテリジェントなコード支援とプロジェクト管理
- **filesystem**: プロジェクトファイルの安全なアクセス
- **playwright**: デプロイ後のWebサイト動作確認・自動テスト
- **github**: GitHub Actions確認、Issues管理、PR操作

### GitHub MCP の活用例
```bash
# デプロイ状況の確認
GitHub Actions の最新実行結果を確認

# Issue 管理
新しいバグレポートや機能要望をIssueとして作成

# PR レビュー
Pull Request の作成・レビュー・マージ操作
```

### セキュリティ設定
- Personal Access Token は適切な権限のみ付与
- プロジェクトファイルのみアクセス許可
- `.env` ファイルや `node_modules` はアクセス禁止

## 🎯 プロジェクトビジョン

### 最高理念
**「一人の時間を、最高の冒険に」**

プレイヤーが自分自身と向き合い、思考を深め、達成感を得られる体験を提供する。シンプルな操作性の中に、無限の可能性と深い戦略性を秘めたゲーム体験の創造。

### プロジェクトの存在意義
- **孤独の価値化**: 一人の時間を退屈から解放し、充実した体験へ
- **アクセシビリティ**: いつでも、どこでも、誰でも楽しめる
- **成長の機会**: プレイを通じた思考力・戦略性の向上
- **純粋な楽しさ**: シンプルだからこそ生まれる本質的な面白さ

## 🏗️ 開発の心構え - 七つの約束

### 1. **プレイヤー体験至上主義**
```
決定時の復唱:
「この選択は、プレイヤーの体験を向上させるか？」
```
- すべての機能はプレイヤーの楽しさのために
- 複雑な実装より直感的な操作を優先
- フィードバックの即時性と明確性

### 2. **シンプリシティの追求**
```
実装時の復唱:
「もっとシンプルにできないか？」
```
- 最小限の要素で最大限の楽しさを
- 説明不要な直感的インターフェース
- 削ぎ落とす勇気を持つ

### 3. **漸進的進化**
```
リリース時の復唱:
「小さく始めて、大きく育てる」
```
- 完璧を求めず、まず動くものを
- フィードバックを基にした継続的改善
- 失敗を恐れない実験的精神
- とにかくデプロイまで到達する

### 4. **アクセシビリティの保証**
```
テスト時の復唱:
「誰もが楽しめる設計になっているか？」
```
- デバイスや環境に依存しない体験
- 多様なプレイスタイルへの対応
- インクルーシブなデザイン思考

### 5. **持続可能な開発**
```
計画時の復唱:
「長期的に維持・発展できる構造か？」
```
- 拡張性を考慮したアーキテクチャ
- 明確で保守しやすいコード
- ドキュメントの充実

### 6. **創造的な挑戦**
```
アイデア出し時の復唱:
「まだ誰も見たことのない体験を」
```
- 既存の枠にとらわれない発想
- 技術的制約を創造性で乗り越える
- プレイヤーを驚かせる仕掛け

### 7. **楽しむことの大切さ**
```
毎日の復唱:
「作る過程も、遊ぶように楽しもう」
```
- 開発者自身が最初のプレイヤー
- 情熱を持って取り組む
- 楽しさは必ず伝わる

## 🌟 期待される成果

### プレイヤーへの価値
- **即座の満足感**: すぐに始められ、すぐに楽しめる
- **持続的な興味**: 繰り返しプレイしたくなる深さ
- **個人的な成長**: スキルアップを実感できる設計
- **共有したくなる体験**: SNSでシェアしたくなる瞬間

### 技術的な達成
- **高速なレスポンス**: ストレスフリーな操作感
- **安定した動作**: どんな環境でも確実に動く
- **美しいコード**: 他の開発者が参考にしたくなる実装
- **革新的な手法**: 新しい可能性を示す

### 社会的なインパクト
- **孤独な時間の価値向上**: 一人の時間をポジティブに
- **デジタルウェルビーイング**: 健全なゲーム体験の提供
- **オープンソース貢献**: コミュニティへの還元
- **インスピレーション**: 他の開発者への刺激

## 🎮 ゲーム哲学

### 面白さの本質
- **発見の喜び**: 新しい戦略やパターンの発見
- **成長の実感**: 上達が明確に感じられる
- **適度な挑戦**: 簡単すぎず、難しすぎない絶妙なバランス
- **意味のある選択**: すべての行動に戦略的意味がある

### 一人用ゲームの美学
- **自己対話**: プレイを通じた内省の機会
- **マイペース**: 他者に急かされない自由
- **完全な没入**: 一人だからこその集中体験
- **個人的な達成**: 誰とも比較されない純粋な満足

## 🚀 実行の指針

### 日々の開発サイクル
1. **朝の宣言**: プロジェクトビジョンの確認
2. **実装**: プレイヤー視点での機能開発
3. **テストプレイ**: 楽しさの検証
4. **振り返り**: 改善点の発見
5. **次への準備**: 明日への引き継ぎ

### ⚠️ デプロイ時の必須確認事項
**「動いているはず」ではなく「動いていることを確認した」**
- 詳細は[デプロイ検証ガイドライン](./docs/development/DEPLOYMENT_VERIFICATION_GUIDE.md)を参照
- GitHub Actionsの成功を確認してから「デプロイ完了」と報告する
- 必ず本番環境での動作確認まで行う

### 🔄 小さなデプロイサイクル
```
実装時の復唱:
「TODOを1つ完了したら、即座にデプロイ」
```
- **1 TODO = 1 デプロイ**: 各タスク完了ごとにデプロイ実行
- **継続的な価値提供**: プレイヤーに頻繁に価値を届ける
- **早期フィードバック**: 問題の早期発見と修正
- **達成感の積み重ね**: 小さな成功体験の連続

#### デプロイサイクルの流れ
1. **TODO選択**: TodoWriteで管理されたタスクから1つ選択
2. **実装**: 機能を実装（必要に応じてSubAgentを活用）
3. **テスト**: 基本動作確認（lint/typecheck実行）
4. **コミット**: 変更をGitにコミット
5. **デプロイ**: GitHub Pagesへデプロイ（自動）
6. **確認**: デプロイされたサイトで動作確認
7. **TODO更新**: 完了をマークし、次のタスクへ

#### 推奨されるTODOサイズ
- **理想**: 30分〜2時間で完了できるサイズ
- **最大**: 半日以内に完了できること
- **分割**: 大きなタスクは必ず小さく分割

#### デプロイ失敗時の対応
1. エラーログを確認
2. 原因を特定（ビルドエラー、型エラー等）
3. 修正してすぐに再デプロイ
4. 成功するまで次のTODOに進まない

### 意思決定の基準
すべての決定において、以下の優先順位で判断する：
1. プレイヤーの楽しさ
2. アクセシビリティ
3. 技術的な健全性
4. 開発の持続可能性
5. 革新性

### クオリティの定義
- **動作**: 即座に反応し、決してフリーズしない
- **見た目**: シンプルで美しく、目に優しい
- **音**: 控えめで心地よいフィードバック（オプション）
- **操作感**: 直感的で気持ちいいインタラクション

## 🎓 継続的な学びと成長

### 開発者としての成長
- **技術力**: 新しい実装手法への挑戦
- **デザイン力**: UI/UXの深い理解
- **企画力**: 面白さを生み出す発想力
- **共感力**: プレイヤーの気持ちを理解する力

### プロジェクトの進化
- **機能の深化**: 既存機能の洗練
- **横への展開**: 新しいゲームモードの追加
- **コミュニティ形成**: プレイヤーとの対話
- **知識の共有**: 開発ノウハウの公開

## 💫 最後に

このプロジェクトは、単なるゲーム開発ではありません。
一人一人の大切な時間を、より豊かで意味のあるものに変える挑戦です。

技術的な完璧さよりも、プレイヤーの笑顔を。
複雑な機能よりも、シンプルな楽しさを。
他者との競争よりも、自分自身との対話を。

一人でも多くの人が、このゲームを通じて、
孤独な時間の素晴らしさを発見できますように。

---

**Remember**: 技術は手段、目的は人の幸せ。この原則を決して忘れないこと。

---

## 🔒 並行開発安全システム

### Claude Code Hooks による包括的システム保護

**破壊的システムコマンドと並行開発事故**から開発者を保護するため、以下のコマンドは**自動的に禁止**されます：

#### 🚨 CRITICAL - システム破壊コマンド（即座にブロック）
- `rm -rf /` `rm -rf ~` `rm -rf $HOME` - **ディレクトリ全削除**
- `dd if=/dev/zero of=/dev/sda` - **ディスク破壊**
- `:(){ :|:& };:` - **フォークボム（システムクラッシュ）**
- `chmod -R 000 /` - **権限破壊**
- `cat /etc/shadow` - **機密情報漏洩**
- `curl ... | bash` - **未検証スクリプト実行**

#### ⚠️ HIGH RISK - 並行開発リスク
- `git add .` - 一括追加は危険（個別ファイル指定必須）
- `git add -A` - 全体追加は危険
- `git add --all` - 全体追加は危険  
- `git add *` - ワイルドカード追加は危険

#### ✅ 推奨される安全な方法
```bash
# ❌ 危険：一括追加
git add .

# ✅ 安全：個別ファイル指定
git add src/components/GameCanvas.vue
git add src/domain/entities/Game.ts

# npm使用例
npm install lodash
```

#### 📋 フックシステムの機能
1. **Pre-Bash Hook**: 危険なコマンドの実行防止
2. **Post-Bash Hook**: コマンド実行結果の追跡
3. **Pre-Commit Hook**: コミット前の安全性チェック
4. **Task Complete Hook**: タスク完了時の次ステップ提案

#### 🔧 フックテスト
```bash
# フックシステムの動作確認
node .claude/test-hooks.cjs
```

#### 📊 ログ確認
全ての活動は `.claude/logs/` に記録されます：
- `bash-commands.log` - 実行コマンドの履歴
- `commit-checks.log` - コミット前チェック結果
- `task-completion.log` - タスク完了履歴

詳細は [`.claude/README.md`](.claude/README.md) を参照してください。

## 📁 ドキュメント管理ガイドライン

### ディレクトリ構造
```
insurance_game/
├── src/                    # ソースコード
├── public/                 # 静的アセット  
├── docs/
│   ├── design/            # 設計ドキュメント（正式仕様書）
│   ├── development/       # 開発ガイド（セットアップ、原則など）
│   ├── manual/           # ユーザーマニュアル
│   └── planning/         # 計画・進捗（ロードマップ、作業状況など）
├── scripts/              # 開発用スクリプト
│   ├── dev/             # 開発補助（*.bat、test-runner.jsなど）
│   └── setup/           # セットアップ用
├── .archive/            # アーカイブ（.gitignore対象）
│   └── YYYY-MM/        # 年月別に整理
└── README.md
```

### ドキュメント作成ルール

#### 1. メタデータを必ず記載
各ドキュメントの冒頭に以下を記載：
```markdown
> **最終更新**: YYYY/MM/DD  
> **文書種別**: 正式仕様書|作業記録|一時文書  
> **更新頻度**: 頻繁|定期的|完成後は変更なし
```

#### 2. 一時的なファイルの命名規則
- 作業記録・分析: `*_ANALYSIS_YYYY-MM-DD.md`
- 改善サマリー: `*_SUMMARY_YYYY-MM-DD.md`  
- 一時的な計画: `*_PLAN_YYYY-MM-DD.md`

#### 3. Living Documents（定期更新が必要）
- `WORK_STATUS.md` - 週次更新
- `TECHNICAL_DEBT_REPORT.md` - 月次更新
- `CHANGELOG.md` - **機能実装・変更時に必ず更新**

##### CHANGELOGの更新ルール
1. **必須更新タイミング**
   - 新機能の実装完了時
   - バグ修正時
   - 破壊的変更時
   - ドキュメント追加時

2. **記載内容**
   - `[Unreleased]` セクション: 今後のロードマップ（短期・中期・長期）
   - `[バージョン番号]` セクション: リリース済みの変更内容
   - 絵文字を使って視覚的に分かりやすく（🎮 新機能、🛠 変更、🐛 修正、📚 ドキュメント）
   - Added/Changed/Fixed/Documentationのカテゴリで整理

3. **ホーム画面との連携**
   - `src/App.vue`のホーム画面は最新バージョンの内容を表示
   - 詳細はCHANGELOG.mdへのリンクで確認可能
   - 変更時はApp.vueの表示も同時に更新すること

#### 4. アーカイブ方針
- 3ヶ月以上更新がない一時文書は`.archive/`へ移動
- 重複・統合されたファイルは即座にアーカイブ
- アーカイブ時は`YYYY-MM`ディレクトリに整理

#### 5. ファイル統合ルール
- 同じテーマの文書が複数ある場合は統合を検討
- 統合時は良い部分を組み合わせ、古いものはアーカイブ
- `*_REVISED`や`*_ENHANCED`などの派生版は正式版に昇格後、元をアーカイブ

### 禁止事項
- ❌ ルートディレクトリに一時的なファイルを作成しない
- ❌ 日付なしの`ANALYSIS.md`や`SUMMARY.md`を作らない
- ❌ 重複した内容のドキュメントを放置しない
- ❌ アーカイブなしにファイルを削除しない

### 推奨事項  
- ✅ 新しい分析や作業記録は日付付きファイル名で作成
- ✅ 定期的にファイル整理を実施（月1回程度）
- ✅ READMEに主要ドキュメントへのリンクを維持
- ✅ 不明なファイルは削除前に`.archive/`へ移動